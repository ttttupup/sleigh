<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>decompiler: Decoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classDecoder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Decoder Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for reading structured data from a stream.  
 <a href="classDecoder.html#details">More...</a></p>

<p><code>#include &lt;marshal.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Decoder:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classDecoder.png" usemap="#Decoder_map" alt=""/>
  <map id="Decoder_map" name="Decoder_map">
<area href="classPackedDecode.html" title="A byte-based decoder designed to marshal info to the decompiler efficiently. " alt="PackedDecode" shape="rect" coords="0,56,98,80"/>
<area href="classXmlDecode.html" title="An XML based decoder. " alt="XmlDecode" shape="rect" coords="108,56,206,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad742ab5418158e242bd8105561231143"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad742ab5418158e242bd8105561231143"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#ad742ab5418158e242bd8105561231143">Decoder</a> (const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *spc)</td></tr>
<tr class="memdesc:ad742ab5418158e242bd8105561231143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base constructor. <br/></td></tr>
<tr class="separator:ad742ab5418158e242bd8105561231143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e1c337c5263c056415259df22bc284"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7e1c337c5263c056415259df22bc284"></a>
const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#af7e1c337c5263c056415259df22bc284">getAddrSpaceManager</a> (void) const </td></tr>
<tr class="memdesc:af7e1c337c5263c056415259df22bc284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the manager used for address space decoding. <br/></td></tr>
<tr class="separator:af7e1c337c5263c056415259df22bc284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018cda43f7451dab35dfc6a4f262df46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a018cda43f7451dab35dfc6a4f262df46"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a018cda43f7451dab35dfc6a4f262df46">~Decoder</a> (void)</td></tr>
<tr class="memdesc:a018cda43f7451dab35dfc6a4f262df46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a018cda43f7451dab35dfc6a4f262df46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992d5adfdb5766ec56844e6d5c2d1457"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a992d5adfdb5766ec56844e6d5c2d1457">ingestStream</a> (istream &amp;s)=0</td></tr>
<tr class="memdesc:a992d5adfdb5766ec56844e6d5c2d1457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare to decode a given stream.  <a href="#a992d5adfdb5766ec56844e6d5c2d1457">More...</a><br/></td></tr>
<tr class="separator:a992d5adfdb5766ec56844e6d5c2d1457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a196e06e948a4ab4023fe0e5d129377"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a5a196e06e948a4ab4023fe0e5d129377">peekElement</a> (void)=0</td></tr>
<tr class="memdesc:a5a196e06e948a4ab4023fe0e5d129377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next child element of the current parent, without traversing in (opening) it.  <a href="#a5a196e06e948a4ab4023fe0e5d129377">More...</a><br/></td></tr>
<tr class="separator:a5a196e06e948a4ab4023fe0e5d129377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b21defb3b7d9023324df3bb8328c87f"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a9b21defb3b7d9023324df3bb8328c87f">openElement</a> (void)=0</td></tr>
<tr class="memdesc:a9b21defb3b7d9023324df3bb8328c87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open (traverse into) the next child element of the current parent.  <a href="#a9b21defb3b7d9023324df3bb8328c87f">More...</a><br/></td></tr>
<tr class="separator:a9b21defb3b7d9023324df3bb8328c87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6af23e00b46785ec0894c37a6f72d87"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#ac6af23e00b46785ec0894c37a6f72d87">openElement</a> (const <a class="el" href="classElementId.html">ElementId</a> &amp;elemId)=0</td></tr>
<tr class="memdesc:ac6af23e00b46785ec0894c37a6f72d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open (traverse into) the next child element, which must be of a specific type.  <a href="#ac6af23e00b46785ec0894c37a6f72d87">More...</a><br/></td></tr>
<tr class="separator:ac6af23e00b46785ec0894c37a6f72d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1837b91ab3c9d2a7f5b2711fe0a86a97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a1837b91ab3c9d2a7f5b2711fe0a86a97">closeElement</a> (uint4 id)=0</td></tr>
<tr class="memdesc:a1837b91ab3c9d2a7f5b2711fe0a86a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the current element.  <a href="#a1837b91ab3c9d2a7f5b2711fe0a86a97">More...</a><br/></td></tr>
<tr class="separator:a1837b91ab3c9d2a7f5b2711fe0a86a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a59712041e1dc3f7185440d665b3d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a36a59712041e1dc3f7185440d665b3d3">closeElementSkipping</a> (uint4 id)=0</td></tr>
<tr class="memdesc:a36a59712041e1dc3f7185440d665b3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the current element, skipping any child elements that have not yet been parsed.  <a href="#a36a59712041e1dc3f7185440d665b3d3">More...</a><br/></td></tr>
<tr class="separator:a36a59712041e1dc3f7185440d665b3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98ca46e0ea39c4ce713d4b14bc44772"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#ad98ca46e0ea39c4ce713d4b14bc44772">getNextAttributeId</a> (void)=0</td></tr>
<tr class="memdesc:ad98ca46e0ea39c4ce713d4b14bc44772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next attribute id for the current element.  <a href="#ad98ca46e0ea39c4ce713d4b14bc44772">More...</a><br/></td></tr>
<tr class="separator:ad98ca46e0ea39c4ce713d4b14bc44772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90d9a4d81b76e608dd59614c8259231"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#af90d9a4d81b76e608dd59614c8259231">rewindAttributes</a> (void)=0</td></tr>
<tr class="memdesc:af90d9a4d81b76e608dd59614c8259231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset attribute traversal for the current element.  <a href="#af90d9a4d81b76e608dd59614c8259231">More...</a><br/></td></tr>
<tr class="separator:af90d9a4d81b76e608dd59614c8259231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a25fdd41dff502755f8c142c5a59d8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a41a25fdd41dff502755f8c142c5a59d8">readBool</a> (void)=0</td></tr>
<tr class="memdesc:a41a25fdd41dff502755f8c142c5a59d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as a boolean value.  <a href="#a41a25fdd41dff502755f8c142c5a59d8">More...</a><br/></td></tr>
<tr class="separator:a41a25fdd41dff502755f8c142c5a59d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af097ef2bdd296e892cc4c1c48639693e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#af097ef2bdd296e892cc4c1c48639693e">readBool</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)=0</td></tr>
<tr class="memdesc:af097ef2bdd296e892cc4c1c48639693e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as a boolean value.  <a href="#af097ef2bdd296e892cc4c1c48639693e">More...</a><br/></td></tr>
<tr class="separator:af097ef2bdd296e892cc4c1c48639693e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c617582ce9540eca9519accbb8ee00"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a88c617582ce9540eca9519accbb8ee00">readSignedInteger</a> (void)=0</td></tr>
<tr class="memdesc:a88c617582ce9540eca9519accbb8ee00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as a signed integer value.  <a href="#a88c617582ce9540eca9519accbb8ee00">More...</a><br/></td></tr>
<tr class="separator:a88c617582ce9540eca9519accbb8ee00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59999a0af09a7b5654fdb08febe7f3eb"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a59999a0af09a7b5654fdb08febe7f3eb">readSignedInteger</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)=0</td></tr>
<tr class="memdesc:a59999a0af09a7b5654fdb08febe7f3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as a signed integer.  <a href="#a59999a0af09a7b5654fdb08febe7f3eb">More...</a><br/></td></tr>
<tr class="separator:a59999a0af09a7b5654fdb08febe7f3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3deb10c5112cb984390b7a14262202"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a4e3deb10c5112cb984390b7a14262202">readSignedIntegerExpectString</a> (const string &amp;expect, intb expectval)=0</td></tr>
<tr class="memdesc:a4e3deb10c5112cb984390b7a14262202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as either a signed integer value or a string.  <a href="#a4e3deb10c5112cb984390b7a14262202">More...</a><br/></td></tr>
<tr class="separator:a4e3deb10c5112cb984390b7a14262202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af003e43112b4d358a0d24b653de72d13"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#af003e43112b4d358a0d24b653de72d13">readSignedIntegerExpectString</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId, const string &amp;expect, intb expectval)=0</td></tr>
<tr class="memdesc:af003e43112b4d358a0d24b653de72d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as either a signed integer or a string.  <a href="#af003e43112b4d358a0d24b653de72d13">More...</a><br/></td></tr>
<tr class="separator:af003e43112b4d358a0d24b653de72d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738ae1f9145b933f70748cf039afe847"><td class="memItemLeft" align="right" valign="top">virtual uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a738ae1f9145b933f70748cf039afe847">readUnsignedInteger</a> (void)=0</td></tr>
<tr class="memdesc:a738ae1f9145b933f70748cf039afe847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as an unsigned integer value.  <a href="#a738ae1f9145b933f70748cf039afe847">More...</a><br/></td></tr>
<tr class="separator:a738ae1f9145b933f70748cf039afe847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f34bd56b4fce89f77d93135aeb5a57"><td class="memItemLeft" align="right" valign="top">virtual uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#af6f34bd56b4fce89f77d93135aeb5a57">readUnsignedInteger</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)=0</td></tr>
<tr class="memdesc:af6f34bd56b4fce89f77d93135aeb5a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as an unsigned integer.  <a href="#af6f34bd56b4fce89f77d93135aeb5a57">More...</a><br/></td></tr>
<tr class="separator:af6f34bd56b4fce89f77d93135aeb5a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206874f59d968db5904c0d39ad6bfdee"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a206874f59d968db5904c0d39ad6bfdee">readString</a> (void)=0</td></tr>
<tr class="memdesc:a206874f59d968db5904c0d39ad6bfdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as a string.  <a href="#a206874f59d968db5904c0d39ad6bfdee">More...</a><br/></td></tr>
<tr class="separator:a206874f59d968db5904c0d39ad6bfdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4403ec4674a01b257d4cb2494a40b25b"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a4403ec4674a01b257d4cb2494a40b25b">readString</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)=0</td></tr>
<tr class="memdesc:a4403ec4674a01b257d4cb2494a40b25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the specific attribute in the current element and return it as a string.  <a href="#a4403ec4674a01b257d4cb2494a40b25b">More...</a><br/></td></tr>
<tr class="separator:a4403ec4674a01b257d4cb2494a40b25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698792800d19dede5dc90f8d091a0efb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a698792800d19dede5dc90f8d091a0efb">readSpace</a> (void)=0</td></tr>
<tr class="memdesc:a698792800d19dede5dc90f8d091a0efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as an address space.  <a href="#a698792800d19dede5dc90f8d091a0efb">More...</a><br/></td></tr>
<tr class="separator:a698792800d19dede5dc90f8d091a0efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d2b96ed213096d7cc93a85c2e3c030"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#ac5d2b96ed213096d7cc93a85c2e3c030">readSpace</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)=0</td></tr>
<tr class="memdesc:ac5d2b96ed213096d7cc93a85c2e3c030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the specific attribute in the current element and return it as an address space.  <a href="#ac5d2b96ed213096d7cc93a85c2e3c030">More...</a><br/></td></tr>
<tr class="separator:ac5d2b96ed213096d7cc93a85c2e3c030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bc3e4fc9f888c1ee13b50afaa23103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#ad7bc3e4fc9f888c1ee13b50afaa23103">skipElement</a> (void)</td></tr>
<tr class="memdesc:ad7bc3e4fc9f888c1ee13b50afaa23103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip parsing of the next element.  <a href="#ad7bc3e4fc9f888c1ee13b50afaa23103">More...</a><br/></td></tr>
<tr class="separator:ad7bc3e4fc9f888c1ee13b50afaa23103"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1710afd881dc823cd5920692685c47af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1710afd881dc823cd5920692685c47af"></a>
const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a1710afd881dc823cd5920692685c47af">spcManager</a></td></tr>
<tr class="memdesc:a1710afd881dc823cd5920692685c47af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager for decoding address space attributes. <br/></td></tr>
<tr class="separator:a1710afd881dc823cd5920692685c47af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for reading structured data from a stream. </p>
<p>All data is loosely structured as with an XML document. A document contains a nested set of <b>elements</b>, with labels corresponding to the <a class="el" href="classElementId.html" title="An annotation for a specific collection of hierarchical data. ">ElementId</a> class. A single element can hold zero or more attributes and zero or more child elements. An attribute holds a primitive data element (bool, integer, string) and is labeled by an <a class="el" href="classAttributeId.html" title="An annotation for a data element to being transferred to/from a stream. ">AttributeId</a>. The document is traversed using a sequence of <a class="el" href="classDecoder.html#a9b21defb3b7d9023324df3bb8328c87f" title="Open (traverse into) the next child element of the current parent. ">openElement()</a> and <a class="el" href="classDecoder.html#a1837b91ab3c9d2a7f5b2711fe0a86a97" title="Close the current element. ">closeElement()</a> calls, intermixed with read*() calls to extract the data. The elements are traversed in a depth first order. <a class="el" href="classAttributes.html" title="The attributes for a single XML element. ">Attributes</a> within an element can be traversed in order using repeated calls to the <a class="el" href="classDecoder.html#ad98ca46e0ea39c4ce713d4b14bc44772" title="Get the next attribute id for the current element. ">getNextAttributeId()</a> method, followed by a calls to one of the read*(void) methods to extract the data. Alternately a read*(<a class="el" href="classAttributeId.html" title="An annotation for a data element to being transferred to/from a stream. ">AttributeId</a>) call can be used to extract data for an attribute known to be in the element. There is a special content attribute whose data can be extracted using a read*(<a class="el" href="classAttributeId.html" title="An annotation for a data element to being transferred to/from a stream. ">AttributeId</a>) call that is passed the special ATTRIB_CONTENT id. This attribute will not be traversed by getNextAttribute(). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1837b91ab3c9d2a7f5b2711fe0a86a97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Decoder::closeElement </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the current element. </p>
<p>The data for the current element is considered fully processed. If the element has additional children, an exception is thrown. The stream must indicate the end of the element in some way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the id of the element to close (which must be the current element) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a072589c17be02ccbdeffacae41e39095">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#aa8e50db3b9a26f220bdca3b2e0c9a901">XmlDecode</a>.</p>

<p>Referenced by <a class="el" href="structVarnodeData.html#ad49ee972626e66aab1748a35f0b65a32">VarnodeData::decode()</a>, <a class="el" href="structTrackedContext.html#af6e2915e58a191821ba548016453e7a8">TrackedContext::decode()</a>, <a class="el" href="classTruncationTag.html#a6bb1d24f754e8be9a9d1ca850b1c1d72">TruncationTag::decode()</a>, <a class="el" href="classPcodeOpRaw.html#ae4a09db78b969a104972d9b7d3ca0093">PcodeOpRaw::decode()</a>, <a class="el" href="classSeqNum.html#aadb2fd8dadd48274d5f36d78d9dc96de">SeqNum::decode()</a>, <a class="el" href="classAddrSpace.html#acfbc31fbef23911b81173b7c93b24543">AddrSpace::decode()</a>, <a class="el" href="classSpacebaseSpace.html#a8a430a27ade5a8703c520656bb5ed10f">SpacebaseSpace::decode()</a>, <a class="el" href="classRange.html#a23f8a6f7123a475bc3bb7001366f8f64">Range::decode()</a>, <a class="el" href="classRangeProperties.html#ac864e28aa9da0a8aa6c4d758122b46b4">RangeProperties::decode()</a>, <a class="el" href="classRangeList.html#a450046ce22bee16d16b504424b537d14">RangeList::decode()</a>, <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>, <a class="el" href="classContextInternal.html#a2824aafb3952175a5d60996ecccc1695">ContextInternal::decode()</a>, <a class="el" href="classContextInternal.html#aaad693556b2167c3c005b12f930b9a5a">ContextInternal::decodeContext()</a>, <a class="el" href="classContextInternal.html#a900e3828df187403df5b50a97be7a9fc">ContextInternal::decodeFromSpec()</a>, <a class="el" href="classPcodeEmit.html#a1d37f1622ef8a60cee7bc559a1eabeec">PcodeEmit::decodeOp()</a>, and <a class="el" href="classAddrSpaceManager.html#aee56defff6dfb953555b001afb3a84ea">AddrSpaceManager::decodeSpaces()</a>.</p>

</div>
</div>
<a class="anchor" id="a36a59712041e1dc3f7185440d665b3d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Decoder::closeElementSkipping </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the current element, skipping any child elements that have not yet been parsed. </p>
<p>This closes the given element, which must be current. If there are child elements that have not been parsed, this is not considered an error, and they are skipped over in the parse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the id of the element to close (which must be the current element) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#af881a670a80b2fe553e073c2cde11060">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a084dcab64aaceb413b66a93ccf1e7970">XmlDecode</a>.</p>

<p>Referenced by <a class="el" href="classDecoder.html#ad7bc3e4fc9f888c1ee13b50afaa23103">skipElement()</a>.</p>

</div>
</div>
<a class="anchor" id="ad98ca46e0ea39c4ce713d4b14bc44772"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint4 Decoder::getNextAttributeId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next attribute id for the current element. </p>
<p><a class="el" href="classAttributes.html" title="The attributes for a single XML element. ">Attributes</a> are automatically set up for traversal using this method, when the element is opened. If all attributes have been traversed (or there are no attributes), 0 is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the id of the next attribute or 0 </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a5c87996b51a654de0dcce6da2dc6f094">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#ad696ae2412f215cdf74ea373d7d9be3c">XmlDecode</a>.</p>

<p>Referenced by <a class="el" href="classSeqNum.html#aadb2fd8dadd48274d5f36d78d9dc96de">SeqNum::decode()</a>, <a class="el" href="classRangeProperties.html#ac864e28aa9da0a8aa6c4d758122b46b4">RangeProperties::decode()</a>, <a class="el" href="classContextInternal.html#a2824aafb3952175a5d60996ecccc1695">ContextInternal::decode()</a>, <a class="el" href="classAddrSpace.html#acfd61654ef34bec85e16360eeb08e31d">AddrSpace::decodeAttributes()</a>, <a class="el" href="classJoinSpace.html#a782272458968df7a727e7d6280edc8d8">JoinSpace::decodeAttributes()</a>, <a class="el" href="classAddrSpace.html#acc7365b29fa5cf7d650af0552ceb26a9">AddrSpace::decodeBasicAttributes()</a>, <a class="el" href="structVarnodeData.html#ad620f74a51a72a652bf518571e351957">VarnodeData::decodeFromAttributes()</a>, and <a class="el" href="classRange.html#a94744dd422421a5578aaca9fb6f382bf">Range::decodeFromAttributes()</a>.</p>

</div>
</div>
<a class="anchor" id="a992d5adfdb5766ec56844e6d5c2d1457"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Decoder::ingestStream </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare to decode a given stream. </p>
<p>Called once before any decoding. Currently this is assumed to make an internal copy of the stream data, i.e. the input stream is cleared before any decoding takes place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the given input stream to be decode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the stream was fully ingested </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#acfcb78a9e069071bd9a23c70c995284a">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a9039549449d97bdd27f2e316db7a9052">XmlDecode</a>.</p>

</div>
</div>
<a class="anchor" id="a9b21defb3b7d9023324df3bb8328c87f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint4 Decoder::openElement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open (traverse into) the next child element of the current parent. </p>
<p>The child becomes the current parent. The list of attributes is initialized for use with getNextAttributeId. </p>
<dl class="section return"><dt>Returns</dt><dd>the id of the child element </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a90f902925e06098a3c437dc099732fe7">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a3ab85b69a8ea29222626340d23be11a4">XmlDecode</a>.</p>

<p>Referenced by <a class="el" href="structVarnodeData.html#ad49ee972626e66aab1748a35f0b65a32">VarnodeData::decode()</a>, <a class="el" href="structTrackedContext.html#af6e2915e58a191821ba548016453e7a8">TrackedContext::decode()</a>, <a class="el" href="classTruncationTag.html#a6bb1d24f754e8be9a9d1ca850b1c1d72">TruncationTag::decode()</a>, <a class="el" href="classPcodeOpRaw.html#ae4a09db78b969a104972d9b7d3ca0093">PcodeOpRaw::decode()</a>, <a class="el" href="classSeqNum.html#aadb2fd8dadd48274d5f36d78d9dc96de">SeqNum::decode()</a>, <a class="el" href="classAddrSpace.html#acfbc31fbef23911b81173b7c93b24543">AddrSpace::decode()</a>, <a class="el" href="classSpacebaseSpace.html#a8a430a27ade5a8703c520656bb5ed10f">SpacebaseSpace::decode()</a>, <a class="el" href="classRange.html#a23f8a6f7123a475bc3bb7001366f8f64">Range::decode()</a>, <a class="el" href="classRangeProperties.html#ac864e28aa9da0a8aa6c4d758122b46b4">RangeProperties::decode()</a>, <a class="el" href="classRangeList.html#a450046ce22bee16d16b504424b537d14">RangeList::decode()</a>, <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>, <a class="el" href="classContextInternal.html#a2824aafb3952175a5d60996ecccc1695">ContextInternal::decode()</a>, <a class="el" href="classContextInternal.html#aaad693556b2167c3c005b12f930b9a5a">ContextInternal::decodeContext()</a>, <a class="el" href="classContextInternal.html#a900e3828df187403df5b50a97be7a9fc">ContextInternal::decodeFromSpec()</a>, <a class="el" href="classPcodeEmit.html#a1d37f1622ef8a60cee7bc559a1eabeec">PcodeEmit::decodeOp()</a>, <a class="el" href="classAddrSpaceManager.html#aee56defff6dfb953555b001afb3a84ea">AddrSpaceManager::decodeSpaces()</a>, and <a class="el" href="classDecoder.html#ad7bc3e4fc9f888c1ee13b50afaa23103">skipElement()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6af23e00b46785ec0894c37a6f72d87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint4 Decoder::openElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElementId.html">ElementId</a> &amp;&#160;</td>
          <td class="paramname"><em>elemId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open (traverse into) the next child element, which must be of a specific type. </p>
<p>The child becomes the current parent, and its attributes are initialized for use with getNextAttributeId. The child must match the given element id or an exception is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elemId</td><td>is the given element id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the child element </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a8b571789fcf41713b8bd7d8e8041a2ff">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#ae9b9beb021c1ce4c9160524b14155e96">XmlDecode</a>.</p>

</div>
</div>
<a class="anchor" id="a5a196e06e948a4ab4023fe0e5d129377"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint4 Decoder::peekElement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at the next child element of the current parent, without traversing in (opening) it. </p>
<p>The element id is returned, which can be compared to <a class="el" href="classElementId.html" title="An annotation for a specific collection of hierarchical data. ">ElementId</a> labels. If there are no remaining child elements to traverse, 0 is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the element id or 0 </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a919a4c874a926b3d1a74e68c8dde86e1">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#af6c7ee140e1b6675b0f54a3865377be8">XmlDecode</a>.</p>

<p>Referenced by <a class="el" href="classPcodeOpRaw.html#ae4a09db78b969a104972d9b7d3ca0093">PcodeOpRaw::decode()</a>, <a class="el" href="classRangeList.html#a450046ce22bee16d16b504424b537d14">RangeList::decode()</a>, <a class="el" href="classAddrSpaceManager.html#aa028e435f3e8f6a1f2c7d4c462089af0">AddrSpaceManager::decodeSpace()</a>, <a class="el" href="classAddrSpaceManager.html#aee56defff6dfb953555b001afb3a84ea">AddrSpaceManager::decodeSpaces()</a>, and <a class="el" href="classContextDatabase.html#a1389a93b8bd64400fb62eba160d23a05">ContextDatabase::decodeTracked()</a>.</p>

</div>
</div>
<a class="anchor" id="a41a25fdd41dff502755f8c142c5a59d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Decoder::readBool </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as a boolean value. </p>
<p>The last attribute, as returned by getNextAttributeId, is treated as a boolean, and its value is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the boolean value associated with the current attribute. </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a7af7102b4a55e29e26a0da50f33d99b0">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a9a13d4fbff3bc5e7ab88f718d1594d65">XmlDecode</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpace.html#acc7365b29fa5cf7d650af0552ceb26a9">AddrSpace::decodeBasicAttributes()</a>.</p>

</div>
</div>
<a class="anchor" id="af097ef2bdd296e892cc4c1c48639693e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Decoder::readBool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as a boolean value. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then parsed as a boolean and its value returned. If there is no attribute matching the id, an exception is thrown. Parsing via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean value </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#ab03c6ebf3f561e5353ee1319fdc4162a">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#af329fb28ce197553092af8d07e9d5dc6">XmlDecode</a>.</p>

</div>
</div>
<a class="anchor" id="a88c617582ce9540eca9519accbb8ee00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual intb Decoder::readSignedInteger </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as a signed integer value. </p>
<p>The last attribute, as returned by getNextAttributeId, is treated as a signed integer, and its value is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the signed integer value associated with the current attribute. </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a348412434319f578505367b0ff225dcc">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a6c5b7686e66310aa5d13534bd0d7dbe3">XmlDecode</a>.</p>

<p>Referenced by <a class="el" href="classPcodeOpRaw.html#ae4a09db78b969a104972d9b7d3ca0093">PcodeOpRaw::decode()</a>, <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>, <a class="el" href="classAddrSpace.html#acfd61654ef34bec85e16360eeb08e31d">AddrSpace::decodeAttributes()</a>, <a class="el" href="classAddrSpace.html#acc7365b29fa5cf7d650af0552ceb26a9">AddrSpace::decodeBasicAttributes()</a>, and <a class="el" href="classPcodeEmit.html#a1d37f1622ef8a60cee7bc559a1eabeec">PcodeEmit::decodeOp()</a>.</p>

</div>
</div>
<a class="anchor" id="a59999a0af09a7b5654fdb08febe7f3eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual intb Decoder::readSignedInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as a signed integer. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then parsed as a signed integer and its value returned. If there is no attribute matching the id, an exception is thrown. Parsing via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the signed integer value </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#ade2eb1984afead4ee24cf9b70ce3b2ba">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#af90f328dc0c346d8323aa8e32bbe60a7">XmlDecode</a>.</p>

</div>
</div>
<a class="anchor" id="a4e3deb10c5112cb984390b7a14262202"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual intb Decoder::readSignedIntegerExpectString </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>expect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intb&#160;</td>
          <td class="paramname"><em>expectval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as either a signed integer value or a string. </p>
<p>If the attribute is an integer, its value is returned. If the attribute is a string, it must match an expected string passed to the method, and a predetermined integer value associated with the string is returned. If the attribute neither matches the expected string nor is an integer, the return value is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expect</td><td>is the string value to expect if the attribute is encoded as a string </td></tr>
    <tr><td class="paramname">expectval</td><td>is the integer value to return if the attribute matches the expected string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoded integer or the integer value associated with the expected string </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a2ed06cb62e12a3fbeecf2756ef1c6590">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#afbf043fa2688d7732fa6990052a70a4c">XmlDecode</a>.</p>

</div>
</div>
<a class="anchor" id="af003e43112b4d358a0d24b653de72d13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual intb Decoder::readSignedIntegerExpectString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>expect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intb&#160;</td>
          <td class="paramname"><em>expectval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as either a signed integer or a string. </p>
<p>If the attribute is an integer, its value is parsed and returned. If the attribute is encoded as a string, it must match an expected string passed to this method. In this case, a predetermined integer value is passed back, indicating a matching string was parsed. If the attribute neither matches the expected string nor is an integer, the return value is undefined. If there is no attribute matching the id, an exception is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
    <tr><td class="paramname">expect</td><td>is the string to expect, if the attribute is not encoded as an integer </td></tr>
    <tr><td class="paramname">expectval</td><td>is the integer value to return if the attribute matches the expected string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoded integer or the integer value associated with the expected string </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#ae4a08bead1c9dfab1e86a8d20ed10c26">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a211b48088ce1256f335fca2102028599">XmlDecode</a>.</p>

</div>
</div>
<a class="anchor" id="a698792800d19dede5dc90f8d091a0efb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classAddrSpace.html">AddrSpace</a>* Decoder::readSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as an address space. </p>
<p>The last attribute, as returned by getNextAttributeId, is returned as an address space. </p>
<dl class="section return"><dt>Returns</dt><dd>the address space associated with the current attribute. </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#abba3d18f2a01441d0a0df619df46066e">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a372e9e97f1e9a9ee2e3ca456d3bfd802">XmlDecode</a>.</p>

<p>Referenced by <a class="el" href="classPcodeOpRaw.html#ae4a09db78b969a104972d9b7d3ca0093">PcodeOpRaw::decode()</a>, <a class="el" href="classSpacebaseSpace.html#a8a430a27ade5a8703c520656bb5ed10f">SpacebaseSpace::decode()</a>, <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>, <a class="el" href="structVarnodeData.html#ad620f74a51a72a652bf518571e351957">VarnodeData::decodeFromAttributes()</a>, and <a class="el" href="classRange.html#a94744dd422421a5578aaca9fb6f382bf">Range::decodeFromAttributes()</a>.</p>

</div>
</div>
<a class="anchor" id="ac5d2b96ed213096d7cc93a85c2e3c030"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classAddrSpace.html">AddrSpace</a>* Decoder::readSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the specific attribute in the current element and return it as an address space. </p>
<p>Search attributes from the current element for a match to the given attribute id. Return this attribute as an address space. If there is no attribute matching the id, an exception is thrown. Parse via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address space associated with the attribute </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#aadc8290dd84387e11f78059768cf7402">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a7b15c5b9229daf7b662438ce5958952a">XmlDecode</a>.</p>

</div>
</div>
<a class="anchor" id="a206874f59d968db5904c0d39ad6bfdee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string Decoder::readString </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as a string. </p>
<p>The last attribute, as returned by getNextAttributeId, is returned as a string. </p>
<dl class="section return"><dt>Returns</dt><dd>the string associated with the current attribute. </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a75cb2804b7762e2419ef28317a298ef5">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a3b6017dcf41117fc94070b2ea603190f">XmlDecode</a>.</p>

<p>Referenced by <a class="el" href="classTruncationTag.html#a6bb1d24f754e8be9a9d1ca850b1c1d72">TruncationTag::decode()</a>, <a class="el" href="classRangeProperties.html#ac864e28aa9da0a8aa6c4d758122b46b4">RangeProperties::decode()</a>, <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>, <a class="el" href="classJoinSpace.html#a782272458968df7a727e7d6280edc8d8">JoinSpace::decodeAttributes()</a>, <a class="el" href="classAddrSpace.html#acc7365b29fa5cf7d650af0552ceb26a9">AddrSpace::decodeBasicAttributes()</a>, <a class="el" href="classContextInternal.html#aaad693556b2167c3c005b12f930b9a5a">ContextInternal::decodeContext()</a>, <a class="el" href="structVarnodeData.html#ad620f74a51a72a652bf518571e351957">VarnodeData::decodeFromAttributes()</a>, <a class="el" href="classRange.html#a94744dd422421a5578aaca9fb6f382bf">Range::decodeFromAttributes()</a>, and <a class="el" href="classAddrSpaceManager.html#aee56defff6dfb953555b001afb3a84ea">AddrSpaceManager::decodeSpaces()</a>.</p>

</div>
</div>
<a class="anchor" id="a4403ec4674a01b257d4cb2494a40b25b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual string Decoder::readString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the specific attribute in the current element and return it as a string. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then returned as a string. If there is no attribute matching the id, and exception is thrown. Parse via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string associated with the attribute </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a7a3e35a8ae3d45c6108480a5204442e0">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a98f0b91832a3d9647dab65c5f9634d98">XmlDecode</a>.</p>

</div>
</div>
<a class="anchor" id="a738ae1f9145b933f70748cf039afe847"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uintb Decoder::readUnsignedInteger </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as an unsigned integer value. </p>
<p>The last attribute, as returned by getNextAttributeId, is treated as an unsigned integer, and its value is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the unsigned integer value associated with the current attribute. </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a54ca75cfef14da4da656b45bbb3b2277">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a0c0413c852158d3219633bf6d10a6984">XmlDecode</a>.</p>

<p>Referenced by <a class="el" href="structTrackedContext.html#af6e2915e58a191821ba548016453e7a8">TrackedContext::decode()</a>, <a class="el" href="classTruncationTag.html#a6bb1d24f754e8be9a9d1ca850b1c1d72">TruncationTag::decode()</a>, <a class="el" href="classSeqNum.html#aadb2fd8dadd48274d5f36d78d9dc96de">SeqNum::decode()</a>, <a class="el" href="classRangeProperties.html#ac864e28aa9da0a8aa6c4d758122b46b4">RangeProperties::decode()</a>, <a class="el" href="classAddrSpace.html#acfd61654ef34bec85e16360eeb08e31d">AddrSpace::decodeAttributes()</a>, <a class="el" href="classJoinSpace.html#a782272458968df7a727e7d6280edc8d8">JoinSpace::decodeAttributes()</a>, <a class="el" href="classAddrSpace.html#acc7365b29fa5cf7d650af0552ceb26a9">AddrSpace::decodeBasicAttributes()</a>, <a class="el" href="classContextInternal.html#aaad693556b2167c3c005b12f930b9a5a">ContextInternal::decodeContext()</a>, and <a class="el" href="classRange.html#a94744dd422421a5578aaca9fb6f382bf">Range::decodeFromAttributes()</a>.</p>

</div>
</div>
<a class="anchor" id="af6f34bd56b4fce89f77d93135aeb5a57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uintb Decoder::readUnsignedInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as an unsigned integer. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then parsed as an unsigned integer and its value returned. If there is no attribute matching the id, an exception is thrown. Parsing via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unsigned integer value </dd></dl>

<p>Implemented in <a class="el" href="classPackedDecode.html#a252d98ec98bf2ee2697b051f7fdc5875">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#a5f460096d7bcde0a84e96099d534da6a">XmlDecode</a>.</p>

</div>
</div>
<a class="anchor" id="af90d9a4d81b76e608dd59614c8259231"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Decoder::rewindAttributes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset attribute traversal for the current element. </p>
<p><a class="el" href="classAttributes.html" title="The attributes for a single XML element. ">Attributes</a> for a single element can be traversed more than once using the getNextAttributeId method. </p>

<p>Implemented in <a class="el" href="classPackedDecode.html#a0e28399b23ef28d6d07ae93dcceeb6df">PackedDecode</a>, and <a class="el" href="classXmlDecode.html#acfe976dd55bf980879066e4180686e2b">XmlDecode</a>.</p>

<p>Referenced by <a class="el" href="classContextInternal.html#a2824aafb3952175a5d60996ecccc1695">ContextInternal::decode()</a>, and <a class="el" href="structVarnodeData.html#ad620f74a51a72a652bf518571e351957">VarnodeData::decodeFromAttributes()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7bc3e4fc9f888c1ee13b50afaa23103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Decoder::skipElement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip parsing of the next element. </p>
<p>The element skipped is the one that would be opened by the next call to openElement. </p>

<p>References <a class="el" href="classDecoder.html#a36a59712041e1dc3f7185440d665b3d3">closeElementSkipping()</a>, and <a class="el" href="classDecoder.html#a9b21defb3b7d9023324df3bb8328c87f">openElement()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>marshal.hh</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
