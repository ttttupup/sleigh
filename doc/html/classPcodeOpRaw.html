<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>decompiler: PcodeOpRaw Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classPcodeOpRaw-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PcodeOpRaw Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A low-level representation of a single pcode operation.  
 <a href="classPcodeOpRaw.html#details">More...</a></p>

<p><code>#include &lt;pcoderaw.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a294ebc1a204972cfdc831faf6aff3f48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#a294ebc1a204972cfdc831faf6aff3f48">setBehavior</a> (<a class="el" href="classOpBehavior.html">OpBehavior</a> *be)</td></tr>
<tr class="memdesc:a294ebc1a204972cfdc831faf6aff3f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the opcode for this op.  <a href="#a294ebc1a204972cfdc831faf6aff3f48">More...</a><br/></td></tr>
<tr class="separator:a294ebc1a204972cfdc831faf6aff3f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f8ffb85aa33536fc6cc34cd87eb578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpBehavior.html">OpBehavior</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#a19f8ffb85aa33536fc6cc34cd87eb578">getBehavior</a> (void) const </td></tr>
<tr class="memdesc:a19f8ffb85aa33536fc6cc34cd87eb578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the behavior for this op.  <a href="#a19f8ffb85aa33536fc6cc34cd87eb578">More...</a><br/></td></tr>
<tr class="separator:a19f8ffb85aa33536fc6cc34cd87eb578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3ff9ab2edc1397b4f88b8d042f59b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#a7c3ff9ab2edc1397b4f88b8d042f59b8">getOpcode</a> (void) const </td></tr>
<tr class="memdesc:a7c3ff9ab2edc1397b4f88b8d042f59b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the opcode for this op.  <a href="#a7c3ff9ab2edc1397b4f88b8d042f59b8">More...</a><br/></td></tr>
<tr class="separator:a7c3ff9ab2edc1397b4f88b8d042f59b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabdf56ea3e97062b7daf2af34f741a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#afabdf56ea3e97062b7daf2af34f741a1">setSeqNum</a> (const <a class="el" href="classAddress.html">Address</a> &amp;a, uintm b)</td></tr>
<tr class="memdesc:afabdf56ea3e97062b7daf2af34f741a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sequence number.  <a href="#afabdf56ea3e97062b7daf2af34f741a1">More...</a><br/></td></tr>
<tr class="separator:afabdf56ea3e97062b7daf2af34f741a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac672e63a7df7797e6fed85e550f951f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSeqNum.html">SeqNum</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#ac672e63a7df7797e6fed85e550f951f6">getSeqNum</a> (void) const </td></tr>
<tr class="memdesc:ac672e63a7df7797e6fed85e550f951f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the sequence number.  <a href="#ac672e63a7df7797e6fed85e550f951f6">More...</a><br/></td></tr>
<tr class="separator:ac672e63a7df7797e6fed85e550f951f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714014825db274fc64f32a07d4022451"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#a714014825db274fc64f32a07d4022451">getAddr</a> (void) const </td></tr>
<tr class="memdesc:a714014825db274fc64f32a07d4022451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address of this operation.  <a href="#a714014825db274fc64f32a07d4022451">More...</a><br/></td></tr>
<tr class="separator:a714014825db274fc64f32a07d4022451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c25e2a933548b236169924aa3b40d46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#a1c25e2a933548b236169924aa3b40d46">setOutput</a> (<a class="el" href="structVarnodeData.html">VarnodeData</a> *o)</td></tr>
<tr class="memdesc:a1c25e2a933548b236169924aa3b40d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output varnode for this op.  <a href="#a1c25e2a933548b236169924aa3b40d46">More...</a><br/></td></tr>
<tr class="separator:a1c25e2a933548b236169924aa3b40d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d788f96b3e90ce150fb8a9cec92fe51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVarnodeData.html">VarnodeData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#a5d788f96b3e90ce150fb8a9cec92fe51">getOutput</a> (void) const </td></tr>
<tr class="memdesc:a5d788f96b3e90ce150fb8a9cec92fe51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the output varnode for this op.  <a href="#a5d788f96b3e90ce150fb8a9cec92fe51">More...</a><br/></td></tr>
<tr class="separator:a5d788f96b3e90ce150fb8a9cec92fe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd56b621ed3037ffa2cd015ca77406c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#acd56b621ed3037ffa2cd015ca77406c0">addInput</a> (<a class="el" href="structVarnodeData.html">VarnodeData</a> *i)</td></tr>
<tr class="memdesc:acd56b621ed3037ffa2cd015ca77406c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an additional input varnode to this op.  <a href="#acd56b621ed3037ffa2cd015ca77406c0">More...</a><br/></td></tr>
<tr class="separator:acd56b621ed3037ffa2cd015ca77406c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a26e03c83c2e057f90010d350be391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#ac9a26e03c83c2e057f90010d350be391">clearInputs</a> (void)</td></tr>
<tr class="memdesc:ac9a26e03c83c2e057f90010d350be391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all input varnodes to this op.  <a href="#ac9a26e03c83c2e057f90010d350be391">More...</a><br/></td></tr>
<tr class="separator:ac9a26e03c83c2e057f90010d350be391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6500599911fc0e88a822466e66900ba5"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#a6500599911fc0e88a822466e66900ba5">numInput</a> (void) const </td></tr>
<tr class="memdesc:a6500599911fc0e88a822466e66900ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of input varnodes to this op.  <a href="#a6500599911fc0e88a822466e66900ba5">More...</a><br/></td></tr>
<tr class="separator:a6500599911fc0e88a822466e66900ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5a365c3d42c7308dbd48948df0d503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVarnodeData.html">VarnodeData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#aae5a365c3d42c7308dbd48948df0d503">getInput</a> (int4 i) const </td></tr>
<tr class="memdesc:aae5a365c3d42c7308dbd48948df0d503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the i-th input varnode for this op.  <a href="#aae5a365c3d42c7308dbd48948df0d503">More...</a><br/></td></tr>
<tr class="separator:aae5a365c3d42c7308dbd48948df0d503"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae4a09db78b969a104972d9b7d3ca0093"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#ae4a09db78b969a104972d9b7d3ca0093">decode</a> (<a class="el" href="classDecoder.html">Decoder</a> &amp;decoder, int4 isize, <a class="el" href="structVarnodeData.html">VarnodeData</a> *invar, <a class="el" href="structVarnodeData.html">VarnodeData</a> **outvar)</td></tr>
<tr class="memdesc:ae4a09db78b969a104972d9b7d3ca0093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the raw OpCode and input/output Varnode data for a PcodeOp.  <a href="#ae4a09db78b969a104972d9b7d3ca0093">More...</a><br/></td></tr>
<tr class="separator:ae4a09db78b969a104972d9b7d3ca0093"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a62ec5cac9f5484fbe0f5eb2ef5fe9959"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62ec5cac9f5484fbe0f5eb2ef5fe9959"></a>
<a class="el" href="classOpBehavior.html">OpBehavior</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#a62ec5cac9f5484fbe0f5eb2ef5fe9959">behave</a></td></tr>
<tr class="memdesc:a62ec5cac9f5484fbe0f5eb2ef5fe9959"><td class="mdescLeft">&#160;</td><td class="mdescRight">The opcode for this operation. <br/></td></tr>
<tr class="separator:a62ec5cac9f5484fbe0f5eb2ef5fe9959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86039bbd8d785fedc8bf6b65f311b65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae86039bbd8d785fedc8bf6b65f311b65"></a>
<a class="el" href="classSeqNum.html">SeqNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#ae86039bbd8d785fedc8bf6b65f311b65">seq</a></td></tr>
<tr class="memdesc:ae86039bbd8d785fedc8bf6b65f311b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifying address and index of this operation. <br/></td></tr>
<tr class="separator:ae86039bbd8d785fedc8bf6b65f311b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce1c250c545e3f69d051327a2ece50d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ce1c250c545e3f69d051327a2ece50d"></a>
<a class="el" href="structVarnodeData.html">VarnodeData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#a4ce1c250c545e3f69d051327a2ece50d">out</a></td></tr>
<tr class="memdesc:a4ce1c250c545e3f69d051327a2ece50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output varnode triple. <br/></td></tr>
<tr class="separator:a4ce1c250c545e3f69d051327a2ece50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adbf01075b2cb212dd1ffb114985038"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9adbf01075b2cb212dd1ffb114985038"></a>
vector&lt; <a class="el" href="structVarnodeData.html">VarnodeData</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPcodeOpRaw.html#a9adbf01075b2cb212dd1ffb114985038">in</a></td></tr>
<tr class="memdesc:a9adbf01075b2cb212dd1ffb114985038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw varnode inputs to this op. <br/></td></tr>
<tr class="separator:a9adbf01075b2cb212dd1ffb114985038"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A low-level representation of a single pcode operation. </p>
<p>This is just the minimum amount of data to represent a pcode operation An opcode, sequence number, optional output varnode and input varnodes </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acd56b621ed3037ffa2cd015ca77406c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PcodeOpRaw::addInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an additional input varnode to this op. </p>
<p>A <a class="el" href="classPcodeOpRaw.html" title="A low-level representation of a single pcode operation. ">PcodeOpRaw</a> is initially created with no input varnodes. Inputs are added with this method. Varnodes are added in order, so the first addInput call creates input 0, for example. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>is the varnode to be added as input </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOpRaw.html#a9adbf01075b2cb212dd1ffb114985038">in</a>.</p>

<p>Referenced by <a class="el" href="classPcodeEmitCache.html#a493e849e384f3a63cbf1676c43d6bbe1">PcodeEmitCache::dump()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9a26e03c83c2e057f90010d350be391"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PcodeOpRaw::clearInputs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all input varnodes to this op. </p>
<p>If the inputs to a pcode operation need to be changed, this routine clears the existing inputs so new ones can be added. </p>

<p>References <a class="el" href="classPcodeOpRaw.html#a9adbf01075b2cb212dd1ffb114985038">in</a>.</p>

</div>
</div>
<a class="anchor" id="ae4a09db78b969a104972d9b7d3ca0093"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> PcodeOpRaw::decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDecoder.html">Decoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>isize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> *&#160;</td>
          <td class="paramname"><em>invar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> **&#160;</td>
          <td class="paramname"><em>outvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode the raw OpCode and input/output Varnode data for a PcodeOp. </p>
<p>This assumes the &lt;op&gt; element is already open. Decode info suitable for call to <a class="el" href="classPcodeEmit.html#a00f25999bbdea677b82577b21bdfff8e" title="The main pcode emit method. ">PcodeEmit::dump</a>. The output pointer is changed to null if there is no output for this op, otherwise the existing pointer is used to store the output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decoder</td><td>is the stream decoder </td></tr>
    <tr><td class="paramname">isize</td><td>is the (preparsed) number of input parameters for the p-code op </td></tr>
    <tr><td class="paramname">invar</td><td>is an array of storage for the input Varnodes </td></tr>
    <tr><td class="paramname">outvar</td><td>is a (handle) to the storage for the output Varnode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the p-code op OpCode </dd></dl>

<p>References <a class="el" href="translate_8hh.html#a5ba87f627fbf8e0a39c232ee2f2dfd79">ATTRIB_CODE</a>, <a class="el" href="classDecoder.html#a1837b91ab3c9d2a7f5b2711fe0a86a97">Decoder::closeElement()</a>, <a class="el" href="structVarnodeData.html#ad49ee972626e66aab1748a35f0b65a32">VarnodeData::decode()</a>, <a class="el" href="translate_8hh.html#a2638fd09af935368421ec635d5ef7e97">ELEM_SPACEID</a>, <a class="el" href="classDecoder.html#af7e1c337c5263c056415259df22bc284">Decoder::getAddrSpaceManager()</a>, <a class="el" href="classAddrSpaceManager.html#a8e1a7314a41ca6854f5c7d19c69acf18">AddrSpaceManager::getConstantSpace()</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="classDecoder.html#a9b21defb3b7d9023324df3bb8328c87f">Decoder::openElement()</a>, <a class="el" href="classDecoder.html#a5a196e06e948a4ab4023fe0e5d129377">Decoder::peekElement()</a>, <a class="el" href="classDecoder.html#a88c617582ce9540eca9519accbb8ee00">Decoder::readSignedInteger()</a>, <a class="el" href="classDecoder.html#a698792800d19dede5dc90f8d091a0efb">Decoder::readSpace()</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>.</p>

<p>Referenced by <a class="el" href="classPcodeEmit.html#a1d37f1622ef8a60cee7bc559a1eabeec">PcodeEmit::decodeOp()</a>.</p>

</div>
</div>
<a class="anchor" id="a714014825db274fc64f32a07d4022451"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAddress.html">Address</a> &amp; PcodeOpRaw::getAddr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get address of this operation. </p>
<p>This is a convenience function to get the address of the machine instruction (of which this pcode op is a translation) </p>
<dl class="section return"><dt>Returns</dt><dd>the machine instruction address </dd></dl>

<p>References <a class="el" href="classSeqNum.html#ab7181525002bc99b22f8bd9f781dce58">SeqNum::getAddr()</a>, and <a class="el" href="classPcodeOpRaw.html#ae86039bbd8d785fedc8bf6b65f311b65">seq</a>.</p>

<p>Referenced by <a class="el" href="classEmulateMemory.html#a64cee14cda2a10ed440fe171b8fdbcc0">EmulateMemory::executeBranchind()</a>, and <a class="el" href="classEmulateMemory.html#af1c25ebc29e2e57ab762d878ac8103e4">EmulateMemory::executeCallind()</a>.</p>

</div>
</div>
<a class="anchor" id="a19f8ffb85aa33536fc6cc34cd87eb578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpBehavior.html">OpBehavior</a> * PcodeOpRaw::getBehavior </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the behavior for this op. </p>
<p>Get the underlying behavior object for this pcode operation. From this object you can determine how the object evaluates inputs to get the output </p>
<dl class="section return"><dt>Returns</dt><dd>the behavior object </dd></dl>

<p>References <a class="el" href="classPcodeOpRaw.html#a62ec5cac9f5484fbe0f5eb2ef5fe9959">behave</a>.</p>

<p>Referenced by <a class="el" href="classEmulatePcodeCache.html#a450d1bb3d74c67c6473c63e6d83954bd">EmulatePcodeCache::establishOp()</a>.</p>

</div>
</div>
<a class="anchor" id="aae5a365c3d42c7308dbd48948df0d503"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVarnodeData.html">VarnodeData</a> * PcodeOpRaw::getInput </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the i-th input varnode for this op. </p>
<p>Input varnodes are indexed starting at 0. This retrieves the input varnode by index. The index <em>must</em> be in range, or unpredicatable behavior will result. Use the numInput method to get the number of inputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>is the index of the desired input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the desired input varnode </dd></dl>

<p>References <a class="el" href="classPcodeOpRaw.html#a9adbf01075b2cb212dd1ffb114985038">in</a>.</p>

<p>Referenced by <a class="el" href="classBreakTableCallBack.html#a16b989de8c0b55d15940ac41bf7cdd73">BreakTableCallBack::doPcodeOpBreak()</a>, <a class="el" href="classEmulateMemory.html#a1570bf6221f1d26978873823f94ce469">EmulateMemory::executeBinary()</a>, <a class="el" href="classEmulateMemory.html#ac69d1f93ffc1a86d3486af34bb520302">EmulateMemory::executeBranch()</a>, <a class="el" href="classEmulatePcodeCache.html#a6108efef1c0291ca887228781e4c1238">EmulatePcodeCache::executeBranch()</a>, <a class="el" href="classEmulateMemory.html#a64cee14cda2a10ed440fe171b8fdbcc0">EmulateMemory::executeBranchind()</a>, <a class="el" href="classEmulateMemory.html#a20537bae3d7f06adeae32f99d1867b12">EmulateMemory::executeCall()</a>, <a class="el" href="classEmulateMemory.html#af1c25ebc29e2e57ab762d878ac8103e4">EmulateMemory::executeCallind()</a>, <a class="el" href="classEmulateMemory.html#a098137ac05d9118162a1d0aaa5506d0b">EmulateMemory::executeCbranch()</a>, <a class="el" href="classEmulateMemory.html#ad612d22e967669919fd5c8538ade212f">EmulateMemory::executeLoad()</a>, <a class="el" href="classEmulateMemory.html#a3fed95d66c73d4dad23532f959a9417d">EmulateMemory::executeStore()</a>, and <a class="el" href="classEmulateMemory.html#af31f9f35bb843b59d6a509bcbb045894">EmulateMemory::executeUnary()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c3ff9ab2edc1397b4f88b8d042f59b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="opcodes_8hh.html#abeb7dfb0e9e2b3114e240a405d046ea7">OpCode</a> PcodeOpRaw::getOpcode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the opcode for this op. </p>
<p>The possible types of pcode operations are enumerated by OpCode This routine retrieves the enumeration value for this particular op </p>
<dl class="section return"><dt>Returns</dt><dd>the opcode value </dd></dl>

<p>References <a class="el" href="classPcodeOpRaw.html#a62ec5cac9f5484fbe0f5eb2ef5fe9959">behave</a>, and <a class="el" href="classOpBehavior.html#ad47422abddc2bc5730dfc1fdef6d4be0">OpBehavior::getOpcode()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d788f96b3e90ce150fb8a9cec92fe51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVarnodeData.html">VarnodeData</a> * PcodeOpRaw::getOutput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the output varnode for this op. </p>
<p>Most pcode operations have an output varnode. This routine retrieves that varnode. </p>
<dl class="section return"><dt>Returns</dt><dd>the output varnode or <b>null</b> if there is no output </dd></dl>

<p>References <a class="el" href="classPcodeOpRaw.html#a4ce1c250c545e3f69d051327a2ece50d">out</a>.</p>

<p>Referenced by <a class="el" href="classEmulateMemory.html#a1570bf6221f1d26978873823f94ce469">EmulateMemory::executeBinary()</a>, <a class="el" href="classEmulateMemory.html#ad612d22e967669919fd5c8538ade212f">EmulateMemory::executeLoad()</a>, and <a class="el" href="classEmulateMemory.html#af31f9f35bb843b59d6a509bcbb045894">EmulateMemory::executeUnary()</a>.</p>

</div>
</div>
<a class="anchor" id="ac672e63a7df7797e6fed85e550f951f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSeqNum.html">SeqNum</a> &amp; PcodeOpRaw::getSeqNum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the sequence number. </p>
<p>Every pcode operation has a <b>sequence</b> <b>number</b> which associates the operation with the address of the machine instruction being translated and an index number for this operation within the translation. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the sequence number </dd></dl>

<p>References <a class="el" href="classPcodeOpRaw.html#ae86039bbd8d785fedc8bf6b65f311b65">seq</a>.</p>

</div>
</div>
<a class="anchor" id="a6500599911fc0e88a822466e66900ba5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 PcodeOpRaw::numInput </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of input varnodes to this op. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of inputs </dd></dl>

<p>References <a class="el" href="classPcodeOpRaw.html#a9adbf01075b2cb212dd1ffb114985038">in</a>.</p>

</div>
</div>
<a class="anchor" id="a294ebc1a204972cfdc831faf6aff3f48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PcodeOpRaw::setBehavior </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpBehavior.html">OpBehavior</a> *&#160;</td>
          <td class="paramname"><em>be</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the opcode for this op. </p>
<p>The core behavior for this operation is controlled by an <a class="el" href="classOpBehavior.html" title="Class encapsulating the action/behavior of specific pcode opcodes. ">OpBehavior</a> object which knows how output is determined given inputs. This routine sets that object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">be</td><td>is the behavior object </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOpRaw.html#a62ec5cac9f5484fbe0f5eb2ef5fe9959">behave</a>.</p>

<p>Referenced by <a class="el" href="classPcodeEmitCache.html#a493e849e384f3a63cbf1676c43d6bbe1">PcodeEmitCache::dump()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c25e2a933548b236169924aa3b40d46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PcodeOpRaw::setOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVarnodeData.html">VarnodeData</a> *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the output varnode for this op. </p>
<p>Most pcode operations output to a varnode. This routine sets what that varnode is. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>is the varnode to set as output </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOpRaw.html#a4ce1c250c545e3f69d051327a2ece50d">out</a>.</p>

<p>Referenced by <a class="el" href="classPcodeEmitCache.html#a493e849e384f3a63cbf1676c43d6bbe1">PcodeEmitCache::dump()</a>.</p>

</div>
</div>
<a class="anchor" id="afabdf56ea3e97062b7daf2af34f741a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PcodeOpRaw::setSeqNum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintm&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the sequence number. </p>
<p>Every pcode operation has a <b>sequence</b> <b>number</b> which associates the operation with the address of the machine instruction being translated and an order number which provides an index for this particular operation within the entire translation of the machine instruction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the instruction address </td></tr>
    <tr><td class="paramname">b</td><td>is the order number </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPcodeOpRaw.html#ae86039bbd8d785fedc8bf6b65f311b65">seq</a>.</p>

<p>Referenced by <a class="el" href="classPcodeEmitCache.html#a493e849e384f3a63cbf1676c43d6bbe1">PcodeEmitCache::dump()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="pcoderaw_8hh.html">pcoderaw.hh</a></li>
<li>pcoderaw.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
