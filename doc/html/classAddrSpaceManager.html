<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>decompiler: AddrSpaceManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classAddrSpaceManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AddrSpaceManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A manager for different address spaces.  
 <a href="classAddrSpaceManager.html#details">More...</a></p>

<p><code>#include &lt;translate.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AddrSpaceManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAddrSpaceManager.png" usemap="#AddrSpaceManager_map" alt=""/>
  <map id="AddrSpaceManager_map" name="AddrSpaceManager_map">
<area href="classTranslate.html" title="The interface to a translation engine for a processor. " alt="Translate" shape="rect" coords="68,56,195,80"/>
<area href="classSleighBase.html" title="Common core of classes that read or write SLEIGH specification files natively. " alt="SleighBase" shape="rect" coords="68,112,195,136"/>
<area href="classSleigh.html" title="A full SLEIGH engine. " alt="Sleigh" shape="rect" coords="0,168,127,192"/>
<area href="classSleighCompile.html" title="SLEIGH specification compiling. " alt="SleighCompile" shape="rect" coords="137,168,264,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7012cd8aa3869a8db478ef71dfd04756"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a7012cd8aa3869a8db478ef71dfd04756">AddrSpaceManager</a> (void)</td></tr>
<tr class="memdesc:a7012cd8aa3869a8db478ef71dfd04756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty address space manager.  <a href="#a7012cd8aa3869a8db478ef71dfd04756">More...</a><br/></td></tr>
<tr class="separator:a7012cd8aa3869a8db478ef71dfd04756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca145540a3af8f6d35dfc2037580818"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#afca145540a3af8f6d35dfc2037580818">~AddrSpaceManager</a> (void)</td></tr>
<tr class="memdesc:afca145540a3af8f6d35dfc2037580818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the manager.  <a href="#afca145540a3af8f6d35dfc2037580818">More...</a><br/></td></tr>
<tr class="separator:afca145540a3af8f6d35dfc2037580818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a93c129bd2799a82cccfc7df915942"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ab8a93c129bd2799a82cccfc7df915942">getDefaultSize</a> (void) const </td></tr>
<tr class="memdesc:ab8a93c129bd2799a82cccfc7df915942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of addresses for the default space.  <a href="#ab8a93c129bd2799a82cccfc7df915942">More...</a><br/></td></tr>
<tr class="separator:ab8a93c129bd2799a82cccfc7df915942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799fc65471e0b5201e2dd738f01dc34d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a799fc65471e0b5201e2dd738f01dc34d">getSpaceByName</a> (const string &amp;nm) const </td></tr>
<tr class="memdesc:a799fc65471e0b5201e2dd738f01dc34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address space by name.  <a href="#a799fc65471e0b5201e2dd738f01dc34d">More...</a><br/></td></tr>
<tr class="separator:a799fc65471e0b5201e2dd738f01dc34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0339ab25c08d59c4c1da5cf2d41f055b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a0339ab25c08d59c4c1da5cf2d41f055b">getSpaceByShortcut</a> (char sc) const </td></tr>
<tr class="memdesc:a0339ab25c08d59c4c1da5cf2d41f055b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address space from its shortcut.  <a href="#a0339ab25c08d59c4c1da5cf2d41f055b">More...</a><br/></td></tr>
<tr class="separator:a0339ab25c08d59c4c1da5cf2d41f055b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9be6c441d2c5815c6041d14c83aff56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aa9be6c441d2c5815c6041d14c83aff56">getIopSpace</a> (void) const </td></tr>
<tr class="memdesc:aa9be6c441d2c5815c6041d14c83aff56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal pcode op space.  <a href="#aa9be6c441d2c5815c6041d14c83aff56">More...</a><br/></td></tr>
<tr class="separator:aa9be6c441d2c5815c6041d14c83aff56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5ea8b9d837a8b3a16176530a34eaeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a2c5ea8b9d837a8b3a16176530a34eaeb">getFspecSpace</a> (void) const </td></tr>
<tr class="memdesc:a2c5ea8b9d837a8b3a16176530a34eaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal callspec space.  <a href="#a2c5ea8b9d837a8b3a16176530a34eaeb">More...</a><br/></td></tr>
<tr class="separator:a2c5ea8b9d837a8b3a16176530a34eaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3986c7a06ebd80e6c72c45b8133e03a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a3986c7a06ebd80e6c72c45b8133e03a9">getJoinSpace</a> (void) const </td></tr>
<tr class="memdesc:a3986c7a06ebd80e6c72c45b8133e03a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the joining space.  <a href="#a3986c7a06ebd80e6c72c45b8133e03a9">More...</a><br/></td></tr>
<tr class="separator:a3986c7a06ebd80e6c72c45b8133e03a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6a5c3c4ceadaf7f0b4343f52639153"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a4c6a5c3c4ceadaf7f0b4343f52639153">getStackSpace</a> (void) const </td></tr>
<tr class="memdesc:a4c6a5c3c4ceadaf7f0b4343f52639153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stack space for this processor.  <a href="#a4c6a5c3c4ceadaf7f0b4343f52639153">More...</a><br/></td></tr>
<tr class="separator:a4c6a5c3c4ceadaf7f0b4343f52639153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bef0bbef7bfe26c2790ec6018d8fc02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a3bef0bbef7bfe26c2790ec6018d8fc02">getUniqueSpace</a> (void) const </td></tr>
<tr class="memdesc:a3bef0bbef7bfe26c2790ec6018d8fc02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the temporary register space for this processor.  <a href="#a3bef0bbef7bfe26c2790ec6018d8fc02">More...</a><br/></td></tr>
<tr class="separator:a3bef0bbef7bfe26c2790ec6018d8fc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc70d6b8586d28e2b8fe95abf4290a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#adfc70d6b8586d28e2b8fe95abf4290a8">getDefaultCodeSpace</a> (void) const </td></tr>
<tr class="memdesc:adfc70d6b8586d28e2b8fe95abf4290a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default address space of this processor.  <a href="#adfc70d6b8586d28e2b8fe95abf4290a8">More...</a><br/></td></tr>
<tr class="separator:adfc70d6b8586d28e2b8fe95abf4290a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89303f0cc0bb875ce94c85128f15127e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a89303f0cc0bb875ce94c85128f15127e">getDefaultDataSpace</a> (void) const </td></tr>
<tr class="memdesc:a89303f0cc0bb875ce94c85128f15127e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default address space where data is stored.  <a href="#a89303f0cc0bb875ce94c85128f15127e">More...</a><br/></td></tr>
<tr class="separator:a89303f0cc0bb875ce94c85128f15127e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1a7314a41ca6854f5c7d19c69acf18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a8e1a7314a41ca6854f5c7d19c69acf18">getConstantSpace</a> (void) const </td></tr>
<tr class="memdesc:a8e1a7314a41ca6854f5c7d19c69acf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the constant space.  <a href="#a8e1a7314a41ca6854f5c7d19c69acf18">More...</a><br/></td></tr>
<tr class="separator:a8e1a7314a41ca6854f5c7d19c69acf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77aed07a480b7c60b63c30bea2da711a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a77aed07a480b7c60b63c30bea2da711a">getConstant</a> (uintb val) const </td></tr>
<tr class="memdesc:a77aed07a480b7c60b63c30bea2da711a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant encoded as an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>.  <a href="#a77aed07a480b7c60b63c30bea2da711a">More...</a><br/></td></tr>
<tr class="separator:a77aed07a480b7c60b63c30bea2da711a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5d0fafb73b3f77d672dcefae79cb61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a1a5d0fafb73b3f77d672dcefae79cb61">createConstFromSpace</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc) const </td></tr>
<tr class="memdesc:a1a5d0fafb73b3f77d672dcefae79cb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a constant address encoding an address space.  <a href="#a1a5d0fafb73b3f77d672dcefae79cb61">More...</a><br/></td></tr>
<tr class="separator:a1a5d0fafb73b3f77d672dcefae79cb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d2893a87a604368cb0891482551349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a27d2893a87a604368cb0891482551349">resolveConstant</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, uintb val, int4 sz, const <a class="el" href="classAddress.html">Address</a> &amp;point, uintb &amp;fullEncoding) const </td></tr>
<tr class="memdesc:a27d2893a87a604368cb0891482551349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve a native constant into an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>.  <a href="#a27d2893a87a604368cb0891482551349">More...</a><br/></td></tr>
<tr class="separator:a27d2893a87a604368cb0891482551349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb27d4583ae1bfb9e2a16139bae922d3"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#abb27d4583ae1bfb9e2a16139bae922d3">numSpaces</a> (void) const </td></tr>
<tr class="memdesc:abb27d4583ae1bfb9e2a16139bae922d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of address spaces for this processor.  <a href="#abb27d4583ae1bfb9e2a16139bae922d3">More...</a><br/></td></tr>
<tr class="separator:abb27d4583ae1bfb9e2a16139bae922d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4ce4f25454e86a0383852fe42b3b7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a8c4ce4f25454e86a0383852fe42b3b7a">getSpace</a> (int4 i) const </td></tr>
<tr class="memdesc:a8c4ce4f25454e86a0383852fe42b3b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an address space via its index.  <a href="#a8c4ce4f25454e86a0383852fe42b3b7a">More...</a><br/></td></tr>
<tr class="separator:a8c4ce4f25454e86a0383852fe42b3b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcb1edc24d876b71fac49c003307872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a0bcb1edc24d876b71fac49c003307872">getNextSpaceInOrder</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc) const </td></tr>
<tr class="memdesc:a0bcb1edc24d876b71fac49c003307872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next <em>contiguous</em> address space.  <a href="#a0bcb1edc24d876b71fac49c003307872">More...</a><br/></td></tr>
<tr class="separator:a0bcb1edc24d876b71fac49c003307872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9e7e934e22b6bea3b2b949fd2b2159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJoinRecord.html">JoinRecord</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a1b9e7e934e22b6bea3b2b949fd2b2159">findAddJoin</a> (const vector&lt; <a class="el" href="structVarnodeData.html">VarnodeData</a> &gt; &amp;pieces, uint4 logicalsize)</td></tr>
<tr class="memdesc:a1b9e7e934e22b6bea3b2b949fd2b2159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get (or create) <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> for <em>pieces</em>.  <a href="#a1b9e7e934e22b6bea3b2b949fd2b2159">More...</a><br/></td></tr>
<tr class="separator:a1b9e7e934e22b6bea3b2b949fd2b2159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f25cc2edce93262a633b17c701b49f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJoinRecord.html">JoinRecord</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ab2f25cc2edce93262a633b17c701b49f">findJoin</a> (uintb offset) const </td></tr>
<tr class="memdesc:ab2f25cc2edce93262a633b17c701b49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> for <em>offset</em> in the join space.  <a href="#ab2f25cc2edce93262a633b17c701b49f">More...</a><br/></td></tr>
<tr class="separator:ab2f25cc2edce93262a633b17c701b49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82d08eab20f86a31fe366a9bcd58629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ae82d08eab20f86a31fe366a9bcd58629">setDeadcodeDelay</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, int4 delaydelta)</td></tr>
<tr class="memdesc:ae82d08eab20f86a31fe366a9bcd58629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the deadcodedelay for a specific space.  <a href="#ae82d08eab20f86a31fe366a9bcd58629">More...</a><br/></td></tr>
<tr class="separator:ae82d08eab20f86a31fe366a9bcd58629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7d980ea2fc0c6450e941fd7dbec7e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aef7d980ea2fc0c6450e941fd7dbec7e6">truncateSpace</a> (const <a class="el" href="classTruncationTag.html">TruncationTag</a> &amp;tag)</td></tr>
<tr class="memdesc:aef7d980ea2fc0c6450e941fd7dbec7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a space as truncated from its original size.  <a href="#aef7d980ea2fc0c6450e941fd7dbec7e6">More...</a><br/></td></tr>
<tr class="separator:aef7d980ea2fc0c6450e941fd7dbec7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed824a71a1d12bb5d167a7a488eb7198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aed824a71a1d12bb5d167a7a488eb7198">constructFloatExtensionAddress</a> (const <a class="el" href="classAddress.html">Address</a> &amp;realaddr, int4 realsize, int4 logicalsize)</td></tr>
<tr class="memdesc:aed824a71a1d12bb5d167a7a488eb7198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a logically lower precision storage location for a bigger floating point register.  <a href="#aed824a71a1d12bb5d167a7a488eb7198">More...</a><br/></td></tr>
<tr class="separator:aed824a71a1d12bb5d167a7a488eb7198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfc5383270584be6e9b974114e65f13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">constructJoinAddress</a> (const <a class="el" href="classTranslate.html">Translate</a> *translate, const <a class="el" href="classAddress.html">Address</a> &amp;hiaddr, int4 hisz, const <a class="el" href="classAddress.html">Address</a> &amp;loaddr, int4 losz)</td></tr>
<tr class="memdesc:a1cfc5383270584be6e9b974114e65f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a logical whole from register pairs.  <a href="#a1cfc5383270584be6e9b974114e65f13">More...</a><br/></td></tr>
<tr class="separator:a1cfc5383270584be6e9b974114e65f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cf42a54806161d8bf3c1fa283036dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a68cf42a54806161d8bf3c1fa283036dd">renormalizeJoinAddress</a> (<a class="el" href="classAddress.html">Address</a> &amp;addr, int4 size)</td></tr>
<tr class="memdesc:a68cf42a54806161d8bf3c1fa283036dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure a possibly offset <em>join</em> address has a proper <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a>.  <a href="#a68cf42a54806161d8bf3c1fa283036dd">More...</a><br/></td></tr>
<tr class="separator:a68cf42a54806161d8bf3c1fa283036dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16363aa88c3c9fd1859fc8d36ae9273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ae16363aa88c3c9fd1859fc8d36ae9273">parseAddressSimple</a> (const string &amp;val)</td></tr>
<tr class="memdesc:ae16363aa88c3c9fd1859fc8d36ae9273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string with just an <em>address</em> <em>space</em> name and a hex offset.  <a href="#ae16363aa88c3c9fd1859fc8d36ae9273">More...</a><br/></td></tr>
<tr class="separator:ae16363aa88c3c9fd1859fc8d36ae9273"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa028e435f3e8f6a1f2c7d4c462089af0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aa028e435f3e8f6a1f2c7d4c462089af0">decodeSpace</a> (<a class="el" href="classDecoder.html">Decoder</a> &amp;decoder, const <a class="el" href="classTranslate.html">Translate</a> *trans)</td></tr>
<tr class="memdesc:aa028e435f3e8f6a1f2c7d4c462089af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a space to the model based an on XML tag.  <a href="#aa028e435f3e8f6a1f2c7d4c462089af0">More...</a><br/></td></tr>
<tr class="separator:aa028e435f3e8f6a1f2c7d4c462089af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee56defff6dfb953555b001afb3a84ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aee56defff6dfb953555b001afb3a84ea">decodeSpaces</a> (<a class="el" href="classDecoder.html">Decoder</a> &amp;decoder, const <a class="el" href="classTranslate.html">Translate</a> *trans)</td></tr>
<tr class="memdesc:aee56defff6dfb953555b001afb3a84ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore address spaces in the model from an XML tag.  <a href="#aee56defff6dfb953555b001afb3a84ea">More...</a><br/></td></tr>
<tr class="separator:aee56defff6dfb953555b001afb3a84ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9001bbb4f273b895325e1cad6a8930d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a9001bbb4f273b895325e1cad6a8930d6">setDefaultCodeSpace</a> (int4 index)</td></tr>
<tr class="memdesc:a9001bbb4f273b895325e1cad6a8930d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default address space (for code)  <a href="#a9001bbb4f273b895325e1cad6a8930d6">More...</a><br/></td></tr>
<tr class="separator:a9001bbb4f273b895325e1cad6a8930d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5889b07364f07bbc30f79cda62a68d23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a5889b07364f07bbc30f79cda62a68d23">setDefaultDataSpace</a> (int4 index)</td></tr>
<tr class="memdesc:a5889b07364f07bbc30f79cda62a68d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default address space for data.  <a href="#a5889b07364f07bbc30f79cda62a68d23">More...</a><br/></td></tr>
<tr class="separator:a5889b07364f07bbc30f79cda62a68d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdab85595c68e18ab86dd42af914f35b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#abdab85595c68e18ab86dd42af914f35b">setReverseJustified</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:abdab85595c68e18ab86dd42af914f35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set reverse justified property on this space.  <a href="#abdab85595c68e18ab86dd42af914f35b">More...</a><br/></td></tr>
<tr class="separator:abdab85595c68e18ab86dd42af914f35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5300e7a40dba53c7c78fdacebfc6ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a9d5300e7a40dba53c7c78fdacebfc6ed">assignShortcut</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:a9d5300e7a40dba53c7c78fdacebfc6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a shortcut character for a new space.  <a href="#a9d5300e7a40dba53c7c78fdacebfc6ed">More...</a><br/></td></tr>
<tr class="separator:a9d5300e7a40dba53c7c78fdacebfc6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1c818ccc3950c188e06df08746725f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aba1c818ccc3950c188e06df08746725f">markNearPointers</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, int4 size)</td></tr>
<tr class="memdesc:aba1c818ccc3950c188e06df08746725f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that given space can be accessed with near pointers.  <a href="#aba1c818ccc3950c188e06df08746725f">More...</a><br/></td></tr>
<tr class="separator:aba1c818ccc3950c188e06df08746725f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89658bd677414a271a918f0f37af0bd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">insertSpace</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc)</td></tr>
<tr class="memdesc:a89658bd677414a271a918f0f37af0bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new address space to the model.  <a href="#a89658bd677414a271a918f0f37af0bd6">More...</a><br/></td></tr>
<tr class="separator:a89658bd677414a271a918f0f37af0bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45068bcc8331bebc780f00e51bd85250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a45068bcc8331bebc780f00e51bd85250">copySpaces</a> (const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *op2)</td></tr>
<tr class="memdesc:a45068bcc8331bebc780f00e51bd85250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy spaces from another manager.  <a href="#a45068bcc8331bebc780f00e51bd85250">More...</a><br/></td></tr>
<tr class="separator:a45068bcc8331bebc780f00e51bd85250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd0ab3084fd8bb9cb4ea5a84885704d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a6dd0ab3084fd8bb9cb4ea5a84885704d">addSpacebasePointer</a> (<a class="el" href="classSpacebaseSpace.html">SpacebaseSpace</a> *basespace, const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;ptrdata, int4 truncSize, bool stackGrowth)</td></tr>
<tr class="memdesc:a6dd0ab3084fd8bb9cb4ea5a84885704d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the base register of a spacebase space.  <a href="#a6dd0ab3084fd8bb9cb4ea5a84885704d">More...</a><br/></td></tr>
<tr class="separator:a6dd0ab3084fd8bb9cb4ea5a84885704d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6330481f1f40a24d860c820a5a2b64f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a6330481f1f40a24d860c820a5a2b64f5">insertResolver</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *spc, <a class="el" href="classAddressResolver.html">AddressResolver</a> *rsolv)</td></tr>
<tr class="memdesc:a6330481f1f40a24d860c820a5a2b64f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the base resolver for a space.  <a href="#a6330481f1f40a24d860c820a5a2b64f5">More...</a><br/></td></tr>
<tr class="separator:a6330481f1f40a24d860c820a5a2b64f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3271657111f46abc8b10bfdeb56e881d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a3271657111f46abc8b10bfdeb56e881d">setInferPtrBounds</a> (const <a class="el" href="classRange.html">Range</a> &amp;range)</td></tr>
<tr class="memdesc:a3271657111f46abc8b10bfdeb56e881d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the range of addresses that can be inferred as pointers.  <a href="#a3271657111f46abc8b10bfdeb56e881d">More...</a><br/></td></tr>
<tr class="separator:a3271657111f46abc8b10bfdeb56e881d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab596fe6fd25e1e4ec5a9adcbc3f94730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJoinRecord.html">JoinRecord</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#ab596fe6fd25e1e4ec5a9adcbc3f94730">findJoinInternal</a> (uintb offset) const </td></tr>
<tr class="memdesc:ab596fe6fd25e1e4ec5a9adcbc3f94730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> for <em>offset</em> in the join space.  <a href="#ab596fe6fd25e1e4ec5a9adcbc3f94730">More...</a><br/></td></tr>
<tr class="separator:ab596fe6fd25e1e4ec5a9adcbc3f94730"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a09491be3674d830795dc41795247938e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09491be3674d830795dc41795247938e"></a>
vector&lt; <a class="el" href="classAddrSpace.html">AddrSpace</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a09491be3674d830795dc41795247938e">baselist</a></td></tr>
<tr class="memdesc:a09491be3674d830795dc41795247938e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every space we know about for this architecture. <br/></td></tr>
<tr class="separator:a09491be3674d830795dc41795247938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640a67012d0bc05bd417c6aee5ef45bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a640a67012d0bc05bd417c6aee5ef45bb"></a>
vector&lt; <a class="el" href="classAddressResolver.html">AddressResolver</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a640a67012d0bc05bd417c6aee5ef45bb">resolvelist</a></td></tr>
<tr class="memdesc:a640a67012d0bc05bd417c6aee5ef45bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special constant resolvers. <br/></td></tr>
<tr class="separator:a640a67012d0bc05bd417c6aee5ef45bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90050a1c183c3c2108a7ad0d6a6fdeaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90050a1c183c3c2108a7ad0d6a6fdeaa"></a>
map&lt; string, <a class="el" href="classAddrSpace.html">AddrSpace</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a90050a1c183c3c2108a7ad0d6a6fdeaa">name2Space</a></td></tr>
<tr class="memdesc:a90050a1c183c3c2108a7ad0d6a6fdeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from name -&gt; space. <br/></td></tr>
<tr class="separator:a90050a1c183c3c2108a7ad0d6a6fdeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a423a82fa9781995acb644adb9f50f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a423a82fa9781995acb644adb9f50f5"></a>
map&lt; int4, <a class="el" href="classAddrSpace.html">AddrSpace</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a6a423a82fa9781995acb644adb9f50f5">shortcut2Space</a></td></tr>
<tr class="memdesc:a6a423a82fa9781995acb644adb9f50f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from shortcut -&gt; space. <br/></td></tr>
<tr class="separator:a6a423a82fa9781995acb644adb9f50f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107dd46a712fb01cc255912c1c9a5919"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a107dd46a712fb01cc255912c1c9a5919"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a107dd46a712fb01cc255912c1c9a5919">constantspace</a></td></tr>
<tr class="memdesc:a107dd46a712fb01cc255912c1c9a5919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick reference to constant space. <br/></td></tr>
<tr class="separator:a107dd46a712fb01cc255912c1c9a5919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fae43e18f50d494152dbd82024eb257"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fae43e18f50d494152dbd82024eb257"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a6fae43e18f50d494152dbd82024eb257">defaultcodespace</a></td></tr>
<tr class="memdesc:a6fae43e18f50d494152dbd82024eb257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default space where code lives, generally main RAM. <br/></td></tr>
<tr class="separator:a6fae43e18f50d494152dbd82024eb257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8acbdca6433d23e37ae66c7e60d01d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f8acbdca6433d23e37ae66c7e60d01d"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a8f8acbdca6433d23e37ae66c7e60d01d">defaultdataspace</a></td></tr>
<tr class="memdesc:a8f8acbdca6433d23e37ae66c7e60d01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default space where data lives. <br/></td></tr>
<tr class="separator:a8f8acbdca6433d23e37ae66c7e60d01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f6ef1dc85818c9a7582a8ca6bae441"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68f6ef1dc85818c9a7582a8ca6bae441"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a68f6ef1dc85818c9a7582a8ca6bae441">iopspace</a></td></tr>
<tr class="memdesc:a68f6ef1dc85818c9a7582a8ca6bae441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space for internal pcode op pointers. <br/></td></tr>
<tr class="separator:a68f6ef1dc85818c9a7582a8ca6bae441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1305f9c6e7580c8647be5fa3d0c5bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c1305f9c6e7580c8647be5fa3d0c5bf"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a5c1305f9c6e7580c8647be5fa3d0c5bf">fspecspace</a></td></tr>
<tr class="memdesc:a5c1305f9c6e7580c8647be5fa3d0c5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space for internal callspec pointers. <br/></td></tr>
<tr class="separator:a5c1305f9c6e7580c8647be5fa3d0c5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938f0d0e6fb63311401e6b49ecaf5c39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a938f0d0e6fb63311401e6b49ecaf5c39"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a938f0d0e6fb63311401e6b49ecaf5c39">joinspace</a></td></tr>
<tr class="memdesc:a938f0d0e6fb63311401e6b49ecaf5c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space for unifying split variables. <br/></td></tr>
<tr class="separator:a938f0d0e6fb63311401e6b49ecaf5c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6bb24b1ee9d16fa4ae5cc5908ac493"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea6bb24b1ee9d16fa4ae5cc5908ac493"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#aea6bb24b1ee9d16fa4ae5cc5908ac493">stackspace</a></td></tr>
<tr class="memdesc:aea6bb24b1ee9d16fa4ae5cc5908ac493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack space associated with processor. <br/></td></tr>
<tr class="separator:aea6bb24b1ee9d16fa4ae5cc5908ac493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdaa7f4f1c3d5885c0dc9c67d9a17557"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdaa7f4f1c3d5885c0dc9c67d9a17557"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#abdaa7f4f1c3d5885c0dc9c67d9a17557">uniqspace</a></td></tr>
<tr class="memdesc:abdaa7f4f1c3d5885c0dc9c67d9a17557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary space associated with processor. <br/></td></tr>
<tr class="separator:abdaa7f4f1c3d5885c0dc9c67d9a17557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ef5b2b70ec5ad9b947945ad352e0e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37ef5b2b70ec5ad9b947945ad352e0e7"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a37ef5b2b70ec5ad9b947945ad352e0e7">joinallocate</a></td></tr>
<tr class="memdesc:a37ef5b2b70ec5ad9b947945ad352e0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next offset to be allocated in join space. <br/></td></tr>
<tr class="separator:a37ef5b2b70ec5ad9b947945ad352e0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5955adafecf6751b1c3df414f8cd3f59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5955adafecf6751b1c3df414f8cd3f59"></a>
set&lt; <a class="el" href="classJoinRecord.html">JoinRecord</a> <br class="typebreak"/>
*, <a class="el" href="structJoinRecordCompare.html">JoinRecordCompare</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a5955adafecf6751b1c3df414f8cd3f59">splitset</a></td></tr>
<tr class="memdesc:a5955adafecf6751b1c3df414f8cd3f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different splits that have been defined in join space. <br/></td></tr>
<tr class="separator:a5955adafecf6751b1c3df414f8cd3f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fdb56e597dc1018860096da746e0fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99fdb56e597dc1018860096da746e0fe"></a>
vector&lt; <a class="el" href="classJoinRecord.html">JoinRecord</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpaceManager.html#a99fdb56e597dc1018860096da746e0fe">splitlist</a></td></tr>
<tr class="memdesc:a99fdb56e597dc1018860096da746e0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">JoinRecords indexed by join address. <br/></td></tr>
<tr class="separator:a99fdb56e597dc1018860096da746e0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A manager for different address spaces. </p>
<p>Allow creation, lookup by name, lookup by shortcut, lookup by name, and iteration over address spaces </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7012cd8aa3869a8db478ef71dfd04756"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AddrSpaceManager::AddrSpaceManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty address space manager. </p>
<p>Initialize manager containing no address spaces. All the cached space slots are set to null. </p>

<p>References <a class="el" href="classAddrSpaceManager.html#a107dd46a712fb01cc255912c1c9a5919">constantspace</a>, <a class="el" href="classAddrSpaceManager.html#a6fae43e18f50d494152dbd82024eb257">defaultcodespace</a>, <a class="el" href="classAddrSpaceManager.html#a8f8acbdca6433d23e37ae66c7e60d01d">defaultdataspace</a>, <a class="el" href="classAddrSpaceManager.html#a5c1305f9c6e7580c8647be5fa3d0c5bf">fspecspace</a>, <a class="el" href="classAddrSpaceManager.html#a68f6ef1dc85818c9a7582a8ca6bae441">iopspace</a>, <a class="el" href="classAddrSpaceManager.html#a37ef5b2b70ec5ad9b947945ad352e0e7">joinallocate</a>, <a class="el" href="classAddrSpaceManager.html#a938f0d0e6fb63311401e6b49ecaf5c39">joinspace</a>, <a class="el" href="classAddrSpaceManager.html#aea6bb24b1ee9d16fa4ae5cc5908ac493">stackspace</a>, and <a class="el" href="classAddrSpaceManager.html#abdaa7f4f1c3d5885c0dc9c67d9a17557">uniqspace</a>.</p>

</div>
</div>
<a class="anchor" id="afca145540a3af8f6d35dfc2037580818"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AddrSpaceManager::~AddrSpaceManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the manager. </p>
<p>Base destructor class, cleans up <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> pointers which must be explicited created via <em>new</em> </p>

<p>References <a class="el" href="classAddrSpaceManager.html#a09491be3674d830795dc41795247938e">baselist</a>, <a class="el" href="classAddrSpace.html#af0886d7bcbf22c5157cd09b1554d4f38">AddrSpace::refcount</a>, <a class="el" href="classAddrSpaceManager.html#a640a67012d0bc05bd417c6aee5ef45bb">resolvelist</a>, and <a class="el" href="classAddrSpaceManager.html#a99fdb56e597dc1018860096da746e0fe">splitlist</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6dd0ab3084fd8bb9cb4ea5a84885704d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::addSpacebasePointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSpacebaseSpace.html">SpacebaseSpace</a> *&#160;</td>
          <td class="paramname"><em>basespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>ptrdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>truncSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stackGrowth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the base register of a spacebase space. </p>
<p>Perform the <em>privileged</em> act of associating a base register with an existing <em>virtual</em> space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basespace</td><td>is the virtual space </td></tr>
    <tr><td class="paramname">ptrdata</td><td>is the location data for the base register </td></tr>
    <tr><td class="paramname">truncSize</td><td>is the size of the space covered by the base register </td></tr>
    <tr><td class="paramname">stackGrowth</td><td>is true if the stack grows "normally" towards address 0 </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classSpacebaseSpace.html#a8c5de8cd7feb232e04d7e50a85fb0e24">SpacebaseSpace::setBaseRegister()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d5300e7a40dba53c7c78fdacebfc6ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::assignShortcut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select a shortcut character for a new space. </p>
<p>Assign a <em>shortcut</em> character to the given address space. This routine makes use of the desired type of the new space and info about shortcuts for spaces that already exist to pick a unique and consistent character. This method also builds up a map from short to <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the given <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#a9a1077feee89cf4434154e017a3360f5">AddrSpace::getName()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a3ae8eb421cb8d460bc939657402d970a">IPTR_CONSTANT</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a01bf4d06e504bf92eabbfd633e5c74c0">IPTR_FSPEC</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a1eef2cfc279c246cc7ea0387d8c0aa66">IPTR_INTERNAL</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231ad644dc33b71c7d421fcd0fb2003407c7">IPTR_IOP</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a67805851c12bd1477c2a748e53e45f9c">IPTR_JOIN</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231ac6a759a590195b56c099150c63cdd7b2">IPTR_PROCESSOR</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classAddrSpace.html#ad51e6f51e1f0c3307e3a41a9d25e25dd">AddrSpace::shortcut</a>, and <a class="el" href="classAddrSpaceManager.html#a6a423a82fa9781995acb644adb9f50f5">shortcut2Space</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">insertSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="aed824a71a1d12bb5d167a7a488eb7198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> AddrSpaceManager::constructFloatExtensionAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>realaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>realsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>logicalsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a logically lower precision storage location for a bigger floating point register. </p>
<p>This handles the situation where we need to find a logical address to hold the lower precision floating-point value that is stored in a bigger register If the logicalsize (precision) requested matches the -realsize- of the register just return the real address. Otherwise construct a join address to hold the logical value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">realaddr</td><td>is the address of the real floating-point register </td></tr>
    <tr><td class="paramname">realsize</td><td>is the size of the real floating-point register </td></tr>
    <tr><td class="paramname">logicalsize</td><td>is the size (lower precision) size of the logical value </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a1b9e7e934e22b6bea3b2b949fd2b2159">findAddJoin()</a>, <a class="el" href="structVarnodeData.html#ae65999536ac7abe8240fcc2f506abfe4">VarnodeData::getAddr()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, and <a class="el" href="classJoinRecord.html#ac132c6494158b3f82e48eae6a161ea56">JoinRecord::getUnified()</a>.</p>

</div>
</div>
<a class="anchor" id="a1cfc5383270584be6e9b974114e65f13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> AddrSpaceManager::constructJoinAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTranslate.html">Translate</a> *&#160;</td>
          <td class="paramname"><em>translate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>hiaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>hisz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>losz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a logical whole from register pairs. </p>
<p>This handles the common case, of trying to find a join address given a high location and a low location. This may not return an address in the <em>join</em> address space. It checks for the case where the two pieces are contiguous locations in a mappable space, in which case it just returns the containing address </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translate</td><td>is the <a class="el" href="classTranslate.html" title="The interface to a translation engine for a processor. ">Translate</a> object used to find registers </td></tr>
    <tr><td class="paramname">hiaddr</td><td>is the address of the most significant piece to be joined </td></tr>
    <tr><td class="paramname">hisz</td><td>is the size of the most significant piece </td></tr>
    <tr><td class="paramname">loaddr</td><td>is the address of the least significant piece </td></tr>
    <tr><td class="paramname">losz</td><td>is the size of the least significant piece </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an address representing the start of the joined range </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a1b9e7e934e22b6bea3b2b949fd2b2159">findAddJoin()</a>, <a class="el" href="structVarnodeData.html#ae65999536ac7abe8240fcc2f506abfe4">VarnodeData::getAddr()</a>, <a class="el" href="classAddrSpaceManager.html#adfc70d6b8586d28e2b8fe95abf4290a8">getDefaultCodeSpace()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classTranslate.html#a1da0ef001f801641313d9168fb359f02">Translate::getRegisterName()</a>, <a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">Address::getSpace()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="classJoinRecord.html#ac132c6494158b3f82e48eae6a161ea56">JoinRecord::getUnified()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231ac6a759a590195b56c099150c63cdd7b2">IPTR_PROCESSOR</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classAddress.html#ae7209c4a9300045576cf400b7443981e">Address::isBigEndian()</a>, and <a class="el" href="classAddress.html#a7de8fd2dd0029f985341ec5bb3530008">Address::isContiguous()</a>.</p>

</div>
</div>
<a class="anchor" id="a45068bcc8331bebc780f00e51bd85250"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::copySpaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy spaces from another manager. </p>
<p>Different managers may need to share the same spaces. I.e. if different programs being analyzed share the same processor. This routine pulls in a reference of every space in -op2- in order to manage it from within -this- </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is a pointer to space manager being copied </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a09491be3674d830795dc41795247938e">baselist</a>, <a class="el" href="classAddrSpaceManager.html#adfc70d6b8586d28e2b8fe95abf4290a8">getDefaultCodeSpace()</a>, <a class="el" href="classAddrSpaceManager.html#a89303f0cc0bb875ce94c85128f15127e">getDefaultDataSpace()</a>, <a class="el" href="classAddrSpace.html#aa6053f6a9a768acc129311f367318a9d">AddrSpace::getIndex()</a>, <a class="el" href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">insertSpace()</a>, <a class="el" href="classAddrSpaceManager.html#a9001bbb4f273b895325e1cad6a8930d6">setDefaultCodeSpace()</a>, and <a class="el" href="classAddrSpaceManager.html#a5889b07364f07bbc30f79cda62a68d23">setDefaultDataSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a5d0fafb73b3f77d672dcefae79cb61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> AddrSpaceManager::createConstFromSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a constant address encoding an address space. </p>
<p>This routine is used to encode a pointer to an address space as a <em>constant</em> <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>, for use in <b>LOAD</b> and <b>STORE</b> operations. This is used internally and is slightly more efficient than storing the formal index of the space param spc is the space pointer to be encoded </p>
<dl class="section return"><dt>Returns</dt><dd>the encoded <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a107dd46a712fb01cc255912c1c9a5919">constantspace</a>.</p>

</div>
</div>
<a class="anchor" id="aa028e435f3e8f6a1f2c7d4c462089af0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::decodeSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDecoder.html">Decoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTranslate.html">Translate</a> *&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a space to the model based an on XML tag. </p>
<p>The initialization of address spaces is the same across all variants of the <a class="el" href="classTranslate.html" title="The interface to a translation engine for a processor. ">Translate</a> object. This routine initializes a single address space from a decoder element. It knows which class derived from <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> to instantiate based on the <a class="el" href="classElementId.html" title="An annotation for a specific collection of hierarchical data. ">ElementId</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decoder</td><td>is the stream decoder </td></tr>
    <tr><td class="paramname">trans</td><td>is the translator object to be associated with the new space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the initialized <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#acfbc31fbef23911b81173b7c93b24543">AddrSpace::decode()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231ac6a759a590195b56c099150c63cdd7b2">IPTR_PROCESSOR</a>, and <a class="el" href="classDecoder.html#a5a196e06e948a4ab4023fe0e5d129377">Decoder::peekElement()</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#aee56defff6dfb953555b001afb3a84ea">decodeSpaces()</a>.</p>

</div>
</div>
<a class="anchor" id="aee56defff6dfb953555b001afb3a84ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::decodeSpaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDecoder.html">Decoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTranslate.html">Translate</a> *&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore address spaces in the model from an XML tag. </p>
<p>This routine initializes (almost) all the address spaces used for a particular processor by using a <b>&lt;spaces&gt;</b> element, which contains child elements for the specific address spaces. This also instantiates the builtin <em>constant</em> space. It should probably also instantiate the <b>iop</b>, <b>fspec</b>, and <b>join</b> spaces, but this is currently done by the Architecture class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decoder</td><td>is the stream decoder </td></tr>
    <tr><td class="paramname">trans</td><td>is the processor translator to be associated with the spaces </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classDecoder.html#a1837b91ab3c9d2a7f5b2711fe0a86a97">Decoder::closeElement()</a>, <a class="el" href="classAddrSpaceManager.html#aa028e435f3e8f6a1f2c7d4c462089af0">decodeSpace()</a>, <a class="el" href="classAddrSpace.html#aa6053f6a9a768acc129311f367318a9d">AddrSpace::getIndex()</a>, <a class="el" href="classAddrSpaceManager.html#a799fc65471e0b5201e2dd738f01dc34d">getSpaceByName()</a>, <a class="el" href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">insertSpace()</a>, <a class="el" href="classDecoder.html#a9b21defb3b7d9023324df3bb8328c87f">Decoder::openElement()</a>, <a class="el" href="classDecoder.html#a5a196e06e948a4ab4023fe0e5d129377">Decoder::peekElement()</a>, <a class="el" href="classDecoder.html#a206874f59d968db5904c0d39ad6bfdee">Decoder::readString()</a>, and <a class="el" href="classAddrSpaceManager.html#a9001bbb4f273b895325e1cad6a8930d6">setDefaultCodeSpace()</a>.</p>

<p>Referenced by <a class="el" href="classSleighBase.html#a4f2cd05135b68d2bafb549cfe87d3be5">SleighBase::restoreXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b9e7e934e22b6bea3b2b949fd2b2159"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJoinRecord.html">JoinRecord</a> * AddrSpaceManager::findAddJoin </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structVarnodeData.html">VarnodeData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pieces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>logicalsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get (or create) <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> for <em>pieces</em>. </p>
<p>Given a list of memory locations, the <em>pieces</em>, either find a pre-existing <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> or create a <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> that represents the logical joining of the pieces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pieces</td><td>if the list memory locations to be joined </td></tr>
    <tr><td class="paramname">logicalsize</td><td>of a <em>single</em> <em>piece</em> join, or zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a37ef5b2b70ec5ad9b947945ad352e0e7">joinallocate</a>, <a class="el" href="classAddrSpaceManager.html#a938f0d0e6fb63311401e6b49ecaf5c39">joinspace</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="classJoinRecord.html#a02a0aeb685f59a528e2d15068a7ed8e6">JoinRecord::pieces</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>, <a class="el" href="classAddrSpaceManager.html#a99fdb56e597dc1018860096da746e0fe">splitlist</a>, <a class="el" href="classAddrSpaceManager.html#a5955adafecf6751b1c3df414f8cd3f59">splitset</a>, and <a class="el" href="classJoinRecord.html#a160fbc40fb101bd2a4f6f2e16bfa6269">JoinRecord::unified</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#aed824a71a1d12bb5d167a7a488eb7198">constructFloatExtensionAddress()</a>, <a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">constructJoinAddress()</a>, <a class="el" href="classJoinSpace.html#a782272458968df7a727e7d6280edc8d8">JoinSpace::decodeAttributes()</a>, <a class="el" href="classJoinSpace.html#a7607cfde31c477ef860cca530b502445">JoinSpace::read()</a>, and <a class="el" href="classAddrSpaceManager.html#a68cf42a54806161d8bf3c1fa283036dd">renormalizeJoinAddress()</a>.</p>

</div>
</div>
<a class="anchor" id="ab2f25cc2edce93262a633b17c701b49f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJoinRecord.html">JoinRecord</a> * AddrSpaceManager::findJoin </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> for <em>offset</em> in the join space. </p>
<p>Given a specific <em>offset</em> into the <em>join</em> address space, recover the <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> that lists the pieces corresponding to that offset. The offset must originally have come from a <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> returned by <b>findAddJoin</b>, otherwise this method throws an exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>is an offset into the join space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> for that offset </dd></dl>

<p>References <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="classAddrSpaceManager.html#a99fdb56e597dc1018860096da746e0fe">splitlist</a>, and <a class="el" href="classJoinRecord.html#a160fbc40fb101bd2a4f6f2e16bfa6269">JoinRecord::unified</a>.</p>

<p>Referenced by <a class="el" href="classJoinSpace.html#a3627ef798a38b95cbc28d44ea44e05ba">JoinSpace::encodeAttributes()</a>, and <a class="el" href="classJoinSpace.html#a5ba72eff2b1010e948b1696472979cdd">JoinSpace::printRaw()</a>.</p>

</div>
</div>
<a class="anchor" id="ab596fe6fd25e1e4ec5a9adcbc3f94730"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJoinRecord.html">JoinRecord</a> * AddrSpaceManager::findJoinInternal </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> for <em>offset</em> in the join space. </p>
<p>Given a specific <em>offset</em> into the <em>join</em> address space, recover the <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> that contains the offset, as a range in the <em>join</em> address space. If there is no existing record, null is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>is an offset into the join space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> containing that offset or null </dd></dl>

<p>References <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, <a class="el" href="classAddrSpaceManager.html#a99fdb56e597dc1018860096da746e0fe">splitlist</a>, and <a class="el" href="classJoinRecord.html#a160fbc40fb101bd2a4f6f2e16bfa6269">JoinRecord::unified</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a68cf42a54806161d8bf3c1fa283036dd">renormalizeJoinAddress()</a>.</p>

</div>
</div>
<a class="anchor" id="a77aed07a480b7c60b63c30bea2da711a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> AddrSpaceManager::getConstant </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a constant encoded as an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. </p>
<p>This routine encodes a specific value as a <em>constant</em> address. I.e. the address space of the resulting <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> will be the <b>constant</b> space, and the offset will be the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is the constant value to encode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>constant</em> address </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a107dd46a712fb01cc255912c1c9a5919">constantspace</a>.</p>

</div>
</div>
<a class="anchor" id="a8e1a7314a41ca6854f5c7d19c69acf18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getConstantSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the constant space. </p>
<p>Pcode represents constant values within an operation as offsets within a special <em>constant</em> address space. (See <a class="el" href="classConstantSpace.html" title="Special AddrSpace for representing constants during analysis. ">ConstantSpace</a>) </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <b>constant</b> space </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a107dd46a712fb01cc255912c1c9a5919">constantspace</a>.</p>

<p>Referenced by <a class="el" href="classSleighCompile.html#ac6de6c64a443c17ee0c0b33d0dbf4458">SleighCompile::createCrossBuild()</a>, <a class="el" href="classSleighCompile.html#a9576fc0c7e5e7ed41b3adf76a31edd72">SleighCompile::createMacroUse()</a>, <a class="el" href="classPcodeOpRaw.html#ae4a09db78b969a104972d9b7d3ca0093">PcodeOpRaw::decode()</a>, <a class="el" href="classSleighCompile.html#a7884409eb4d2c4ed715a81bc8f3e5392">SleighCompile::finalizeSections()</a>, <a class="el" href="classSleigh.html#aca7ce17e881917e515aa45ea48810e45">Sleigh::initialize()</a>, <a class="el" href="classSleigh.html#a7057d33c217ca1a7dbbdfcbde0fe1314">Sleigh::oneInstruction()</a>, <a class="el" href="classSleighCompile.html#a01a152b7f82b50630aca66df9ba88daa">SleighCompile::predefinedSymbols()</a>, and <a class="el" href="classMacroBuilder.html#aa684d43d15777ebc7167099c69bf30d5">MacroBuilder::transferOp()</a>.</p>

</div>
</div>
<a class="anchor" id="adfc70d6b8586d28e2b8fe95abf4290a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getDefaultCodeSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default address space of this processor. </p>
<p>Most processors have a main address bus, on which the bulk of the processor's RAM is mapped. This matches SLEIGH's notion of the <em>default</em> space. For Harvard architectures, this is the space where code exists (as opposed to data). </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <em>default</em> code space </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a6fae43e18f50d494152dbd82024eb257">defaultcodespace</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">constructJoinAddress()</a>, <a class="el" href="classAddrSpaceManager.html#a45068bcc8331bebc780f00e51bd85250">copySpaces()</a>, <a class="el" href="structVarnodeData.html#ad620f74a51a72a652bf518571e351957">VarnodeData::decodeFromAttributes()</a>, <a class="el" href="classRange.html#a94744dd422421a5578aaca9fb6f382bf">Range::decodeFromAttributes()</a>, <a class="el" href="classSleighCompile.html#afadd41c3c850e824d48ec7c2638304c8">SleighCompile::newSpace()</a>, <a class="el" href="classSleighCompile.html#a2f2a10a6cc1f1b03f02ebd2f63a2264f">SleighCompile::process()</a>, <a class="el" href="classRange.html#a1f471967fde21f530f087c799681278a">Range::Range()</a>, and <a class="el" href="classSleighBase.html#a661ffc811ae5d7f4ed123b1eb495df94">SleighBase::saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a89303f0cc0bb875ce94c85128f15127e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getDefaultDataSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default address space where data is stored. </p>
<p>Return the default address space for holding data. For most processors, this is just the main RAM space and is the same as the default <em>code</em> space. For Harvard architectures, this is the space where data is stored (as opposed to code). </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <em>default</em> data space </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a8f8acbdca6433d23e37ae66c7e60d01d">defaultdataspace</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a45068bcc8331bebc780f00e51bd85250">copySpaces()</a>, and <a class="el" href="classAddrSpaceManager.html#ae16363aa88c3c9fd1859fc8d36ae9273">parseAddressSimple()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8a93c129bd2799a82cccfc7df915942"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 AddrSpaceManager::getDefaultSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get size of addresses for the default space. </p>
<p>Return the size of addresses for the processor's official default space. This space is usually the main RAM databus. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of an address in bytes </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a6fae43e18f50d494152dbd82024eb257">defaultcodespace</a>, and <a class="el" href="classAddrSpace.html#ac0cfccb152e2d1f13cbb70e253cf69bf">AddrSpace::getAddrSize()</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpace.html#a2a7fb8caa90194445f8e70d2e88557e6">AddrSpace::read()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c5ea8b9d837a8b3a16176530a34eaeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getFspecSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the internal callspec space. </p>
<p>There is a special address space reserved for encoding pointers to the FuncCallSpecs object as addresses. This allows direct pointers to be <em>hidden</em> within an operation, when manipulating pcode internally. (See FspecSpace) </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the address space </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a5c1305f9c6e7580c8647be5fa3d0c5bf">fspecspace</a>.</p>

</div>
</div>
<a class="anchor" id="aa9be6c441d2c5815c6041d14c83aff56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getIopSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the internal pcode op space. </p>
<p>There is a special address space reserved for encoding pointers to pcode operations as addresses. This allows a direct pointer to be <em>hidden</em> within an operation, when manipulating pcode internally. (See IopSpace) </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the address space </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a68f6ef1dc85818c9a7582a8ca6bae441">iopspace</a>.</p>

</div>
</div>
<a class="anchor" id="a3986c7a06ebd80e6c72c45b8133e03a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getJoinSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the joining space. </p>
<p>There is a special address space reserved for providing a logical contiguous memory location for variables that are really split between two physical locations. This allows the the decompiler to work with the logical value. (See <a class="el" href="classJoinSpace.html" title="The pool of logically joined variables. ">JoinSpace</a>) </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the address space </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a938f0d0e6fb63311401e6b49ecaf5c39">joinspace</a>.</p>

</div>
</div>
<a class="anchor" id="a0bcb1edc24d876b71fac49c003307872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getNextSpaceInOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next <em>contiguous</em> address space. </p>
<p>Get the next space in the absolute order of addresses. This ordering is determined by the <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the pointer to the space being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pointer to the next space in absolute order </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a09491be3674d830795dc41795247938e">baselist</a>, and <a class="el" href="classAddrSpace.html#aa6053f6a9a768acc129311f367318a9d">AddrSpace::getIndex()</a>.</p>

<p>Referenced by <a class="el" href="classRange.html#a907491659daa4f7a6064bd357c83f30b">Range::getLastAddrOpen()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c4ce4f25454e86a0383852fe42b3b7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getSpace </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an address space via its index. </p>
<p>This retrieves a specific address space via its formal index. All spaces have an index, and in conjunction with the numSpaces method, this method can be used to iterate over all spaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>is the index of the address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the desired space </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a09491be3674d830795dc41795247938e">baselist</a>.</p>

<p>Referenced by <a class="el" href="classSleighBase.html#a661ffc811ae5d7f4ed123b1eb495df94">SleighBase::saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a799fc65471e0b5201e2dd738f01dc34d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getSpaceByName </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address space by name. </p>
<p>All address spaces have a unique name associated with them. This routine retrieves the <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> object based on the desired name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>is the name of the address space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> object </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a90050a1c183c3c2108a7ad0d6a6fdeaa">name2Space</a>.</p>

<p>Referenced by <a class="el" href="classJoinSpace.html#a782272458968df7a727e7d6280edc8d8">JoinSpace::decodeAttributes()</a>, <a class="el" href="classAddrSpaceManager.html#aee56defff6dfb953555b001afb3a84ea">decodeSpaces()</a>, <a class="el" href="classAddrSpaceManager.html#ae16363aa88c3c9fd1859fc8d36ae9273">parseAddressSimple()</a>, <a class="el" href="classRange.html#a1f471967fde21f530f087c799681278a">Range::Range()</a>, <a class="el" href="classXmlDecode.html#a372e9e97f1e9a9ee2e3ca456d3bfd802">XmlDecode::readSpace()</a>, and <a class="el" href="classAddrSpaceManager.html#aef7d980ea2fc0c6450e941fd7dbec7e6">truncateSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="a0339ab25c08d59c4c1da5cf2d41f055b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getSpaceByShortcut </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address space from its shortcut. </p>
<p>All address spaces have a unique shortcut (ASCII) character assigned to them. This routine retrieves an <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> object given a specific shortcut. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sc</td><td>is the shortcut character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a6a423a82fa9781995acb644adb9f50f5">shortcut2Space</a>.</p>

<p>Referenced by <a class="el" href="classJoinSpace.html#a7607cfde31c477ef860cca530b502445">JoinSpace::read()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c6a5c3c4ceadaf7f0b4343f52639153"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getStackSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stack space for this processor. </p>
<p>Most processors have registers and instructions that are reserved for implementing a stack. In the pcode translation, these are translated into locations and operations on a dedicated <b>stack</b> address space. (See <a class="el" href="classSpacebaseSpace.html" title="A virtual space stack space. ">SpacebaseSpace</a>) </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <b>stack</b> space </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#aea6bb24b1ee9d16fa4ae5cc5908ac493">stackspace</a>.</p>

</div>
</div>
<a class="anchor" id="a3bef0bbef7bfe26c2790ec6018d8fc02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpaceManager::getUniqueSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the temporary register space for this processor. </p>
<p>Both the pcode translation process and the simplification process need access to a pool of temporary registers that can be used for moving data around without affecting the address spaces used to formally model the processor's RAM and registers. These temporary locations are all allocated from a dedicated address space, referred to as the <b>unique</b> space. (See <a class="el" href="classUniqueSpace.html" title="The pool of temporary storage registers. ">UniqueSpace</a>) </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <b>unique</b> space </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#abdaa7f4f1c3d5885c0dc9c67d9a17557">uniqspace</a>.</p>

<p>Referenced by <a class="el" href="classSleigh.html#a7057d33c217ca1a7dbbdfcbde0fe1314">Sleigh::oneInstruction()</a>, <a class="el" href="classSleighCompile.html#a01a152b7f82b50630aca66df9ba88daa">SleighCompile::predefinedSymbols()</a>, <a class="el" href="classSleighCompile.html#a5d9ed43987bc167ad93691052361975d">SleighCompile::setResultStarVarnode()</a>, and <a class="el" href="classMacroBuilder.html#aa684d43d15777ebc7167099c69bf30d5">MacroBuilder::transferOp()</a>.</p>

</div>
</div>
<a class="anchor" id="a6330481f1f40a24d860c820a5a2b64f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::insertResolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAddressResolver.html">AddressResolver</a> *&#160;</td>
          <td class="paramname"><em>rsolv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override the base resolver for a space. </p>
<p>Provide a new specialized resolver for a specific <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a>. The manager takes ownership of resolver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the space to which the resolver is associated </td></tr>
    <tr><td class="paramname">rsolv</td><td>is the new resolver object </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#aa6053f6a9a768acc129311f367318a9d">AddrSpace::getIndex()</a>, and <a class="el" href="classAddrSpaceManager.html#a640a67012d0bc05bd417c6aee5ef45bb">resolvelist</a>.</p>

</div>
</div>
<a class="anchor" id="a89658bd677414a271a918f0f37af0bd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::insertSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new address space to the model. </p>
<p>This adds a previously instantiated address space (<a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a>) to the model for this processor. It checks a set of indexing and naming conventions for the space and throws an exception if the conventions are violated. Should only be called during initialization. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>This really shouldn't be public. Need to move the allocation of <b>iop</b>, <b>fspec</b>, and <b>join</b> out of Architecture </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>the address space to insert </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a9d5300e7a40dba53c7c78fdacebfc6ed">assignShortcut()</a>, <a class="el" href="classAddrSpaceManager.html#a09491be3674d830795dc41795247938e">baselist</a>, <a class="el" href="classAddrSpaceManager.html#a107dd46a712fb01cc255912c1c9a5919">constantspace</a>, <a class="el" href="classAddrSpaceManager.html#a5c1305f9c6e7580c8647be5fa3d0c5bf">fspecspace</a>, <a class="el" href="classAddrSpace.html#a5971d35628c019b97c34a4b90001a5f8">AddrSpace::getContain()</a>, <a class="el" href="classAddrSpace.html#a9a1077feee89cf4434154e017a3360f5">AddrSpace::getName()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="classAddrSpace.html#ace333a37cd6fe6ae2c52cd9d64d7269e">AddrSpace::index</a>, <a class="el" href="classConstantSpace.html#a0af7ba99f5b1cbaa516054d42224b221">ConstantSpace::INDEX</a>, <a class="el" href="classOtherSpace.html#a7553cfcbe9798cd2df0b8af62e4b5a51">OtherSpace::INDEX</a>, <a class="el" href="classAddrSpaceManager.html#a68f6ef1dc85818c9a7582a8ca6bae441">iopspace</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a3ae8eb421cb8d460bc939657402d970a">IPTR_CONSTANT</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a01bf4d06e504bf92eabbfd633e5c74c0">IPTR_FSPEC</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a1eef2cfc279c246cc7ea0387d8c0aa66">IPTR_INTERNAL</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231ad644dc33b71c7d421fcd0fb2003407c7">IPTR_IOP</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a67805851c12bd1477c2a748e53e45f9c">IPTR_JOIN</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231ac6a759a590195b56c099150c63cdd7b2">IPTR_PROCESSOR</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231aebea73c9a75ffad2803a312d021932b5">IPTR_SPACEBASE</a>, <a class="el" href="classAddrSpace.html#a0770e74cdceaa69623914616cb43c4ed">AddrSpace::isOtherSpace()</a>, <a class="el" href="classAddrSpace.html#a4a4dcdfc3ef7230974b5f4a36161d29d">AddrSpace::isOverlay()</a>, <a class="el" href="classAddrSpaceManager.html#a938f0d0e6fb63311401e6b49ecaf5c39">joinspace</a>, <a class="el" href="classConstantSpace.html#afee0684a455a4a9828e6cf0845a56839">ConstantSpace::NAME</a>, <a class="el" href="classUniqueSpace.html#a1ff9d0080531f5377e877b77a9462c4a">UniqueSpace::NAME</a>, <a class="el" href="classJoinSpace.html#abae63c158d743df43168bdd580408059">JoinSpace::NAME</a>, <a class="el" href="classAddrSpaceManager.html#a90050a1c183c3c2108a7ad0d6a6fdeaa">name2Space</a>, <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451ae8c7fcb8745b27504eb57262b2936d4b">AddrSpace::overlaybase</a>, <a class="el" href="classAddrSpace.html#af0886d7bcbf22c5157cd09b1554d4f38">AddrSpace::refcount</a>, <a class="el" href="classAddrSpace.html#a3dd14c033be519525d486fcbc94a2bf7">AddrSpace::setFlags()</a>, <a class="el" href="classAddrSpaceManager.html#aea6bb24b1ee9d16fa4ae5cc5908ac493">stackspace</a>, and <a class="el" href="classAddrSpaceManager.html#abdaa7f4f1c3d5885c0dc9c67d9a17557">uniqspace</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a45068bcc8331bebc780f00e51bd85250">copySpaces()</a>, <a class="el" href="classAddrSpaceManager.html#aee56defff6dfb953555b001afb3a84ea">decodeSpaces()</a>, <a class="el" href="classSleighCompile.html#afadd41c3c850e824d48ec7c2638304c8">SleighCompile::newSpace()</a>, and <a class="el" href="classSleighCompile.html#a01a152b7f82b50630aca66df9ba88daa">SleighCompile::predefinedSymbols()</a>.</p>

</div>
</div>
<a class="anchor" id="aba1c818ccc3950c188e06df08746725f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::markNearPointers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark that given space can be accessed with near pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> to mark </td></tr>
    <tr><td class="paramname">size</td><td>is the (minimum) size of a near pointer in bytes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#a05c9b715d49d562e566ca392818fb798">AddrSpace::addressSize</a>, <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a4a7e5f29d8510b239e70ba18fa9c7864">AddrSpace::has_nearpointers</a>, <a class="el" href="classAddrSpace.html#acd897fe79e11489f2c9204f4a07067fc">AddrSpace::minimumPointerSize</a>, and <a class="el" href="classAddrSpace.html#a3dd14c033be519525d486fcbc94a2bf7">AddrSpace::setFlags()</a>.</p>

</div>
</div>
<a class="anchor" id="abb27d4583ae1bfb9e2a16139bae922d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 AddrSpaceManager::numSpaces </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of address spaces for this processor. </p>
<p>This returns the total number of address spaces used by the processor, including all special spaces, like the <b>constant</b> space and the <b>iop</b> space. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of spaces </dd></dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a09491be3674d830795dc41795247938e">baselist</a>.</p>

<p>Referenced by <a class="el" href="classSleighCompile.html#afadd41c3c850e824d48ec7c2638304c8">SleighCompile::newSpace()</a>, <a class="el" href="classSleighCompile.html#a01a152b7f82b50630aca66df9ba88daa">SleighCompile::predefinedSymbols()</a>, and <a class="el" href="classSleighBase.html#a661ffc811ae5d7f4ed123b1eb495df94">SleighBase::saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="ae16363aa88c3c9fd1859fc8d36ae9273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> AddrSpaceManager::parseAddressSimple </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string with just an <em>address</em> <em>space</em> name and a hex offset. </p>
<p>The string <em>must</em> contain a hexadecimal offset. The offset may be optionally prepended with "0x". The string may optionally start with the name of the address space to associate with the offset, followed by ':' to separate it from the offset. If the name is not present, the default data space is assumed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is the string to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed address </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#af5925a4ae67a290f59bf17533fac62b4">AddrSpace::addressToByte()</a>, <a class="el" href="classAddrSpaceManager.html#a89303f0cc0bb875ce94c85128f15127e">getDefaultDataSpace()</a>, <a class="el" href="classAddrSpaceManager.html#a799fc65471e0b5201e2dd738f01dc34d">getSpaceByName()</a>, and <a class="el" href="classAddrSpace.html#a2a3d94aea39c4fc962e493b81452afe8">AddrSpace::getWordSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a68cf42a54806161d8bf3c1fa283036dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::renormalizeJoinAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure a possibly offset <em>join</em> address has a proper <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a>. </p>
<p>If an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> in the <em>join</em> AddressSpace is shifted from its original offset, it may no longer have a valid <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a>. The shift or size change may even make the address of one of the pieces a more natural representation. Given a new <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> and size, this method decides if there is a matching <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a>. If not it either constructs a new <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> or computes the address within the containing piece. The given <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> is changed if necessary either to the offset corresponding to the new <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> or to a normal <em>non-join</em> <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>is the given <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the range in bytes </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a1b9e7e934e22b6bea3b2b949fd2b2159">findAddJoin()</a>, <a class="el" href="classAddrSpaceManager.html#ab596fe6fd25e1e4ec5a9adcbc3f94730">findJoinInternal()</a>, <a class="el" href="classJoinRecord.html#a107bed4b4a47a8f672aa252818cb323d">JoinRecord::getEquivalentAddress()</a>, <a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">Address::getOffset()</a>, <a class="el" href="classAddress.html#a36631134a5ad2883696d26300e4894b1">Address::isInvalid()</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="classJoinRecord.html#a02a0aeb685f59a528e2d15068a7ed8e6">JoinRecord::pieces</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>, and <a class="el" href="classJoinRecord.html#a160fbc40fb101bd2a4f6f2e16bfa6269">JoinRecord::unified</a>.</p>

<p>Referenced by <a class="el" href="classAddress.html#a079f391c59a43a0e0fb8a5c66eaf6f64">Address::renormalize()</a>.</p>

</div>
</div>
<a class="anchor" id="a27d2893a87a604368cb0891482551349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> AddrSpaceManager::resolveConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb &amp;&#160;</td>
          <td class="paramname"><em>fullEncoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve a native constant into an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. </p>
<p>If there is a special resolver for the <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a>, this is invoked, otherwise basic wordsize conversion and wrapping is performed. If the address encoding is partial (as in a <em>near</em> pointer) and the full encoding can be recovered, it is passed back. The <em>sz</em> parameter indicates the number of bytes in constant and is used to determine if the constant is a partial or full pointer encoding. A value of -1 indicates the value is known to be a full encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the space to generate the address from </td></tr>
    <tr><td class="paramname">val</td><td>is the constant encoding of the address </td></tr>
    <tr><td class="paramname">sz</td><td>is the size of the constant encoding (or -1) </td></tr>
    <tr><td class="paramname">point</td><td>is the context address (for recovering full encoding info if necessary) </td></tr>
    <tr><td class="paramname">fullEncoding</td><td>is used to pass back the recovered full encoding of the pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the formal <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> associated with the encoding </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#af5925a4ae67a290f59bf17533fac62b4">AddrSpace::addressToByte()</a>, <a class="el" href="classAddrSpace.html#aa6053f6a9a768acc129311f367318a9d">AddrSpace::getIndex()</a>, <a class="el" href="classAddrSpace.html#a2a3d94aea39c4fc962e493b81452afe8">AddrSpace::getWordSize()</a>, <a class="el" href="classAddressResolver.html#a80c05cd2e1a4ff745967f9f1512d418d">AddressResolver::resolve()</a>, <a class="el" href="classAddrSpaceManager.html#a640a67012d0bc05bd417c6aee5ef45bb">resolvelist</a>, and <a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">AddrSpace::wrapOffset()</a>.</p>

</div>
</div>
<a class="anchor" id="ae82d08eab20f86a31fe366a9bcd58629"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::setDeadcodeDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>delaydelta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the deadcodedelay for a specific space. </p>
<p>Set the number of passes for a specific <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> before deadcode removal is allowed for that space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spc</td><td>is the <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> to change </td></tr>
    <tr><td class="paramname">delaydelta</td><td>is the number of rounds to the delay should be set to </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#aa2fd37355d0ed2ebee552ac944f67d95">AddrSpace::deadcodedelay</a>.</p>

</div>
</div>
<a class="anchor" id="a9001bbb4f273b895325e1cad6a8930d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::setDefaultCodeSpace </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the default address space (for code) </p>
<p>Once all the address spaces have been initialized, this routine should be called once to establish the official <em>default</em> space for the processor, via its index. Should only be called during initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>is the index of the desired default space </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a09491be3674d830795dc41795247938e">baselist</a>, <a class="el" href="classAddrSpaceManager.html#a6fae43e18f50d494152dbd82024eb257">defaultcodespace</a>, and <a class="el" href="classAddrSpaceManager.html#a8f8acbdca6433d23e37ae66c7e60d01d">defaultdataspace</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a45068bcc8331bebc780f00e51bd85250">copySpaces()</a>, <a class="el" href="classAddrSpaceManager.html#aee56defff6dfb953555b001afb3a84ea">decodeSpaces()</a>, and <a class="el" href="classSleighCompile.html#afadd41c3c850e824d48ec7c2638304c8">SleighCompile::newSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="a5889b07364f07bbc30f79cda62a68d23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::setDefaultDataSpace </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the default address space for data. </p>
<p>If the architecture has different code and data spaces, this routine can be called to set the <em>data</em> space after the <em>code</em> space has been set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>is the index of the desired default space </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpaceManager.html#a09491be3674d830795dc41795247938e">baselist</a>, <a class="el" href="classAddrSpaceManager.html#a6fae43e18f50d494152dbd82024eb257">defaultcodespace</a>, and <a class="el" href="classAddrSpaceManager.html#a8f8acbdca6433d23e37ae66c7e60d01d">defaultdataspace</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a45068bcc8331bebc780f00e51bd85250">copySpaces()</a>.</p>

</div>
</div>
<a class="anchor" id="a3271657111f46abc8b10bfdeb56e881d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::setInferPtrBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRange.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the range of addresses that can be inferred as pointers. </p>
<p>This method establishes for a single address space, what range of constants are checked as possible symbol starts, when it is not known apriori that a constant is a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>is the range of values for a single address space </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRange.html#a95edabf8ef5fec9f9a5ead6bfbd186f2">Range::getFirst()</a>, <a class="el" href="classRange.html#ad30a7b51202bd1937e70db1a661b6c70">Range::getLast()</a>, <a class="el" href="classRange.html#a621cd0851c083c88977264bd8ffedd8b">Range::getSpace()</a>, <a class="el" href="classAddrSpace.html#a8e5a220b549a1bac5d86a8ccaae68c2f">AddrSpace::pointerLowerBound</a>, and <a class="el" href="classAddrSpace.html#a9314f29b21a32cc860db914606991912">AddrSpace::pointerUpperBound</a>.</p>

</div>
</div>
<a class="anchor" id="abdab85595c68e18ab86dd42af914f35b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::setReverseJustified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>spc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set reverse justified property on this space. </p>
<p>For spaces with alignment restrictions, the address of a small variable must be justified within a larger aligned memory word, usually either to the left boundary for little endian encoding or to the right boundary for big endian encoding. Some compilers justify small variables to the opposite side of the one indicated by the endianness. Setting this property on a space causes the decompiler to use this justification </p>

<p>References <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451abb22ff2778e1876ccf90657fc6df801f">AddrSpace::reverse_justification</a>, and <a class="el" href="classAddrSpace.html#a3dd14c033be519525d486fcbc94a2bf7">AddrSpace::setFlags()</a>.</p>

</div>
</div>
<a class="anchor" id="aef7d980ea2fc0c6450e941fd7dbec7e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpaceManager::truncateSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTruncationTag.html">TruncationTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a space as truncated from its original size. </p>
<p>Mark the named space as truncated from its original size </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>is a description of the space and how it should be truncated </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classTruncationTag.html#a61631adb661eba44832d179b286520ac">TruncationTag::getName()</a>, <a class="el" href="classTruncationTag.html#a068e1caf6de7a0ea2fddb03158cf5890">TruncationTag::getSize()</a>, <a class="el" href="classAddrSpaceManager.html#a799fc65471e0b5201e2dd738f01dc34d">getSpaceByName()</a>, and <a class="el" href="classAddrSpace.html#a84ecacea771a34c4349d1f31272316c7">AddrSpace::truncateSpace()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="translate_8hh.html">translate.hh</a></li>
<li>translate.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
