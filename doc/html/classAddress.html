<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>decompiler: Address Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classAddress-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Address Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A low-level machine address for labelling bytes and data.  
 <a href="classAddress.html#details">More...</a></p>

<p><code>#include &lt;address.hh&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab6dfc48b4779dab420c4ae0bc5aaffd7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#ab6dfc48b4779dab420c4ae0bc5aaffd7">mach_extreme</a> { <a class="el" href="classAddress.html#ab6dfc48b4779dab420c4ae0bc5aaffd7a1990ccfacf791a707a42d623bdc4134d">m_minimal</a>, 
<a class="el" href="classAddress.html#ab6dfc48b4779dab420c4ae0bc5aaffd7abe15025551d5d35578ab1f409e3f6b7f">m_maximal</a>
 }</td></tr>
<tr class="memdesc:ab6dfc48b4779dab420c4ae0bc5aaffd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum for specifying extremal addresses.  <a href="classAddress.html#ab6dfc48b4779dab420c4ae0bc5aaffd7">More...</a><br/></td></tr>
<tr class="separator:ab6dfc48b4779dab420c4ae0bc5aaffd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a84f096e8cab2cd71a252877055938759"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a84f096e8cab2cd71a252877055938759">Address</a> (<a class="el" href="classAddress.html#ab6dfc48b4779dab420c4ae0bc5aaffd7">mach_extreme</a> ex)</td></tr>
<tr class="memdesc:a84f096e8cab2cd71a252877055938759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an extremal address.  <a href="#a84f096e8cab2cd71a252877055938759">More...</a><br/></td></tr>
<tr class="separator:a84f096e8cab2cd71a252877055938759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a01db36be374e934ed33c773e31b7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a69a01db36be374e934ed33c773e31b7f">Address</a> (void)</td></tr>
<tr class="memdesc:a69a01db36be374e934ed33c773e31b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an invalid address.  <a href="#a69a01db36be374e934ed33c773e31b7f">More...</a><br/></td></tr>
<tr class="separator:a69a01db36be374e934ed33c773e31b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa525e3d0433b8bbe9045465d78cfe5ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#aa525e3d0433b8bbe9045465d78cfe5ae">Address</a> (<a class="el" href="classAddrSpace.html">AddrSpace</a> *id, uintb off)</td></tr>
<tr class="memdesc:aa525e3d0433b8bbe9045465d78cfe5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an address with a space/offset pair.  <a href="#aa525e3d0433b8bbe9045465d78cfe5ae">More...</a><br/></td></tr>
<tr class="separator:aa525e3d0433b8bbe9045465d78cfe5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29436dab23400efc18afcf58ce529082"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a29436dab23400efc18afcf58ce529082">Address</a> (const <a class="el" href="classAddress.html">Address</a> &amp;op2)</td></tr>
<tr class="memdesc:a29436dab23400efc18afcf58ce529082"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy constructor.  <a href="#a29436dab23400efc18afcf58ce529082">More...</a><br/></td></tr>
<tr class="separator:a29436dab23400efc18afcf58ce529082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36631134a5ad2883696d26300e4894b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a36631134a5ad2883696d26300e4894b1">isInvalid</a> (void) const </td></tr>
<tr class="memdesc:a36631134a5ad2883696d26300e4894b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the address invalid?  <a href="#a36631134a5ad2883696d26300e4894b1">More...</a><br/></td></tr>
<tr class="separator:a36631134a5ad2883696d26300e4894b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e9717c199593d3446eae0328499e43"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a45e9717c199593d3446eae0328499e43">getAddrSize</a> (void) const </td></tr>
<tr class="memdesc:a45e9717c199593d3446eae0328499e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes in the address.  <a href="#a45e9717c199593d3446eae0328499e43">More...</a><br/></td></tr>
<tr class="separator:a45e9717c199593d3446eae0328499e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7209c4a9300045576cf400b7443981e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#ae7209c4a9300045576cf400b7443981e">isBigEndian</a> (void) const </td></tr>
<tr class="memdesc:ae7209c4a9300045576cf400b7443981e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is data at this address big endian encoded.  <a href="#ae7209c4a9300045576cf400b7443981e">More...</a><br/></td></tr>
<tr class="separator:ae7209c4a9300045576cf400b7443981e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040ac0edbb01bd26c8956130ec4ef20e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a040ac0edbb01bd26c8956130ec4ef20e">printRaw</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:a040ac0edbb01bd26c8956130ec4ef20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a raw version of the address to a stream.  <a href="#a040ac0edbb01bd26c8956130ec4ef20e">More...</a><br/></td></tr>
<tr class="separator:a040ac0edbb01bd26c8956130ec4ef20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10953bd3fe65b279ee102a69d43e2d27"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a10953bd3fe65b279ee102a69d43e2d27">read</a> (const string &amp;s)</td></tr>
<tr class="memdesc:a10953bd3fe65b279ee102a69d43e2d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in the address from a string.  <a href="#a10953bd3fe65b279ee102a69d43e2d27">More...</a><br/></td></tr>
<tr class="separator:a10953bd3fe65b279ee102a69d43e2d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7255960e441327e10b24442d44a2bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#acb7255960e441327e10b24442d44a2bd">getSpace</a> (void) const </td></tr>
<tr class="memdesc:acb7255960e441327e10b24442d44a2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address space.  <a href="#acb7255960e441327e10b24442d44a2bd">More...</a><br/></td></tr>
<tr class="separator:acb7255960e441327e10b24442d44a2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e9bc454f258c51c1ddccc336922a8d"><td class="memItemLeft" align="right" valign="top">uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a90e9bc454f258c51c1ddccc336922a8d">getOffset</a> (void) const </td></tr>
<tr class="memdesc:a90e9bc454f258c51c1ddccc336922a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address offset.  <a href="#a90e9bc454f258c51c1ddccc336922a8d">More...</a><br/></td></tr>
<tr class="separator:a90e9bc454f258c51c1ddccc336922a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f2d71168775f819e4e482c2e13c1b9"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#af0f2d71168775f819e4e482c2e13c1b9">getShortcut</a> (void) const </td></tr>
<tr class="memdesc:af0f2d71168775f819e4e482c2e13c1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shortcut character for the address space.  <a href="#af0f2d71168775f819e4e482c2e13c1b9">More...</a><br/></td></tr>
<tr class="separator:af0f2d71168775f819e4e482c2e13c1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942aba71799e61225a20135d3dc86453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a942aba71799e61225a20135d3dc86453">operator=</a> (const <a class="el" href="classAddress.html">Address</a> &amp;op2)</td></tr>
<tr class="memdesc:a942aba71799e61225a20135d3dc86453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an address.  <a href="#a942aba71799e61225a20135d3dc86453">More...</a><br/></td></tr>
<tr class="separator:a942aba71799e61225a20135d3dc86453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb86b64921c6989b56be7f7804dddec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#abfb86b64921c6989b56be7f7804dddec">operator==</a> (const <a class="el" href="classAddress.html">Address</a> &amp;op2) const </td></tr>
<tr class="memdesc:abfb86b64921c6989b56be7f7804dddec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two addresses for equality.  <a href="#abfb86b64921c6989b56be7f7804dddec">More...</a><br/></td></tr>
<tr class="separator:abfb86b64921c6989b56be7f7804dddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ef47cee744c1a30a5603b5a35bb058"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a05ef47cee744c1a30a5603b5a35bb058">operator!=</a> (const <a class="el" href="classAddress.html">Address</a> &amp;op2) const </td></tr>
<tr class="memdesc:a05ef47cee744c1a30a5603b5a35bb058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two addresses for inequality.  <a href="#a05ef47cee744c1a30a5603b5a35bb058">More...</a><br/></td></tr>
<tr class="separator:a05ef47cee744c1a30a5603b5a35bb058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07d3060bdc07d9b25cea7c561e6ef81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#af07d3060bdc07d9b25cea7c561e6ef81">operator&lt;</a> (const <a class="el" href="classAddress.html">Address</a> &amp;op2) const </td></tr>
<tr class="memdesc:af07d3060bdc07d9b25cea7c561e6ef81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two addresses via their natural ordering.  <a href="#af07d3060bdc07d9b25cea7c561e6ef81">More...</a><br/></td></tr>
<tr class="separator:af07d3060bdc07d9b25cea7c561e6ef81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae71cfe5906858be8c34d8b2cce18fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a4ae71cfe5906858be8c34d8b2cce18fd">operator&lt;=</a> (const <a class="el" href="classAddress.html">Address</a> &amp;op2) const </td></tr>
<tr class="memdesc:a4ae71cfe5906858be8c34d8b2cce18fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two addresses via their natural ordering.  <a href="#a4ae71cfe5906858be8c34d8b2cce18fd">More...</a><br/></td></tr>
<tr class="separator:a4ae71cfe5906858be8c34d8b2cce18fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a440c026e09b7ec2d2cb361301c6164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a2a440c026e09b7ec2d2cb361301c6164">operator+</a> (int4 off) const </td></tr>
<tr class="memdesc:a2a440c026e09b7ec2d2cb361301c6164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment address by a number of bytes.  <a href="#a2a440c026e09b7ec2d2cb361301c6164">More...</a><br/></td></tr>
<tr class="separator:a2a440c026e09b7ec2d2cb361301c6164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239158df52ba68f63d5d697b17067743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a239158df52ba68f63d5d697b17067743">operator-</a> (int4 off) const </td></tr>
<tr class="memdesc:a239158df52ba68f63d5d697b17067743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement address by a number of bytes.  <a href="#a239158df52ba68f63d5d697b17067743">More...</a><br/></td></tr>
<tr class="separator:a239158df52ba68f63d5d697b17067743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96db8627391dda4a570ee397e9cad814"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a96db8627391dda4a570ee397e9cad814">containedBy</a> (int4 sz, const <a class="el" href="classAddress.html">Address</a> &amp;op2, int4 sz2) const </td></tr>
<tr class="memdesc:a96db8627391dda4a570ee397e9cad814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if <em>op2</em> range contains <b>this</b> range.  <a href="#a96db8627391dda4a570ee397e9cad814">More...</a><br/></td></tr>
<tr class="separator:a96db8627391dda4a570ee397e9cad814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bb3dfe1bd894305f137aac061c8707"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a87bb3dfe1bd894305f137aac061c8707">justifiedContain</a> (int4 sz, const <a class="el" href="classAddress.html">Address</a> &amp;op2, int4 sz2, bool forceleft) const </td></tr>
<tr class="memdesc:a87bb3dfe1bd894305f137aac061c8707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if <em>op2</em> is the least significant part of <em>this</em>.  <a href="#a87bb3dfe1bd894305f137aac061c8707">More...</a><br/></td></tr>
<tr class="separator:a87bb3dfe1bd894305f137aac061c8707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bcd73e2401a3416abd1ee02b0bd2f4"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a14bcd73e2401a3416abd1ee02b0bd2f4">overlap</a> (int4 skip, const <a class="el" href="classAddress.html">Address</a> &amp;op, int4 size) const </td></tr>
<tr class="memdesc:a14bcd73e2401a3416abd1ee02b0bd2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how two address ranges overlap.  <a href="#a14bcd73e2401a3416abd1ee02b0bd2f4">More...</a><br/></td></tr>
<tr class="separator:a14bcd73e2401a3416abd1ee02b0bd2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de8fd2dd0029f985341ec5bb3530008"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a7de8fd2dd0029f985341ec5bb3530008">isContiguous</a> (int4 sz, const <a class="el" href="classAddress.html">Address</a> &amp;loaddr, int4 losz) const </td></tr>
<tr class="memdesc:a7de8fd2dd0029f985341ec5bb3530008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does <em>this</em> form a contigous range with <em>loaddr</em>.  <a href="#a7de8fd2dd0029f985341ec5bb3530008">More...</a><br/></td></tr>
<tr class="separator:a7de8fd2dd0029f985341ec5bb3530008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b132480ba80a42ba433f52b00164f91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a5b132480ba80a42ba433f52b00164f91">isConstant</a> (void) const </td></tr>
<tr class="memdesc:a5b132480ba80a42ba433f52b00164f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a <em>constant</em> <em>value</em>.  <a href="#a5b132480ba80a42ba433f52b00164f91">More...</a><br/></td></tr>
<tr class="separator:a5b132480ba80a42ba433f52b00164f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079f391c59a43a0e0fb8a5c66eaf6f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a079f391c59a43a0e0fb8a5c66eaf6f64">renormalize</a> (int4 size)</td></tr>
<tr class="memdesc:a079f391c59a43a0e0fb8a5c66eaf6f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure there is a backing <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> if <b>this</b> is in the <em>join</em> space.  <a href="#a079f391c59a43a0e0fb8a5c66eaf6f64">More...</a><br/></td></tr>
<tr class="separator:a079f391c59a43a0e0fb8a5c66eaf6f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af320224a1a004a7bc94d2fa8ac474835"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#af320224a1a004a7bc94d2fa8ac474835">isJoin</a> (void) const </td></tr>
<tr class="memdesc:af320224a1a004a7bc94d2fa8ac474835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a <em>join</em> <em>value</em>.  <a href="#af320224a1a004a7bc94d2fa8ac474835">More...</a><br/></td></tr>
<tr class="separator:af320224a1a004a7bc94d2fa8ac474835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb62651d149f28317aa0af35830a739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#afcb62651d149f28317aa0af35830a739">encode</a> (<a class="el" href="classEncoder.html">Encoder</a> &amp;encoder) const </td></tr>
<tr class="memdesc:afcb62651d149f28317aa0af35830a739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode <b>this</b> to a stream.  <a href="#afcb62651d149f28317aa0af35830a739">More...</a><br/></td></tr>
<tr class="separator:afcb62651d149f28317aa0af35830a739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbab61be30fc265c60b8336a57b81e6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#afbab61be30fc265c60b8336a57b81e6a">encode</a> (<a class="el" href="classEncoder.html">Encoder</a> &amp;encoder, int4 size) const </td></tr>
<tr class="memdesc:afbab61be30fc265c60b8336a57b81e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode <b>this</b> and a size to a stream.  <a href="#afbab61be30fc265c60b8336a57b81e6a">More...</a><br/></td></tr>
<tr class="separator:afbab61be30fc265c60b8336a57b81e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8ba6e1ffe8881aefcc3d9ba9acf6d8d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#a8ba6e1ffe8881aefcc3d9ba9acf6d8d4">decode</a> (<a class="el" href="classDecoder.html">Decoder</a> &amp;decoder)</td></tr>
<tr class="memdesc:a8ba6e1ffe8881aefcc3d9ba9acf6d8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore an address from parsed XML.  <a href="#a8ba6e1ffe8881aefcc3d9ba9acf6d8d4">More...</a><br/></td></tr>
<tr class="separator:a8ba6e1ffe8881aefcc3d9ba9acf6d8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f596516a325482bf9f8d6af9cd32ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classAddress.html">Address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#ab8f596516a325482bf9f8d6af9cd32ce">decode</a> (<a class="el" href="classDecoder.html">Decoder</a> &amp;decoder, int4 &amp;size)</td></tr>
<tr class="memdesc:ab8f596516a325482bf9f8d6af9cd32ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore an address and size from parsed XML.  <a href="#ab8f596516a325482bf9f8d6af9cd32ce">More...</a><br/></td></tr>
<tr class="separator:ab8f596516a325482bf9f8d6af9cd32ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac08d67074731b83664127bb0cc190bfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac08d67074731b83664127bb0cc190bfe"></a>
<a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a></td></tr>
<tr class="memdesc:ac08d67074731b83664127bb0cc190bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to our address space. <br/></td></tr>
<tr class="separator:ac08d67074731b83664127bb0cc190bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb9f0a40c81e28e83eca5a9de2959a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbb9f0a40c81e28e83eca5a9de2959a8"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a></td></tr>
<tr class="memdesc:adbb9f0a40c81e28e83eca5a9de2959a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset (in bytes) <br/></td></tr>
<tr class="separator:adbb9f0a40c81e28e83eca5a9de2959a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aad61b7eee4f2506349c6a517a1271faa"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddress.html#aad61b7eee4f2506349c6a517a1271faa">operator&lt;&lt;</a> (ostream &amp;s, const <a class="el" href="classAddress.html">Address</a> &amp;addr)</td></tr>
<tr class="memdesc:aad61b7eee4f2506349c6a517a1271faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an address to stream.  <a href="#aad61b7eee4f2506349c6a517a1271faa">More...</a><br/></td></tr>
<tr class="separator:aad61b7eee4f2506349c6a517a1271faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A low-level machine address for labelling bytes and data. </p>
<p>All data that can be manipulated within the processor reverse engineering model can be labelled with an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>. It is simply an address space (<a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a>) and an offset within that space. Note that processor registers are typically modelled by creating a dedicated address space for them, as distinct from RAM say, and then specifying certain addresses within the register space that correspond to particular registers. However, an arbitrary address could refer to anything, RAM, ROM, cpu register, data segment, coprocessor, stack, nvram, etc. An <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> represents an offset <em>only</em>, not an offset and length </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ab6dfc48b4779dab420c4ae0bc5aaffd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classAddress.html#ab6dfc48b4779dab420c4ae0bc5aaffd7">Address::mach_extreme</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enum for specifying extremal addresses. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ab6dfc48b4779dab420c4ae0bc5aaffd7a1990ccfacf791a707a42d623bdc4134d"></a>m_minimal</em>&nbsp;</td><td class="fielddoc">
<p>Smallest possible address. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ab6dfc48b4779dab420c4ae0bc5aaffd7abe15025551d5d35578ab1f409e3f6b7f"></a>m_maximal</em>&nbsp;</td><td class="fielddoc">
<p>Biggest possible address. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a84f096e8cab2cd71a252877055938759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Address::Address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddress.html#ab6dfc48b4779dab420c4ae0bc5aaffd7">mach_extreme</a>&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an extremal address. </p>
<p>Some data structures sort on an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>, and it is convenient to be able to create an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> that is either bigger than or smaller than all other Addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>is either <em>m_minimal</em> or <em>m_maximal</em> </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddress.html#ab6dfc48b4779dab420c4ae0bc5aaffd7a1990ccfacf791a707a42d623bdc4134d">m_minimal</a>, and <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>.</p>

</div>
</div>
<a class="anchor" id="a69a01db36be374e934ed33c773e31b7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Address::Address </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an invalid address. </p>
<p>An invalid address is possible in some circumstances. This deliberately constructs an invalid address </p>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>.</p>

<p>Referenced by <a class="el" href="classAddress.html#a8ba6e1ffe8881aefcc3d9ba9acf6d8d4">decode()</a>, <a class="el" href="classAddress.html#a2a440c026e09b7ec2d2cb361301c6164">operator+()</a>, and <a class="el" href="classAddress.html#a239158df52ba68f63d5d697b17067743">operator-()</a>.</p>

</div>
</div>
<a class="anchor" id="aa525e3d0433b8bbe9045465d78cfe5ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Address::Address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an address with a space/offset pair. </p>
<p>This is the basic <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the space containing the address </td></tr>
    <tr><td class="paramname">off</td><td>is the offset of the address </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, and <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>.</p>

</div>
</div>
<a class="anchor" id="a29436dab23400efc18afcf58ce529082"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Address::Address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A copy constructor. </p>
<p>This is a standard copy constructor, copying the address space and the offset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> to copy </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, and <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a96db8627391dda4a570ee397e9cad814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Address::containedBy </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if <em>op2</em> range contains <b>this</b> range. </p>
<p>Return <b>true</b> if the range starting at <b>this</b> extending the given number of bytes is contained by the second given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>is the given number of bytes in <b>this</b> range </td></tr>
    <tr><td class="paramname">op2</td><td>is the start of the second given range </td></tr>
    <tr><td class="paramname">sz2</td><td>is the number of bytes in the second given range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the second given range contains <b>this</b> range </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, and <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>.</p>

</div>
</div>
<a class="anchor" id="a8ba6e1ffe8881aefcc3d9ba9acf6d8d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> Address::decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDecoder.html">Decoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore an address from parsed XML. </p>
<p>This is usually used to decode an address from an <b>&lt;addr&gt;</b> element, but any element can be used if it has the appropriate attributes</p>
<ul>
<li><em>space</em> indicates the address space of the tag</li>
<li><em>offset</em> indicates the offset within the space</li>
</ul>
<p>or a <em>name</em> attribute can be used to recover an address based on a register name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decoder</td><td>is the stream decoder </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </dd></dl>

<p>References <a class="el" href="classAddress.html#a69a01db36be374e934ed33c773e31b7f">Address()</a>, <a class="el" href="structVarnodeData.html#ad49ee972626e66aab1748a35f0b65a32">VarnodeData::decode()</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>.</p>

<p>Referenced by <a class="el" href="classSeqNum.html#aadb2fd8dadd48274d5f36d78d9dc96de">SeqNum::decode()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8f596516a325482bf9f8d6af9cd32ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> Address::decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDecoder.html">Decoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore an address and size from parsed XML. </p>
<p>This is usually used to decode an address from an <b>&lt;addr&gt;</b> element, but any element can be used if it has the appropriate attributes</p>
<ul>
<li><em>space</em> indicates the address space of the tag</li>
<li><em>offset</em> indicates the offset within the space</li>
<li><em>size</em> indicates the size of an address range</li>
</ul>
<p>or a <em>name</em> attribute can be used to recover an address and size based on a register name. If a size is recovered it is stored in <em>size</em> reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decoder</td><td>is the stream decoder </td></tr>
    <tr><td class="paramname">size</td><td>is the reference to any recovered size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> </dd></dl>

<p>References <a class="el" href="classAddress.html#a69a01db36be374e934ed33c773e31b7f">Address()</a>, <a class="el" href="structVarnodeData.html#ad49ee972626e66aab1748a35f0b65a32">VarnodeData::decode()</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="structVarnodeData.html#a50d39ae46d51c8854b962f3ec4ee4e25">VarnodeData::size</a>, and <a class="el" href="structVarnodeData.html#a1a69a5187f7a6376c0c93c08962ea68d">VarnodeData::space</a>.</p>

</div>
</div>
<a class="anchor" id="afcb62651d149f28317aa0af35830a739"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Address::encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEncoder.html">Encoder</a> &amp;&#160;</td>
          <td class="paramname"><em>encoder</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode <b>this</b> to a stream. </p>
<p>Save an &lt;addr&gt; element corresponding to this address to a stream. The exact format is determined by the address space, but this generally has a <em>space</em> and an <em>offset</em> attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>is the stream encoder </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classEncoder.html#abda45c0bc71d8f693a50edb545ecfe89">Encoder::closeElement()</a>, <a class="el" href="classAddrSpace.html#a2c407cfabac453b763b59d14cdec74de">AddrSpace::encodeAttributes()</a>, <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>, and <a class="el" href="classEncoder.html#a3848582b94dc98752f6180e0621c3c77">Encoder::openElement()</a>.</p>

</div>
</div>
<a class="anchor" id="afbab61be30fc265c60b8336a57b81e6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Address::encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEncoder.html">Encoder</a> &amp;&#160;</td>
          <td class="paramname"><em>encoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode <b>this</b> and a size to a stream. </p>
<p>Encode an &lt;addr&gt; element corresponding to this address to a stream. The tag will also include an extra <em>size</em> attribute so that it can describe an entire memory range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>is the stream encoder </td></tr>
    <tr><td class="paramname">size</td><td>is the number of bytes in the range </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classEncoder.html#abda45c0bc71d8f693a50edb545ecfe89">Encoder::closeElement()</a>, <a class="el" href="classAddrSpace.html#a2c407cfabac453b763b59d14cdec74de">AddrSpace::encodeAttributes()</a>, <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>, and <a class="el" href="classEncoder.html#a3848582b94dc98752f6180e0621c3c77">Encoder::openElement()</a>.</p>

</div>
</div>
<a class="anchor" id="a45e9717c199593d3446eae0328499e43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 Address::getAddrSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bytes in the address. </p>
<p>Get the number of bytes needed to encode the <em>offset</em> for this address. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes in the encoding </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, and <a class="el" href="classAddrSpace.html#ac0cfccb152e2d1f13cbb70e253cf69bf">AddrSpace::getAddrSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a90e9bc454f258c51c1ddccc336922a8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb Address::getOffset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the address offset. </p>
<p>Get the offset of the address as an integer. </p>
<dl class="section return"><dt>Returns</dt><dd>the offset integer </dd></dl>

<p>References <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#aed824a71a1d12bb5d167a7a488eb7198">AddrSpaceManager::constructFloatExtensionAddress()</a>, <a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">AddrSpaceManager::constructJoinAddress()</a>, <a class="el" href="classRange.html#a7665541629fc870ed7706f667b0dd160">Range::contains()</a>, <a class="el" href="classSeqNum.html#a95d4b48e1869c8b7ee7fcd7d07d9df57">SeqNum::encode()</a>, <a class="el" href="classContextInternal.html#aa6c2913e6b71ccc005c5914fd6664627">ContextInternal::encodeContext()</a>, <a class="el" href="classContextDatabase.html#aad4f93f4dacd48b7ccb2e5c378d4d15c">ContextDatabase::encodeTracked()</a>, <a class="el" href="classEmulatePcodeCache.html#a6108efef1c0291ca887228781e4c1238">EmulatePcodeCache::executeBranch()</a>, <a class="el" href="classContextInternal.html#ab49e9b4c05c997a393100f11f9d8f028">ContextInternal::getContext()</a>, <a class="el" href="classContextCache.html#a8f862cb06ea57502b1bb3b15f88fb0bc">ContextCache::getContext()</a>, <a class="el" href="classDisassemblyCache.html#afab4ffc5dc52eb4cc6da82e13a1d5107">DisassemblyCache::getParserContext()</a>, <a class="el" href="classRangeList.html#a83ace846d1d6faedd894e5756e1f7cf8">RangeList::inRange()</a>, <a class="el" href="classRawLoadImage.html#ac66523f8d5e0533f4af6ee7bd48741cc">RawLoadImage::loadFill()</a>, <a class="el" href="classRangeList.html#a232b03aa522a412ea6ac9e4936e7c63b">RangeList::longestFit()</a>, <a class="el" href="classSleigh.html#a7057d33c217ca1a7dbbdfcbde0fe1314">Sleigh::oneInstruction()</a>, <a class="el" href="classAddrSpaceManager.html#a68cf42a54806161d8bf3c1fa283036dd">AddrSpaceManager::renormalizeJoinAddress()</a>, <a class="el" href="classContextCache.html#ac9f411a6a52bed3b3e59607371766c8b">ContextCache::setContext()</a>, and <a class="el" href="classSleighBuilder.html#a6b5d7721e7da9dcc115e19e38af88499">SleighBuilder::setUniqueOffset()</a>.</p>

</div>
</div>
<a class="anchor" id="af0f2d71168775f819e4e482c2e13c1b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char Address::getShortcut </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the shortcut character for the address space. </p>
<p>Each address has a shortcut character associated with it for use with the read and printRaw methods. </p>
<dl class="section return"><dt>Returns</dt><dd>the shortcut char </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, and <a class="el" href="classAddrSpace.html#a10c33b5d21f18a7a06b2d5e083f786c8">AddrSpace::getShortcut()</a>.</p>

<p>Referenced by <a class="el" href="classRawLoadImage.html#ac66523f8d5e0533f4af6ee7bd48741cc">RawLoadImage::loadFill()</a>.</p>

</div>
</div>
<a class="anchor" id="acb7255960e441327e10b24442d44a2bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * Address::getSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the address space. </p>
<p>Get the address space associated with this address. </p>
<dl class="section return"><dt>Returns</dt><dd>the AddressSpace pointer, or <b>NULL</b> if invalid </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#aed824a71a1d12bb5d167a7a488eb7198">AddrSpaceManager::constructFloatExtensionAddress()</a>, <a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">AddrSpaceManager::constructJoinAddress()</a>, <a class="el" href="classRange.html#a7665541629fc870ed7706f667b0dd160">Range::contains()</a>, <a class="el" href="classSeqNum.html#a95d4b48e1869c8b7ee7fcd7d07d9df57">SeqNum::encode()</a>, <a class="el" href="classContextInternal.html#aa6c2913e6b71ccc005c5914fd6664627">ContextInternal::encodeContext()</a>, <a class="el" href="classContextDatabase.html#aad4f93f4dacd48b7ccb2e5c378d4d15c">ContextDatabase::encodeTracked()</a>, <a class="el" href="classEmulateMemory.html#a64cee14cda2a10ed440fe171b8fdbcc0">EmulateMemory::executeBranchind()</a>, <a class="el" href="classEmulateMemory.html#af1c25ebc29e2e57ab762d878ac8103e4">EmulateMemory::executeCallind()</a>, <a class="el" href="classContextInternal.html#ab49e9b4c05c997a393100f11f9d8f028">ContextInternal::getContext()</a>, <a class="el" href="classContextCache.html#a8f862cb06ea57502b1bb3b15f88fb0bc">ContextCache::getContext()</a>, <a class="el" href="classRangeList.html#a83ace846d1d6faedd894e5756e1f7cf8">RangeList::inRange()</a>, <a class="el" href="classRangeList.html#a232b03aa522a412ea6ac9e4936e7c63b">RangeList::longestFit()</a>, and <a class="el" href="classContextCache.html#ac9f411a6a52bed3b3e59607371766c8b">ContextCache::setContext()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7209c4a9300045576cf400b7443981e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Address::isBigEndian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is data at this address big endian encoded. </p>
<p>Determine if data stored at this address is big endian encoded. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the address is big endian </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, and <a class="el" href="classAddrSpace.html#aee713265281a230a8d25ea84328c37de">AddrSpace::isBigEndian()</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">AddrSpaceManager::constructJoinAddress()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b132480ba80a42ba433f52b00164f91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Address::isConstant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a <em>constant</em> <em>value</em>. </p>
<p>Determine if this address is from the <em>constant</em> <em>space</em>. All constant values are represented as an offset into the <em>constant</em> <em>space</em>. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if this address represents a constant </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, and <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a3ae8eb421cb8d460bc939657402d970a">IPTR_CONSTANT</a>.</p>

</div>
</div>
<a class="anchor" id="a7de8fd2dd0029f985341ec5bb3530008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Address::isContiguous </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>loaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>losz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does <em>this</em> form a contigous range with <em>loaddr</em>. </p>
<p>Does the location <em>this</em>, <em>sz</em> form a contiguous region to <em>loaddr</em>, <em>losz</em>, where <em>this</em> forms the most significant piece of the logical whole </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>is the size of <em>this</em> hi region </td></tr>
    <tr><td class="paramname">loaddr</td><td>is the starting address of the low region </td></tr>
    <tr><td class="paramname">losz</td><td>is the size of the low region </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the pieces form a contiguous whole </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddrSpace.html#aee713265281a230a8d25ea84328c37de">AddrSpace::isBigEndian()</a>, <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>, and <a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">AddrSpace::wrapOffset()</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">AddrSpaceManager::constructJoinAddress()</a>.</p>

</div>
</div>
<a class="anchor" id="a36631134a5ad2883696d26300e4894b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Address::isInvalid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the address invalid? </p>
<p>Determine if this is an invalid address. This only detects <em>deliberate</em> invalid addresses. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the address is invalid </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>.</p>

<p>Referenced by <a class="el" href="classContextInternal.html#aaad693556b2167c3c005b12f930b9a5a">ContextInternal::decodeContext()</a>, <a class="el" href="classContextInternal.html#acae33e5c7dee94becd253bc5e071eddc">ContextInternal::getRegionForSet()</a>, <a class="el" href="classRangeList.html#a83ace846d1d6faedd894e5756e1f7cf8">RangeList::inRange()</a>, <a class="el" href="classRangeList.html#a232b03aa522a412ea6ac9e4936e7c63b">RangeList::longestFit()</a>, and <a class="el" href="classAddrSpaceManager.html#a68cf42a54806161d8bf3c1fa283036dd">AddrSpaceManager::renormalizeJoinAddress()</a>.</p>

</div>
</div>
<a class="anchor" id="af320224a1a004a7bc94d2fa8ac474835"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Address::isJoin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a <em>join</em> <em>value</em>. </p>
<p>Determine if this address represents a set of joined memory locations. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if this address represents a join </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, and <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a67805851c12bd1477c2a748e53e45f9c">IPTR_JOIN</a>.</p>

</div>
</div>
<a class="anchor" id="a87bb3dfe1bd894305f137aac061c8707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 Address::justifiedContain </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>sz2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceleft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if <em>op2</em> is the least significant part of <em>this</em>. </p>
<p>Return -1 if (<em>op2</em>,<em>sz2</em>) is not properly contained in (<em>this</em>,<em>sz</em>). If it is contained, return the endian aware offset of (<em>op2</em>,<em>sz2</em>) I.e. if the least significant byte of the <em>op2</em> range falls on the least significant byte of the <em>this</em> range, return 0. If it intersects the second least significant, return 1, etc. The -forceleft- toggle causes the check to be made against the left (lowest address) side of the container, regardless of the endianness. I.e. it forces a little endian interpretation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>is the size of <em>this</em> range </td></tr>
    <tr><td class="paramname">op2</td><td>is the address of the second range </td></tr>
    <tr><td class="paramname">sz2</td><td>is the size of the second range </td></tr>
    <tr><td class="paramname">forceleft</td><td>is <b>true</b> if containments is forced to be on the left even for big endian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the endian aware offset, or -1 </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddrSpace.html#aee713265281a230a8d25ea84328c37de">AddrSpace::isBigEndian()</a>, and <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>.</p>

</div>
</div>
<a class="anchor" id="a05ef47cee744c1a30a5603b5a35bb058"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Address::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two addresses for inequality. </p>
<p>Check if two addresses are not equal. I.e. if either their address space or offset are different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the address to compare to <em>this</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the addresses are different </dd></dl>

</div>
</div>
<a class="anchor" id="a2a440c026e09b7ec2d2cb361301c6164"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> Address::operator+ </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>off</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment address by a number of bytes. </p>
<p>Add an integer value to the offset portion of the address. The addition takes into account the <em>size</em> of the address space, and the <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> will wrap around if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>is the number to add to the offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new incremented address </dd></dl>

<p>References <a class="el" href="classAddress.html#a69a01db36be374e934ed33c773e31b7f">Address()</a>, <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>, and <a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">AddrSpace::wrapOffset()</a>.</p>

</div>
</div>
<a class="anchor" id="a239158df52ba68f63d5d697b17067743"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> Address::operator- </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>off</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrement address by a number of bytes. </p>
<p>Subtract an integer value from the offset portion of the address. The subtraction takes into account the <em>size</em> of the address space, and the <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> will wrap around if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>is the number to subtract from the offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new decremented address </dd></dl>

<p>References <a class="el" href="classAddress.html#a69a01db36be374e934ed33c773e31b7f">Address()</a>, <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>, and <a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">AddrSpace::wrapOffset()</a>.</p>

</div>
</div>
<a class="anchor" id="af07d3060bdc07d9b25cea7c561e6ef81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Address::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two addresses via their natural ordering. </p>
<p>Do an ordering comparison of two addresses. Addresses are sorted first on space, then on offset. So two addresses in the same space compare naturally based on their offset, but addresses in different spaces also compare. Different spaces are ordered by their index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the address to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <em>this</em> comes before <em>op2</em> </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddrSpace.html#aa6053f6a9a768acc129311f367318a9d">AddrSpace::getIndex()</a>, and <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>.</p>

</div>
</div>
<a class="anchor" id="a4ae71cfe5906858be8c34d8b2cce18fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Address::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two addresses via their natural ordering. </p>
<p>Do an ordering comparison of two addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the address to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if <em>this</em> comes before or is equal to <em>op2</em> </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddrSpace.html#aa6053f6a9a768acc129311f367318a9d">AddrSpace::getIndex()</a>, and <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>.</p>

</div>
</div>
<a class="anchor" id="a942aba71799e61225a20135d3dc86453"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddress.html">Address</a> &amp; Address::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an address. </p>
<p>This is a standard assignment operator, copying the address space pointer and the offset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> being assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to altered address </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, and <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>.</p>

</div>
</div>
<a class="anchor" id="abfb86b64921c6989b56be7f7804dddec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Address::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>op2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two addresses for equality. </p>
<p>Check if two addresses are equal. I.e. if their address space and offset are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op2</td><td>is the address to compare to <em>this</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the addresses are the same </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, and <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>.</p>

</div>
</div>
<a class="anchor" id="a14bcd73e2401a3416abd1ee02b0bd2f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int4 Address::overlap </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine how two address ranges overlap. </p>
<p>If <em>this</em> + <em>skip</em> falls in the range <em>op</em> to <em>op</em> + <em>size</em>, then a non-negative integer is returned indicating where in the interval it falls. I.e. if <em>this</em> + <em>skip</em> == <em>op</em>, then 0 is returned. Otherwise -1 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skip</td><td>is an adjust to <em>this</em> address </td></tr>
    <tr><td class="paramname">op</td><td>is the start of the range to check </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer indicating how overlap occurs </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a3ae8eb421cb8d460bc939657402d970a">IPTR_CONSTANT</a>, <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>, and <a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">AddrSpace::wrapOffset()</a>.</p>

</div>
</div>
<a class="anchor" id="a040ac0edbb01bd26c8956130ec4ef20e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Address::printRaw </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a raw version of the address to a stream. </p>
<p>Write a short-hand or debug version of this address to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the stream being written </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>, and <a class="el" href="classAddrSpace.html#a0a28ec850803f89be4db6c85669573cc">AddrSpace::printRaw()</a>.</p>

<p>Referenced by <a class="el" href="classRawLoadImage.html#ac66523f8d5e0533f4af6ee7bd48741cc">RawLoadImage::loadFill()</a>.</p>

</div>
</div>
<a class="anchor" id="a10953bd3fe65b279ee102a69d43e2d27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 Address::read </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read in the address from a string. </p>
<p>Convert a string into an address. The string format can be tailored for the particular address space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the string to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>any size associated with the parsed string </dd></dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddress.html#adbb9f0a40c81e28e83eca5a9de2959a8">offset</a>, and <a class="el" href="classAddrSpace.html#a2a7fb8caa90194445f8e70d2e88557e6">AddrSpace::read()</a>.</p>

</div>
</div>
<a class="anchor" id="a079f391c59a43a0e0fb8a5c66eaf6f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Address::renormalize </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make sure there is a backing <a class="el" href="classJoinRecord.html" title="A record describing how logical values are split. ">JoinRecord</a> if <b>this</b> is in the <em>join</em> space. </p>
<p>If <b>this</b> is (originally) a <em>join</em> address, reevaluate it in terms of its new <em>offset</em> and <em>siz</em>, changing the space and offset if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>is the new size in bytes of the underlying object </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddress.html#ac08d67074731b83664127bb0cc190bfe">base</a>, <a class="el" href="classAddrSpace.html#aa5502574575723e9af7ad3d3b8844fdf">AddrSpace::getManager()</a>, <a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">AddrSpace::getType()</a>, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231a67805851c12bd1477c2a748e53e45f9c">IPTR_JOIN</a>, and <a class="el" href="classAddrSpaceManager.html#a68cf42a54806161d8bf3c1fa283036dd">AddrSpaceManager::renormalizeJoinAddress()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aad61b7eee4f2506349c6a517a1271faa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddress.html">Address</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write out an address to stream. </p>
<p>This allows an <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> to be written to a stream using the standard '&lt;&lt;' operator. This is a wrapper for the printRaw method and is intended for debugging and console mode uses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the stream being written to </td></tr>
    <tr><td class="paramname">addr</td><td>is the <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="address_8hh.html">address.hh</a></li>
<li>address.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
