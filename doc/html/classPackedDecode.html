<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>decompiler: PackedDecode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classPackedDecode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PackedDecode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A byte-based decoder designed to marshal info to the decompiler efficiently.  
 <a href="classPackedDecode.html#details">More...</a></p>

<p><code>#include &lt;marshal.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PackedDecode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPackedDecode.png" usemap="#PackedDecode_map" alt=""/>
  <map id="PackedDecode_map" name="PackedDecode_map">
<area href="classDecoder.html" title="A class for reading structured data from a stream. " alt="Decoder" shape="rect" coords="0,0,98,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode_1_1ByteChunk.html">ByteChunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bounded array of bytes.  <a href="classPackedDecode_1_1ByteChunk.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode_1_1Position.html">Position</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator into input stream.  <a href="classPackedDecode_1_1Position.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5d7484a8369e9143506a3935aa828db4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d7484a8369e9143506a3935aa828db4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a5d7484a8369e9143506a3935aa828db4">PackedDecode</a> (const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *<a class="el" href="classDecoder.html#a1710afd881dc823cd5920692685c47af">spcManager</a>)</td></tr>
<tr class="memdesc:a5d7484a8369e9143506a3935aa828db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:a5d7484a8369e9143506a3935aa828db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcb78a9e069071bd9a23c70c995284a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#acfcb78a9e069071bd9a23c70c995284a">ingestStream</a> (istream &amp;s)</td></tr>
<tr class="memdesc:acfcb78a9e069071bd9a23c70c995284a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare to decode a given stream.  <a href="#acfcb78a9e069071bd9a23c70c995284a">More...</a><br/></td></tr>
<tr class="separator:acfcb78a9e069071bd9a23c70c995284a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919a4c874a926b3d1a74e68c8dde86e1"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a919a4c874a926b3d1a74e68c8dde86e1">peekElement</a> (void)</td></tr>
<tr class="memdesc:a919a4c874a926b3d1a74e68c8dde86e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next child element of the current parent, without traversing in (opening) it.  <a href="#a919a4c874a926b3d1a74e68c8dde86e1">More...</a><br/></td></tr>
<tr class="separator:a919a4c874a926b3d1a74e68c8dde86e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f902925e06098a3c437dc099732fe7"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a90f902925e06098a3c437dc099732fe7">openElement</a> (void)</td></tr>
<tr class="memdesc:a90f902925e06098a3c437dc099732fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open (traverse into) the next child element of the current parent.  <a href="#a90f902925e06098a3c437dc099732fe7">More...</a><br/></td></tr>
<tr class="separator:a90f902925e06098a3c437dc099732fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b571789fcf41713b8bd7d8e8041a2ff"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a8b571789fcf41713b8bd7d8e8041a2ff">openElement</a> (const <a class="el" href="classElementId.html">ElementId</a> &amp;elemId)</td></tr>
<tr class="memdesc:a8b571789fcf41713b8bd7d8e8041a2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open (traverse into) the next child element, which must be of a specific type.  <a href="#a8b571789fcf41713b8bd7d8e8041a2ff">More...</a><br/></td></tr>
<tr class="separator:a8b571789fcf41713b8bd7d8e8041a2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072589c17be02ccbdeffacae41e39095"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a072589c17be02ccbdeffacae41e39095">closeElement</a> (uint4 id)</td></tr>
<tr class="memdesc:a072589c17be02ccbdeffacae41e39095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the current element.  <a href="#a072589c17be02ccbdeffacae41e39095">More...</a><br/></td></tr>
<tr class="separator:a072589c17be02ccbdeffacae41e39095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af881a670a80b2fe553e073c2cde11060"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#af881a670a80b2fe553e073c2cde11060">closeElementSkipping</a> (uint4 id)</td></tr>
<tr class="memdesc:af881a670a80b2fe553e073c2cde11060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the current element, skipping any child elements that have not yet been parsed.  <a href="#af881a670a80b2fe553e073c2cde11060">More...</a><br/></td></tr>
<tr class="separator:af881a670a80b2fe553e073c2cde11060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e28399b23ef28d6d07ae93dcceeb6df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a0e28399b23ef28d6d07ae93dcceeb6df">rewindAttributes</a> (void)</td></tr>
<tr class="memdesc:a0e28399b23ef28d6d07ae93dcceeb6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset attribute traversal for the current element.  <a href="#a0e28399b23ef28d6d07ae93dcceeb6df">More...</a><br/></td></tr>
<tr class="separator:a0e28399b23ef28d6d07ae93dcceeb6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c87996b51a654de0dcce6da2dc6f094"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a5c87996b51a654de0dcce6da2dc6f094">getNextAttributeId</a> (void)</td></tr>
<tr class="memdesc:a5c87996b51a654de0dcce6da2dc6f094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next attribute id for the current element.  <a href="#a5c87996b51a654de0dcce6da2dc6f094">More...</a><br/></td></tr>
<tr class="separator:a5c87996b51a654de0dcce6da2dc6f094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af7102b4a55e29e26a0da50f33d99b0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a7af7102b4a55e29e26a0da50f33d99b0">readBool</a> (void)</td></tr>
<tr class="memdesc:a7af7102b4a55e29e26a0da50f33d99b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as a boolean value.  <a href="#a7af7102b4a55e29e26a0da50f33d99b0">More...</a><br/></td></tr>
<tr class="separator:a7af7102b4a55e29e26a0da50f33d99b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03c6ebf3f561e5353ee1319fdc4162a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#ab03c6ebf3f561e5353ee1319fdc4162a">readBool</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)</td></tr>
<tr class="memdesc:ab03c6ebf3f561e5353ee1319fdc4162a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as a boolean value.  <a href="#ab03c6ebf3f561e5353ee1319fdc4162a">More...</a><br/></td></tr>
<tr class="separator:ab03c6ebf3f561e5353ee1319fdc4162a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348412434319f578505367b0ff225dcc"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a348412434319f578505367b0ff225dcc">readSignedInteger</a> (void)</td></tr>
<tr class="memdesc:a348412434319f578505367b0ff225dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as a signed integer value.  <a href="#a348412434319f578505367b0ff225dcc">More...</a><br/></td></tr>
<tr class="separator:a348412434319f578505367b0ff225dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2eb1984afead4ee24cf9b70ce3b2ba"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#ade2eb1984afead4ee24cf9b70ce3b2ba">readSignedInteger</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)</td></tr>
<tr class="memdesc:ade2eb1984afead4ee24cf9b70ce3b2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as a signed integer.  <a href="#ade2eb1984afead4ee24cf9b70ce3b2ba">More...</a><br/></td></tr>
<tr class="separator:ade2eb1984afead4ee24cf9b70ce3b2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed06cb62e12a3fbeecf2756ef1c6590"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a2ed06cb62e12a3fbeecf2756ef1c6590">readSignedIntegerExpectString</a> (const string &amp;expect, intb expectval)</td></tr>
<tr class="memdesc:a2ed06cb62e12a3fbeecf2756ef1c6590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as either a signed integer value or a string.  <a href="#a2ed06cb62e12a3fbeecf2756ef1c6590">More...</a><br/></td></tr>
<tr class="separator:a2ed06cb62e12a3fbeecf2756ef1c6590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a08bead1c9dfab1e86a8d20ed10c26"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#ae4a08bead1c9dfab1e86a8d20ed10c26">readSignedIntegerExpectString</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId, const string &amp;expect, intb expectval)</td></tr>
<tr class="memdesc:ae4a08bead1c9dfab1e86a8d20ed10c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as either a signed integer or a string.  <a href="#ae4a08bead1c9dfab1e86a8d20ed10c26">More...</a><br/></td></tr>
<tr class="separator:ae4a08bead1c9dfab1e86a8d20ed10c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ca75cfef14da4da656b45bbb3b2277"><td class="memItemLeft" align="right" valign="top">virtual uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a54ca75cfef14da4da656b45bbb3b2277">readUnsignedInteger</a> (void)</td></tr>
<tr class="memdesc:a54ca75cfef14da4da656b45bbb3b2277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as an unsigned integer value.  <a href="#a54ca75cfef14da4da656b45bbb3b2277">More...</a><br/></td></tr>
<tr class="separator:a54ca75cfef14da4da656b45bbb3b2277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252d98ec98bf2ee2697b051f7fdc5875"><td class="memItemLeft" align="right" valign="top">virtual uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a252d98ec98bf2ee2697b051f7fdc5875">readUnsignedInteger</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)</td></tr>
<tr class="memdesc:a252d98ec98bf2ee2697b051f7fdc5875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as an unsigned integer.  <a href="#a252d98ec98bf2ee2697b051f7fdc5875">More...</a><br/></td></tr>
<tr class="separator:a252d98ec98bf2ee2697b051f7fdc5875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cb2804b7762e2419ef28317a298ef5"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a75cb2804b7762e2419ef28317a298ef5">readString</a> (void)</td></tr>
<tr class="memdesc:a75cb2804b7762e2419ef28317a298ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as a string.  <a href="#a75cb2804b7762e2419ef28317a298ef5">More...</a><br/></td></tr>
<tr class="separator:a75cb2804b7762e2419ef28317a298ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3e35a8ae3d45c6108480a5204442e0"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a7a3e35a8ae3d45c6108480a5204442e0">readString</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)</td></tr>
<tr class="memdesc:a7a3e35a8ae3d45c6108480a5204442e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the specific attribute in the current element and return it as a string.  <a href="#a7a3e35a8ae3d45c6108480a5204442e0">More...</a><br/></td></tr>
<tr class="separator:a7a3e35a8ae3d45c6108480a5204442e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba3d18f2a01441d0a0df619df46066e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#abba3d18f2a01441d0a0df619df46066e">readSpace</a> (void)</td></tr>
<tr class="memdesc:abba3d18f2a01441d0a0df619df46066e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as an address space.  <a href="#abba3d18f2a01441d0a0df619df46066e">More...</a><br/></td></tr>
<tr class="separator:abba3d18f2a01441d0a0df619df46066e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc8290dd84387e11f78059768cf7402"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#aadc8290dd84387e11f78059768cf7402">readSpace</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)</td></tr>
<tr class="memdesc:aadc8290dd84387e11f78059768cf7402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the specific attribute in the current element and return it as an address space.  <a href="#aadc8290dd84387e11f78059768cf7402">More...</a><br/></td></tr>
<tr class="separator:aadc8290dd84387e11f78059768cf7402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classDecoder"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classDecoder')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classDecoder.html">Decoder</a></td></tr>
<tr class="memitem:ad742ab5418158e242bd8105561231143 inherit pub_methods_classDecoder"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad742ab5418158e242bd8105561231143"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#ad742ab5418158e242bd8105561231143">Decoder</a> (const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *spc)</td></tr>
<tr class="memdesc:ad742ab5418158e242bd8105561231143 inherit pub_methods_classDecoder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base constructor. <br/></td></tr>
<tr class="separator:ad742ab5418158e242bd8105561231143 inherit pub_methods_classDecoder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e1c337c5263c056415259df22bc284 inherit pub_methods_classDecoder"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7e1c337c5263c056415259df22bc284"></a>
const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#af7e1c337c5263c056415259df22bc284">getAddrSpaceManager</a> (void) const </td></tr>
<tr class="memdesc:af7e1c337c5263c056415259df22bc284 inherit pub_methods_classDecoder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the manager used for address space decoding. <br/></td></tr>
<tr class="separator:af7e1c337c5263c056415259df22bc284 inherit pub_methods_classDecoder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018cda43f7451dab35dfc6a4f262df46 inherit pub_methods_classDecoder"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a018cda43f7451dab35dfc6a4f262df46"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a018cda43f7451dab35dfc6a4f262df46">~Decoder</a> (void)</td></tr>
<tr class="memdesc:a018cda43f7451dab35dfc6a4f262df46 inherit pub_methods_classDecoder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a018cda43f7451dab35dfc6a4f262df46 inherit pub_methods_classDecoder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bc3e4fc9f888c1ee13b50afaa23103 inherit pub_methods_classDecoder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#ad7bc3e4fc9f888c1ee13b50afaa23103">skipElement</a> (void)</td></tr>
<tr class="memdesc:ad7bc3e4fc9f888c1ee13b50afaa23103 inherit pub_methods_classDecoder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip parsing of the next element.  <a href="#ad7bc3e4fc9f888c1ee13b50afaa23103">More...</a><br/></td></tr>
<tr class="separator:ad7bc3e4fc9f888c1ee13b50afaa23103 inherit pub_methods_classDecoder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae6f052ee830d29a8ba5a7a3468e05141"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6f052ee830d29a8ba5a7a3468e05141"></a>
static const int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#ae6f052ee830d29a8ba5a7a3468e05141">BUFFER_SIZE</a> = 1024</td></tr>
<tr class="memdesc:ae6f052ee830d29a8ba5a7a3468e05141"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size, in bytes, of a single cached chunk of the input stream. <br/></td></tr>
<tr class="separator:ae6f052ee830d29a8ba5a7a3468e05141"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a994c4e7ea0c48e3bd11cce2aebf02d40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a994c4e7ea0c48e3bd11cce2aebf02d40"></a>
uint1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a994c4e7ea0c48e3bd11cce2aebf02d40">getByte</a> (<a class="el" href="classPackedDecode_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="memdesc:a994c4e7ea0c48e3bd11cce2aebf02d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte at the current position, do not advance. <br/></td></tr>
<tr class="separator:a994c4e7ea0c48e3bd11cce2aebf02d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0386069ddf07d1ad0c0b32327c88df73"><td class="memItemLeft" align="right" valign="top">uint1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a0386069ddf07d1ad0c0b32327c88df73">getBytePlus1</a> (<a class="el" href="classPackedDecode_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="memdesc:a0386069ddf07d1ad0c0b32327c88df73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte following the current byte, do not advance position.  <a href="#a0386069ddf07d1ad0c0b32327c88df73">More...</a><br/></td></tr>
<tr class="separator:a0386069ddf07d1ad0c0b32327c88df73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529b0a3f0049f1d1d131665db962402a"><td class="memItemLeft" align="right" valign="top">uint1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a529b0a3f0049f1d1d131665db962402a">getNextByte</a> (<a class="el" href="classPackedDecode_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="memdesc:a529b0a3f0049f1d1d131665db962402a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the byte at the current position and advance to the next byte.  <a href="#a529b0a3f0049f1d1d131665db962402a">More...</a><br/></td></tr>
<tr class="separator:a529b0a3f0049f1d1d131665db962402a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81268540b92cd90d1fc8f5692b56733"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#af81268540b92cd90d1fc8f5692b56733">advancePosition</a> (<a class="el" href="classPackedDecode_1_1Position.html">Position</a> &amp;pos, int4 skip)</td></tr>
<tr class="memdesc:af81268540b92cd90d1fc8f5692b56733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the position by the given number of bytes.  <a href="#af81268540b92cd90d1fc8f5692b56733">More...</a><br/></td></tr>
<tr class="separator:af81268540b92cd90d1fc8f5692b56733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969ed204ac0d1fc43acf0f3065aa91de"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a969ed204ac0d1fc43acf0f3065aa91de">readInteger</a> (int4 len)</td></tr>
<tr class="memdesc:a969ed204ac0d1fc43acf0f3065aa91de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an integer from the <em>current</em> position given its length in bytes.  <a href="#a969ed204ac0d1fc43acf0f3065aa91de">More...</a><br/></td></tr>
<tr class="separator:a969ed204ac0d1fc43acf0f3065aa91de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe22f2c07966f0764aa6e19ebac42628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe22f2c07966f0764aa6e19ebac42628"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#afe22f2c07966f0764aa6e19ebac42628">readLengthCode</a> (uint1 typeByte)</td></tr>
<tr class="memdesc:afe22f2c07966f0764aa6e19ebac42628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract length code from type byte. <br/></td></tr>
<tr class="separator:afe22f2c07966f0764aa6e19ebac42628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94262d97ca5a372ad4762b7ea505d5ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a94262d97ca5a372ad4762b7ea505d5ea">findMatchingAttribute</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)</td></tr>
<tr class="memdesc:a94262d97ca5a372ad4762b7ea505d5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find attribute matching the given id in open element.  <a href="#a94262d97ca5a372ad4762b7ea505d5ea">More...</a><br/></td></tr>
<tr class="separator:a94262d97ca5a372ad4762b7ea505d5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2dfb8c337fd8cf0f6e1f09354921f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#afe2dfb8c337fd8cf0f6e1f09354921f4">skipAttribute</a> (void)</td></tr>
<tr class="memdesc:afe2dfb8c337fd8cf0f6e1f09354921f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip over the attribute at the current position.  <a href="#afe2dfb8c337fd8cf0f6e1f09354921f4">More...</a><br/></td></tr>
<tr class="separator:afe2dfb8c337fd8cf0f6e1f09354921f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e43226695d5aced40bccfe69e057906"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#a8e43226695d5aced40bccfe69e057906">skipAttributeRemaining</a> (uint1 typeByte)</td></tr>
<tr class="memdesc:a8e43226695d5aced40bccfe69e057906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip over remaining attribute data, after a mismatch.  <a href="#a8e43226695d5aced40bccfe69e057906">More...</a><br/></td></tr>
<tr class="separator:a8e43226695d5aced40bccfe69e057906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aae80d33cf573d02948e7ce34548a664f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae80d33cf573d02948e7ce34548a664f"></a>
list&lt; <a class="el" href="classPackedDecode_1_1ByteChunk.html">ByteChunk</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#aae80d33cf573d02948e7ce34548a664f">inStream</a></td></tr>
<tr class="memdesc:aae80d33cf573d02948e7ce34548a664f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incoming raw data as a sequence of byte arrays. <br/></td></tr>
<tr class="separator:aae80d33cf573d02948e7ce34548a664f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdf21a6fee1b35ec613481337373733"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcdf21a6fee1b35ec613481337373733"></a>
<a class="el" href="classPackedDecode_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#abcdf21a6fee1b35ec613481337373733">startPos</a></td></tr>
<tr class="memdesc:abcdf21a6fee1b35ec613481337373733"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPackedDecode_1_1Position.html" title="An iterator into input stream. ">Position</a> at the start of the current open element. <br/></td></tr>
<tr class="separator:abcdf21a6fee1b35ec613481337373733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92cde45342ead75e2106a1162c4b244"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad92cde45342ead75e2106a1162c4b244"></a>
<a class="el" href="classPackedDecode_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#ad92cde45342ead75e2106a1162c4b244">curPos</a></td></tr>
<tr class="memdesc:ad92cde45342ead75e2106a1162c4b244"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPackedDecode_1_1Position.html" title="An iterator into input stream. ">Position</a> of the next attribute as returned by getNextAttributeId. <br/></td></tr>
<tr class="separator:ad92cde45342ead75e2106a1162c4b244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af919b81ebbe26a9f71ae6216d3a00e2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af919b81ebbe26a9f71ae6216d3a00e2d"></a>
<a class="el" href="classPackedDecode_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#af919b81ebbe26a9f71ae6216d3a00e2d">endPos</a></td></tr>
<tr class="memdesc:af919b81ebbe26a9f71ae6216d3a00e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ending position after all attributes in current open element. <br/></td></tr>
<tr class="separator:af919b81ebbe26a9f71ae6216d3a00e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62b6a7c09edf01aae55e1dfb05ba27b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae62b6a7c09edf01aae55e1dfb05ba27b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackedDecode.html#ae62b6a7c09edf01aae55e1dfb05ba27b">attributeRead</a></td></tr>
<tr class="memdesc:ae62b6a7c09edf01aae55e1dfb05ba27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the last attribute returned by getNextAttributeId been read. <br/></td></tr>
<tr class="separator:ae62b6a7c09edf01aae55e1dfb05ba27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classDecoder"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classDecoder')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classDecoder.html">Decoder</a></td></tr>
<tr class="memitem:a1710afd881dc823cd5920692685c47af inherit pro_attribs_classDecoder"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1710afd881dc823cd5920692685c47af"></a>
const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a1710afd881dc823cd5920692685c47af">spcManager</a></td></tr>
<tr class="memdesc:a1710afd881dc823cd5920692685c47af inherit pro_attribs_classDecoder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager for decoding address space attributes. <br/></td></tr>
<tr class="separator:a1710afd881dc823cd5920692685c47af inherit pro_attribs_classDecoder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A byte-based decoder designed to marshal info to the decompiler efficiently. </p>
<p>The decoder expects an encoding as described in <a class="el" href="namespacePackedFormat.html" title="Protocol format for PackedEncode and PackedDecode classes. ">PackedFormat</a>. When ingested, the stream bytes are held in a sequence of arrays (<a class="el" href="classPackedDecode_1_1ByteChunk.html" title="A bounded array of bytes. ">ByteChunk</a>). During decoding, <b>this</b> object maintains a <a class="el" href="classPackedDecode_1_1Position.html" title="An iterator into input stream. ">Position</a> in the stream at the start and end of the current open element, and a <a class="el" href="classPackedDecode_1_1Position.html" title="An iterator into input stream. ">Position</a> of the next attribute to read to facilitate <a class="el" href="classPackedDecode.html#a5c87996b51a654de0dcce6da2dc6f094" title="Get the next attribute id for the current element. ">getNextAttributeId()</a> and associated read*() methods. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af81268540b92cd90d1fc8f5692b56733"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PackedDecode::advancePosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPackedDecode_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>skip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance the position by the given number of bytes. </p>
<p>An exception is thrown of position is advanced past the end of the stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>is the position being advanced </td></tr>
    <tr><td class="paramname">skip</td><td>is the number of bytes to advance </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classPackedDecode_1_1Position.html#a7559e9ae9924732044d5f864ab3fe029">PackedDecode::Position::current</a>, <a class="el" href="classPackedDecode_1_1Position.html#a0ccafe7c2db96652b2b848cac9256595">PackedDecode::Position::end</a>, <a class="el" href="classPackedDecode.html#aae80d33cf573d02948e7ce34548a664f">inStream</a>, and <a class="el" href="classPackedDecode_1_1Position.html#abdc2af7e645d94cf28a7531b8dbf2d63">PackedDecode::Position::seqIter</a>.</p>

</div>
</div>
<a class="anchor" id="a072589c17be02ccbdeffacae41e39095"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PackedDecode::closeElement </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the current element. </p>
<p>The data for the current element is considered fully processed. If the element has additional children, an exception is thrown. The stream must indicate the end of the element in some way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the id of the element to close (which must be the current element) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classDecoder.html#a1837b91ab3c9d2a7f5b2711fe0a86a97">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="af881a670a80b2fe553e073c2cde11060"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PackedDecode::closeElementSkipping </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the current element, skipping any child elements that have not yet been parsed. </p>
<p>This closes the given element, which must be current. If there are child elements that have not been parsed, this is not considered an error, and they are skipped over in the parse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the id of the element to close (which must be the current element) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classDecoder.html#a36a59712041e1dc3f7185440d665b3d3">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a94262d97ca5a372ad4762b7ea505d5ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PackedDecode::findMatchingAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find attribute matching the given id in open element. </p>
<p>The <em>current</em> position is reset to the start of the current open element. <a class="el" href="classAttributes.html" title="The attributes for a single XML element. ">Attributes</a> are scanned and skipped until the attribute matching the given id is found. The <em>current</em> position is set to the start of the matching attribute, in preparation for one of the read*() methods. If the id is not found an exception is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the attribute id to scan for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0386069ddf07d1ad0c0b32327c88df73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint1 PackedDecode::getBytePlus1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPackedDecode_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the byte following the current byte, do not advance position. </p>
<p>An exception is thrown if the position currently points to the last byte in the stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>is the position in the stream to look ahead from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next byte </dd></dl>

<p>References <a class="el" href="classPackedDecode_1_1Position.html#a7559e9ae9924732044d5f864ab3fe029">PackedDecode::Position::current</a>, <a class="el" href="classPackedDecode_1_1Position.html#a0ccafe7c2db96652b2b848cac9256595">PackedDecode::Position::end</a>, <a class="el" href="classPackedDecode.html#aae80d33cf573d02948e7ce34548a664f">inStream</a>, and <a class="el" href="classPackedDecode_1_1Position.html#abdc2af7e645d94cf28a7531b8dbf2d63">PackedDecode::Position::seqIter</a>.</p>

</div>
</div>
<a class="anchor" id="a5c87996b51a654de0dcce6da2dc6f094"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 PackedDecode::getNextAttributeId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next attribute id for the current element. </p>
<p><a class="el" href="classAttributes.html" title="The attributes for a single XML element. ">Attributes</a> are automatically set up for traversal using this method, when the element is opened. If all attributes have been traversed (or there are no attributes), 0 is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the id of the next attribute or 0 </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#ad98ca46e0ea39c4ce713d4b14bc44772">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a529b0a3f0049f1d1d131665db962402a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint1 PackedDecode::getNextByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPackedDecode_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the byte at the current position and advance to the next byte. </p>
<p>An exception is thrown if there are no additional bytes in the stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>is the position of the byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the byte at the current position </dd></dl>

<p>References <a class="el" href="classPackedDecode_1_1Position.html#a7559e9ae9924732044d5f864ab3fe029">PackedDecode::Position::current</a>, <a class="el" href="classPackedDecode_1_1Position.html#a0ccafe7c2db96652b2b848cac9256595">PackedDecode::Position::end</a>, <a class="el" href="classPackedDecode.html#aae80d33cf573d02948e7ce34548a664f">inStream</a>, and <a class="el" href="classPackedDecode_1_1Position.html#abdc2af7e645d94cf28a7531b8dbf2d63">PackedDecode::Position::seqIter</a>.</p>

</div>
</div>
<a class="anchor" id="acfcb78a9e069071bd9a23c70c995284a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PackedDecode::ingestStream </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare to decode a given stream. </p>
<p>Called once before any decoding. Currently this is assumed to make an internal copy of the stream data, i.e. the input stream is cleared before any decoding takes place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the given input stream to be decode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the stream was fully ingested </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a992d5adfdb5766ec56844e6d5c2d1457">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a90f902925e06098a3c437dc099732fe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 PackedDecode::openElement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open (traverse into) the next child element of the current parent. </p>
<p>The child becomes the current parent. The list of attributes is initialized for use with getNextAttributeId. </p>
<dl class="section return"><dt>Returns</dt><dd>the id of the child element </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a9b21defb3b7d9023324df3bb8328c87f">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a8b571789fcf41713b8bd7d8e8041a2ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 PackedDecode::openElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElementId.html">ElementId</a> &amp;&#160;</td>
          <td class="paramname"><em>elemId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open (traverse into) the next child element, which must be of a specific type. </p>
<p>The child becomes the current parent, and its attributes are initialized for use with getNextAttributeId. The child must match the given element id or an exception is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elemId</td><td>is the given element id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the child element </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#ac6af23e00b46785ec0894c37a6f72d87">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a919a4c874a926b3d1a74e68c8dde86e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 PackedDecode::peekElement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at the next child element of the current parent, without traversing in (opening) it. </p>
<p>The element id is returned, which can be compared to <a class="el" href="classElementId.html" title="An annotation for a specific collection of hierarchical data. ">ElementId</a> labels. If there are no remaining child elements to traverse, 0 is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the element id or 0 </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a5a196e06e948a4ab4023fe0e5d129377">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a7af7102b4a55e29e26a0da50f33d99b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PackedDecode::readBool </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as a boolean value. </p>
<p>The last attribute, as returned by getNextAttributeId, is treated as a boolean, and its value is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the boolean value associated with the current attribute. </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a41a25fdd41dff502755f8c142c5a59d8">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="ab03c6ebf3f561e5353ee1319fdc4162a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PackedDecode::readBool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as a boolean value. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then parsed as a boolean and its value returned. If there is no attribute matching the id, an exception is thrown. Parsing via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean value </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#af097ef2bdd296e892cc4c1c48639693e">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a969ed204ac0d1fc43acf0f3065aa91de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8 PackedDecode::readInteger </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an integer from the <em>current</em> position given its length in bytes. </p>
<p>The integer is encoded, 7-bits per byte, starting with the most significant 7-bits. The integer is decode from the <em>current</em> position, and the position is advanced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>is the number of bytes to extract </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a348412434319f578505367b0ff225dcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intb PackedDecode::readSignedInteger </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as a signed integer value. </p>
<p>The last attribute, as returned by getNextAttributeId, is treated as a signed integer, and its value is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the signed integer value associated with the current attribute. </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a88c617582ce9540eca9519accbb8ee00">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="ade2eb1984afead4ee24cf9b70ce3b2ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intb PackedDecode::readSignedInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as a signed integer. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then parsed as a signed integer and its value returned. If there is no attribute matching the id, an exception is thrown. Parsing via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the signed integer value </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a59999a0af09a7b5654fdb08febe7f3eb">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a2ed06cb62e12a3fbeecf2756ef1c6590"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intb PackedDecode::readSignedIntegerExpectString </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>expect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intb&#160;</td>
          <td class="paramname"><em>expectval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as either a signed integer value or a string. </p>
<p>If the attribute is an integer, its value is returned. If the attribute is a string, it must match an expected string passed to the method, and a predetermined integer value associated with the string is returned. If the attribute neither matches the expected string nor is an integer, the return value is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expect</td><td>is the string value to expect if the attribute is encoded as a string </td></tr>
    <tr><td class="paramname">expectval</td><td>is the integer value to return if the attribute matches the expected string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoded integer or the integer value associated with the expected string </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a4e3deb10c5112cb984390b7a14262202">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="ae4a08bead1c9dfab1e86a8d20ed10c26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intb PackedDecode::readSignedIntegerExpectString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>expect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intb&#160;</td>
          <td class="paramname"><em>expectval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as either a signed integer or a string. </p>
<p>If the attribute is an integer, its value is parsed and returned. If the attribute is encoded as a string, it must match an expected string passed to this method. In this case, a predetermined integer value is passed back, indicating a matching string was parsed. If the attribute neither matches the expected string nor is an integer, the return value is undefined. If there is no attribute matching the id, an exception is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
    <tr><td class="paramname">expect</td><td>is the string to expect, if the attribute is not encoded as an integer </td></tr>
    <tr><td class="paramname">expectval</td><td>is the integer value to return if the attribute matches the expected string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoded integer or the integer value associated with the expected string </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#af003e43112b4d358a0d24b653de72d13">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="abba3d18f2a01441d0a0df619df46066e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * PackedDecode::readSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as an address space. </p>
<p>The last attribute, as returned by getNextAttributeId, is returned as an address space. </p>
<dl class="section return"><dt>Returns</dt><dd>the address space associated with the current attribute. </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a698792800d19dede5dc90f8d091a0efb">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="aadc8290dd84387e11f78059768cf7402"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * PackedDecode::readSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the specific attribute in the current element and return it as an address space. </p>
<p>Search attributes from the current element for a match to the given attribute id. Return this attribute as an address space. If there is no attribute matching the id, an exception is thrown. Parse via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address space associated with the attribute </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#ac5d2b96ed213096d7cc93a85c2e3c030">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a75cb2804b7762e2419ef28317a298ef5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string PackedDecode::readString </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as a string. </p>
<p>The last attribute, as returned by getNextAttributeId, is returned as a string. </p>
<dl class="section return"><dt>Returns</dt><dd>the string associated with the current attribute. </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a206874f59d968db5904c0d39ad6bfdee">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a7a3e35a8ae3d45c6108480a5204442e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string PackedDecode::readString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the specific attribute in the current element and return it as a string. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then returned as a string. If there is no attribute matching the id, and exception is thrown. Parse via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string associated with the attribute </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a4403ec4674a01b257d4cb2494a40b25b">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a54ca75cfef14da4da656b45bbb3b2277"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb PackedDecode::readUnsignedInteger </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as an unsigned integer value. </p>
<p>The last attribute, as returned by getNextAttributeId, is treated as an unsigned integer, and its value is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the unsigned integer value associated with the current attribute. </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a738ae1f9145b933f70748cf039afe847">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a252d98ec98bf2ee2697b051f7fdc5875"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb PackedDecode::readUnsignedInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as an unsigned integer. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then parsed as an unsigned integer and its value returned. If there is no attribute matching the id, an exception is thrown. Parsing via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unsigned integer value </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#af6f34bd56b4fce89f77d93135aeb5a57">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="a0e28399b23ef28d6d07ae93dcceeb6df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PackedDecode::rewindAttributes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset attribute traversal for the current element. </p>
<p><a class="el" href="classAttributes.html" title="The attributes for a single XML element. ">Attributes</a> for a single element can be traversed more than once using the getNextAttributeId method. </p>

<p>Implements <a class="el" href="classDecoder.html#af90d9a4d81b76e608dd59614c8259231">Decoder</a>.</p>

</div>
</div>
<a class="anchor" id="afe2dfb8c337fd8cf0f6e1f09354921f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PackedDecode::skipAttribute </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip over the attribute at the current position. </p>
<p>The attribute at the <em>current</em> position is scanned enough to determine its length, and the position is advanced to the following byte. </p>

</div>
</div>
<a class="anchor" id="a8e43226695d5aced40bccfe69e057906"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PackedDecode::skipAttributeRemaining </td>
          <td>(</td>
          <td class="paramtype">uint1&#160;</td>
          <td class="paramname"><em>typeByte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skip over remaining attribute data, after a mismatch. </p>
<p>This assumes the header and <b>type</b> <b>byte</b> have been read. Decode type and length info and finish skipping over the attribute so that the next call to <a class="el" href="classPackedDecode.html#a5c87996b51a654de0dcce6da2dc6f094" title="Get the next attribute id for the current element. ">getNextAttributeId()</a> is on cut. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeByte</td><td>is the previously scanned type byte </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>marshal.hh</li>
<li>marshal.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
