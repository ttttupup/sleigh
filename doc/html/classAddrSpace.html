<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>decompiler: AddrSpace Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classAddrSpace-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AddrSpace Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A region where processor data is stored.  
 <a href="classAddrSpace.html#details">More...</a></p>

<p><code>#include &lt;space.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AddrSpace:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAddrSpace.png" usemap="#AddrSpace_map" alt=""/>
  <map id="AddrSpace_map" name="AddrSpace_map">
<area href="classConstantSpace.html" title="Special AddrSpace for representing constants during analysis. " alt="ConstantSpace" shape="rect" coords="0,56,111,80"/>
<area href="classJoinSpace.html" title="The pool of logically joined variables. " alt="JoinSpace" shape="rect" coords="121,56,232,80"/>
<area href="classOtherSpace.html" title="Special AddrSpace for special/user-defined address spaces. " alt="OtherSpace" shape="rect" coords="242,56,353,80"/>
<area href="classOverlaySpace.html" title="An overlay space. " alt="OverlaySpace" shape="rect" coords="363,56,474,80"/>
<area href="classSpacebaseSpace.html" title="A virtual space stack space. " alt="SpacebaseSpace" shape="rect" coords="484,56,595,80"/>
<area href="classUniqueSpace.html" title="The pool of temporary storage registers. " alt="UniqueSpace" shape="rect" coords="605,56,716,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5f6ad75f3ae456a8734ced8047818451"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a8d907075fd50528d0ac10d43af899be2">big_endian</a> = 1, 
<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451aaa1675e833af050897d4ad66c138f1b4">heritaged</a> = 2, 
<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451aeb1ab5b0f82801bfb177916a2b902fe6">does_deadcode</a> = 4, 
<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451ae26a47a5510e05c1ca0ab8ec2ee0b72b">programspecific</a> = 8, 
<br/>
&#160;&#160;<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451abb22ff2778e1876ccf90657fc6df801f">reverse_justification</a> = 16, 
<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451aa54bdb7e06b55e1bed3ece9eb0864859">formal_stackspace</a> = 0x20, 
<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a7820728fd72194c3c22534c0d814ab76">overlay</a> = 0x40, 
<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451ae8c7fcb8745b27504eb57262b2936d4b">overlaybase</a> = 0x80, 
<br/>
&#160;&#160;<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451ad16f38794d350a82a0af64e95b933f50">truncated</a> = 0x100, 
<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a91dce97e6f6b850d04eb182edde6e2c6">hasphysical</a> = 0x200, 
<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a8a071c679352d4d470de464cc455f071">is_otherspace</a> = 0x400, 
<a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a4a7e5f29d8510b239e70ba18fa9c7864">has_nearpointers</a> = 0x800
<br/>
 }</td></tr>
<tr class="separator:a5f6ad75f3ae456a8734ced8047818451"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8ff2c48f386eb8be5d60206c28cc1be2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a8ff2c48f386eb8be5d60206c28cc1be2">AddrSpace</a> (<a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *m, const <a class="el" href="classTranslate.html">Translate</a> *t, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231">spacetype</a> tp, const string &amp;nm, uint4 size, uint4 ws, int4 ind, uint4 fl, int4 dl)</td></tr>
<tr class="separator:a8ff2c48f386eb8be5d60206c28cc1be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ba3e0553cd1713a2becedf4541e6b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a89ba3e0553cd1713a2becedf4541e6b9">AddrSpace</a> (<a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *m, const <a class="el" href="classTranslate.html">Translate</a> *t, <a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231">spacetype</a> tp)</td></tr>
<tr class="memdesc:a89ba3e0553cd1713a2becedf4541e6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use with decode.  <a href="#a89ba3e0553cd1713a2becedf4541e6b9">More...</a><br/></td></tr>
<tr class="separator:a89ba3e0553cd1713a2becedf4541e6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb16b4237b6fdfd311f9fd6f96252613"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb16b4237b6fdfd311f9fd6f96252613"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#acb16b4237b6fdfd311f9fd6f96252613">~AddrSpace</a> (void)</td></tr>
<tr class="memdesc:acb16b4237b6fdfd311f9fd6f96252613"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address space destructor. <br/></td></tr>
<tr class="separator:acb16b4237b6fdfd311f9fd6f96252613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1077feee89cf4434154e017a3360f5"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a9a1077feee89cf4434154e017a3360f5">getName</a> (void) const </td></tr>
<tr class="memdesc:a9a1077feee89cf4434154e017a3360f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name.  <a href="#a9a1077feee89cf4434154e017a3360f5">More...</a><br/></td></tr>
<tr class="separator:a9a1077feee89cf4434154e017a3360f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5502574575723e9af7ad3d3b8844fdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#aa5502574575723e9af7ad3d3b8844fdf">getManager</a> (void) const </td></tr>
<tr class="memdesc:aa5502574575723e9af7ad3d3b8844fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the space manager.  <a href="#aa5502574575723e9af7ad3d3b8844fdf">More...</a><br/></td></tr>
<tr class="separator:aa5502574575723e9af7ad3d3b8844fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd0745190cc202feaec683a31f043d9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTranslate.html">Translate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#affd0745190cc202feaec683a31f043d9">getTrans</a> (void) const </td></tr>
<tr class="memdesc:affd0745190cc202feaec683a31f043d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the processor translator.  <a href="#affd0745190cc202feaec683a31f043d9">More...</a><br/></td></tr>
<tr class="separator:affd0745190cc202feaec683a31f043d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219ee14b2c9fef027078b63c8b485e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231">spacetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a219ee14b2c9fef027078b63c8b485e76">getType</a> (void) const </td></tr>
<tr class="memdesc:a219ee14b2c9fef027078b63c8b485e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of space.  <a href="#a219ee14b2c9fef027078b63c8b485e76">More...</a><br/></td></tr>
<tr class="separator:a219ee14b2c9fef027078b63c8b485e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3497d662ef4ed44dc1b936f2a07c30cd"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a3497d662ef4ed44dc1b936f2a07c30cd">getDelay</a> (void) const </td></tr>
<tr class="memdesc:a3497d662ef4ed44dc1b936f2a07c30cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of heritage passes being delayed.  <a href="#a3497d662ef4ed44dc1b936f2a07c30cd">More...</a><br/></td></tr>
<tr class="separator:a3497d662ef4ed44dc1b936f2a07c30cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844c74531e892138675449ccbd5cbf76"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a844c74531e892138675449ccbd5cbf76">getDeadcodeDelay</a> (void) const </td></tr>
<tr class="memdesc:a844c74531e892138675449ccbd5cbf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of passes before deadcode removal is allowed.  <a href="#a844c74531e892138675449ccbd5cbf76">More...</a><br/></td></tr>
<tr class="separator:a844c74531e892138675449ccbd5cbf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6053f6a9a768acc129311f367318a9d"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#aa6053f6a9a768acc129311f367318a9d">getIndex</a> (void) const </td></tr>
<tr class="memdesc:aa6053f6a9a768acc129311f367318a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integer identifier.  <a href="#aa6053f6a9a768acc129311f367318a9d">More...</a><br/></td></tr>
<tr class="separator:aa6053f6a9a768acc129311f367318a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3d94aea39c4fc962e493b81452afe8"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a2a3d94aea39c4fc962e493b81452afe8">getWordSize</a> (void) const </td></tr>
<tr class="memdesc:a2a3d94aea39c4fc962e493b81452afe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the addressable unit size.  <a href="#a2a3d94aea39c4fc962e493b81452afe8">More...</a><br/></td></tr>
<tr class="separator:a2a3d94aea39c4fc962e493b81452afe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cfccb152e2d1f13cbb70e253cf69bf"><td class="memItemLeft" align="right" valign="top">uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#ac0cfccb152e2d1f13cbb70e253cf69bf">getAddrSize</a> (void) const </td></tr>
<tr class="memdesc:ac0cfccb152e2d1f13cbb70e253cf69bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the space.  <a href="#ac0cfccb152e2d1f13cbb70e253cf69bf">More...</a><br/></td></tr>
<tr class="separator:ac0cfccb152e2d1f13cbb70e253cf69bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592b7cfae93217aac10c62dd63b30941"><td class="memItemLeft" align="right" valign="top">uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a592b7cfae93217aac10c62dd63b30941">getHighest</a> (void) const </td></tr>
<tr class="memdesc:a592b7cfae93217aac10c62dd63b30941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the highest byte-scaled address.  <a href="#a592b7cfae93217aac10c62dd63b30941">More...</a><br/></td></tr>
<tr class="separator:a592b7cfae93217aac10c62dd63b30941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21a14246466b6d6bc8bd5d592e86b69"><td class="memItemLeft" align="right" valign="top">uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#ad21a14246466b6d6bc8bd5d592e86b69">getPointerLowerBound</a> (void) const </td></tr>
<tr class="memdesc:ad21a14246466b6d6bc8bd5d592e86b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lower bound for assuming an offset is a pointer.  <a href="#ad21a14246466b6d6bc8bd5d592e86b69">More...</a><br/></td></tr>
<tr class="separator:ad21a14246466b6d6bc8bd5d592e86b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dfc6a5657075b0f777cfd938b8dc1c"><td class="memItemLeft" align="right" valign="top">uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#ac7dfc6a5657075b0f777cfd938b8dc1c">getPointerUpperBound</a> (void) const </td></tr>
<tr class="memdesc:ac7dfc6a5657075b0f777cfd938b8dc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get upper bound for assuming an offset is a pointer.  <a href="#ac7dfc6a5657075b0f777cfd938b8dc1c">More...</a><br/></td></tr>
<tr class="separator:ac7dfc6a5657075b0f777cfd938b8dc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab735a8026d27e65147f67fc1ebbdbe94"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#ab735a8026d27e65147f67fc1ebbdbe94">getMinimumPtrSize</a> (void) const </td></tr>
<tr class="memdesc:ab735a8026d27e65147f67fc1ebbdbe94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum pointer size for <b>this</b> space.  <a href="#ab735a8026d27e65147f67fc1ebbdbe94">More...</a><br/></td></tr>
<tr class="separator:ab735a8026d27e65147f67fc1ebbdbe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b66b527431243c6ea0bb471d813c5f3"><td class="memItemLeft" align="right" valign="top">uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a5b66b527431243c6ea0bb471d813c5f3">wrapOffset</a> (uintb off) const </td></tr>
<tr class="memdesc:a5b66b527431243c6ea0bb471d813c5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap -off- to the offset that fits into this space.  <a href="#a5b66b527431243c6ea0bb471d813c5f3">More...</a><br/></td></tr>
<tr class="separator:a5b66b527431243c6ea0bb471d813c5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c33b5d21f18a7a06b2d5e083f786c8"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a10c33b5d21f18a7a06b2d5e083f786c8">getShortcut</a> (void) const </td></tr>
<tr class="memdesc:a10c33b5d21f18a7a06b2d5e083f786c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shortcut character.  <a href="#a10c33b5d21f18a7a06b2d5e083f786c8">More...</a><br/></td></tr>
<tr class="separator:a10c33b5d21f18a7a06b2d5e083f786c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c88339e07b5da212fee17205ddf20d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a9c88339e07b5da212fee17205ddf20d1">isHeritaged</a> (void) const </td></tr>
<tr class="memdesc:a9c88339e07b5da212fee17205ddf20d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if dataflow has been traced.  <a href="#a9c88339e07b5da212fee17205ddf20d1">More...</a><br/></td></tr>
<tr class="separator:a9c88339e07b5da212fee17205ddf20d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a345015f43b75815a5debdc41c3c375"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a3a345015f43b75815a5debdc41c3c375">doesDeadcode</a> (void) const </td></tr>
<tr class="memdesc:a3a345015f43b75815a5debdc41c3c375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if dead code analysis should be done on this space.  <a href="#a3a345015f43b75815a5debdc41c3c375">More...</a><br/></td></tr>
<tr class="separator:a3a345015f43b75815a5debdc41c3c375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e91f272c5e148c8e75e139abbe19a8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a2e91f272c5e148c8e75e139abbe19a8b">hasPhysical</a> (void) const </td></tr>
<tr class="memdesc:a2e91f272c5e148c8e75e139abbe19a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if data is physically stored in this.  <a href="#a2e91f272c5e148c8e75e139abbe19a8b">More...</a><br/></td></tr>
<tr class="separator:a2e91f272c5e148c8e75e139abbe19a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee713265281a230a8d25ea84328c37de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#aee713265281a230a8d25ea84328c37de">isBigEndian</a> (void) const </td></tr>
<tr class="memdesc:aee713265281a230a8d25ea84328c37de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if values in this space are big endian.  <a href="#aee713265281a230a8d25ea84328c37de">More...</a><br/></td></tr>
<tr class="separator:aee713265281a230a8d25ea84328c37de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34059c36f09aeab6e6585317be85dd32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a34059c36f09aeab6e6585317be85dd32">isReverseJustified</a> (void) const </td></tr>
<tr class="memdesc:a34059c36f09aeab6e6585317be85dd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if alignment justification does not match endianness.  <a href="#a34059c36f09aeab6e6585317be85dd32">More...</a><br/></td></tr>
<tr class="separator:a34059c36f09aeab6e6585317be85dd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c612644dfaf2e8c857c461e67fb14ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a6c612644dfaf2e8c857c461e67fb14ba">isFormalStackSpace</a> (void) const </td></tr>
<tr class="memdesc:a6c612644dfaf2e8c857c461e67fb14ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> is attached to the formal <b>stack</b> <b>pointer</b>.  <a href="#a6c612644dfaf2e8c857c461e67fb14ba">More...</a><br/></td></tr>
<tr class="separator:a6c612644dfaf2e8c857c461e67fb14ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4dcdfc3ef7230974b5f4a36161d29d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a4dcdfc3ef7230974b5f4a36161d29d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a4a4dcdfc3ef7230974b5f4a36161d29d">isOverlay</a> (void) const </td></tr>
<tr class="memdesc:a4a4dcdfc3ef7230974b5f4a36161d29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if this is an overlay space. <br/></td></tr>
<tr class="separator:a4a4dcdfc3ef7230974b5f4a36161d29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cb38842b2f4e8279bee04864239001"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04cb38842b2f4e8279bee04864239001"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a04cb38842b2f4e8279bee04864239001">isOverlayBase</a> (void) const </td></tr>
<tr class="memdesc:a04cb38842b2f4e8279bee04864239001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if other spaces overlay this space. <br/></td></tr>
<tr class="separator:a04cb38842b2f4e8279bee04864239001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0770e74cdceaa69623914616cb43c4ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0770e74cdceaa69623914616cb43c4ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a0770e74cdceaa69623914616cb43c4ed">isOtherSpace</a> (void) const </td></tr>
<tr class="memdesc:a0770e74cdceaa69623914616cb43c4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <b>this</b> is the <em>other</em> address space. <br/></td></tr>
<tr class="separator:a0770e74cdceaa69623914616cb43c4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7472d8a944382dab56e41ba5deca72c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#aa7472d8a944382dab56e41ba5deca72c">isTruncated</a> (void) const </td></tr>
<tr class="memdesc:aa7472d8a944382dab56e41ba5deca72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if this space is truncated from its original size.  <a href="#aa7472d8a944382dab56e41ba5deca72c">More...</a><br/></td></tr>
<tr class="separator:aa7472d8a944382dab56e41ba5deca72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fea2c202b0f30815e61aab4babb52f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fea2c202b0f30815e61aab4babb52f8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a1fea2c202b0f30815e61aab4babb52f8">hasNearPointers</a> (void) const </td></tr>
<tr class="memdesc:a1fea2c202b0f30815e61aab4babb52f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if <em>near</em> (truncated) pointers into <b>this</b> space are possible. <br/></td></tr>
<tr class="separator:a1fea2c202b0f30815e61aab4babb52f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cf84c2900da85d1aeb5c737182f4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a23cf84c2900da85d1aeb5c737182f4e8">printOffset</a> (ostream &amp;s, uintb offset) const </td></tr>
<tr class="memdesc:a23cf84c2900da85d1aeb5c737182f4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an address offset to a stream.  <a href="#a23cf84c2900da85d1aeb5c737182f4e8">More...</a><br/></td></tr>
<tr class="separator:a23cf84c2900da85d1aeb5c737182f4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae785e311543d4e95c7d344b0c93823c"><td class="memItemLeft" align="right" valign="top">virtual int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#aae785e311543d4e95c7d344b0c93823c">numSpacebase</a> (void) const </td></tr>
<tr class="memdesc:aae785e311543d4e95c7d344b0c93823c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of base registers associated with this space.  <a href="#aae785e311543d4e95c7d344b0c93823c">More...</a><br/></td></tr>
<tr class="separator:aae785e311543d4e95c7d344b0c93823c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b16390dfa556c9bdd6fe5b31448f7d7"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a3b16390dfa556c9bdd6fe5b31448f7d7">getSpacebase</a> (int4 i) const </td></tr>
<tr class="memdesc:a3b16390dfa556c9bdd6fe5b31448f7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a base register that creates this virtual space.  <a href="#a3b16390dfa556c9bdd6fe5b31448f7d7">More...</a><br/></td></tr>
<tr class="separator:a3b16390dfa556c9bdd6fe5b31448f7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa697bc18ef49fd35c33845be9d9d2af6"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#aa697bc18ef49fd35c33845be9d9d2af6">getSpacebaseFull</a> (int4 i) const </td></tr>
<tr class="memdesc:aa697bc18ef49fd35c33845be9d9d2af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return original spacebase register before truncation.  <a href="#aa697bc18ef49fd35c33845be9d9d2af6">More...</a><br/></td></tr>
<tr class="separator:aa697bc18ef49fd35c33845be9d9d2af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717c89d2bce8e930d230fa24227d7caa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a717c89d2bce8e930d230fa24227d7caa">stackGrowsNegative</a> (void) const </td></tr>
<tr class="memdesc:a717c89d2bce8e930d230fa24227d7caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <b>true</b> if a stack in this space grows negative.  <a href="#a717c89d2bce8e930d230fa24227d7caa">More...</a><br/></td></tr>
<tr class="separator:a717c89d2bce8e930d230fa24227d7caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5971d35628c019b97c34a4b90001a5f8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a5971d35628c019b97c34a4b90001a5f8">getContain</a> (void) const </td></tr>
<tr class="memdesc:a5971d35628c019b97c34a4b90001a5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this space's containing space (if any)  <a href="#a5971d35628c019b97c34a4b90001a5f8">More...</a><br/></td></tr>
<tr class="separator:a5971d35628c019b97c34a4b90001a5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c407cfabac453b763b59d14cdec74de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a2c407cfabac453b763b59d14cdec74de">encodeAttributes</a> (<a class="el" href="classEncoder.html">Encoder</a> &amp;encoder, uintb offset) const </td></tr>
<tr class="memdesc:a2c407cfabac453b763b59d14cdec74de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode address attributes to a stream.  <a href="#a2c407cfabac453b763b59d14cdec74de">More...</a><br/></td></tr>
<tr class="separator:a2c407cfabac453b763b59d14cdec74de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcc0af3ca69f06649b1a6d533fd8a4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a4fcc0af3ca69f06649b1a6d533fd8a4a">encodeAttributes</a> (<a class="el" href="classEncoder.html">Encoder</a> &amp;encoder, uintb offset, int4 size) const </td></tr>
<tr class="memdesc:a4fcc0af3ca69f06649b1a6d533fd8a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode an address and size attributes to a stream.  <a href="#a4fcc0af3ca69f06649b1a6d533fd8a4a">More...</a><br/></td></tr>
<tr class="separator:a4fcc0af3ca69f06649b1a6d533fd8a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd61654ef34bec85e16360eeb08e31d"><td class="memItemLeft" align="right" valign="top">virtual uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#acfd61654ef34bec85e16360eeb08e31d">decodeAttributes</a> (<a class="el" href="classDecoder.html">Decoder</a> &amp;decoder, uint4 &amp;size) const </td></tr>
<tr class="memdesc:acfd61654ef34bec85e16360eeb08e31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover an offset and size.  <a href="#acfd61654ef34bec85e16360eeb08e31d">More...</a><br/></td></tr>
<tr class="separator:acfd61654ef34bec85e16360eeb08e31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a28ec850803f89be4db6c85669573cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a0a28ec850803f89be4db6c85669573cc">printRaw</a> (ostream &amp;s, uintb offset) const </td></tr>
<tr class="memdesc:a0a28ec850803f89be4db6c85669573cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an address in this space to a stream.  <a href="#a0a28ec850803f89be4db6c85669573cc">More...</a><br/></td></tr>
<tr class="separator:a0a28ec850803f89be4db6c85669573cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7fb8caa90194445f8e70d2e88557e6"><td class="memItemLeft" align="right" valign="top">virtual uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a2a7fb8caa90194445f8e70d2e88557e6">read</a> (const string &amp;s, int4 &amp;size) const </td></tr>
<tr class="memdesc:a2a7fb8caa90194445f8e70d2e88557e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in an address (and possible size) from a string.  <a href="#a2a7fb8caa90194445f8e70d2e88557e6">More...</a><br/></td></tr>
<tr class="separator:a2a7fb8caa90194445f8e70d2e88557e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec4ae729130858e8370b98a2cc9ffb4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#acec4ae729130858e8370b98a2cc9ffb4">saveXml</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:acec4ae729130858e8370b98a2cc9ffb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the details of this space as XML.  <a href="#acec4ae729130858e8370b98a2cc9ffb4">More...</a><br/></td></tr>
<tr class="separator:acec4ae729130858e8370b98a2cc9ffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbc31fbef23911b81173b7c93b24543"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfbc31fbef23911b81173b7c93b24543"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#acfbc31fbef23911b81173b7c93b24543">decode</a> (<a class="el" href="classDecoder.html">Decoder</a> &amp;decoder)</td></tr>
<tr class="memdesc:acfbc31fbef23911b81173b7c93b24543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover the details of this space from XML. <br/></td></tr>
<tr class="separator:acfbc31fbef23911b81173b7c93b24543"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af5925a4ae67a290f59bf17533fac62b4"><td class="memItemLeft" align="right" valign="top">static uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#af5925a4ae67a290f59bf17533fac62b4">addressToByte</a> (uintb val, uint4 ws)</td></tr>
<tr class="memdesc:af5925a4ae67a290f59bf17533fac62b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale from addressable units to byte units.  <a href="#af5925a4ae67a290f59bf17533fac62b4">More...</a><br/></td></tr>
<tr class="separator:af5925a4ae67a290f59bf17533fac62b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9149df492bdcaccc208eac261e8365"><td class="memItemLeft" align="right" valign="top">static uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a3c9149df492bdcaccc208eac261e8365">byteToAddress</a> (uintb val, uint4 ws)</td></tr>
<tr class="memdesc:a3c9149df492bdcaccc208eac261e8365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale from byte units to addressable units.  <a href="#a3c9149df492bdcaccc208eac261e8365">More...</a><br/></td></tr>
<tr class="separator:a3c9149df492bdcaccc208eac261e8365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aa860242e1e753b3ad786a0aa1b36e"><td class="memItemLeft" align="right" valign="top">static int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a18aa860242e1e753b3ad786a0aa1b36e">addressToByteInt</a> (int4 val, uint4 ws)</td></tr>
<tr class="memdesc:a18aa860242e1e753b3ad786a0aa1b36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale int4 from addressable units to byte units.  <a href="#a18aa860242e1e753b3ad786a0aa1b36e">More...</a><br/></td></tr>
<tr class="separator:a18aa860242e1e753b3ad786a0aa1b36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082aa8e67257bcdcfc40d1280a3d0315"><td class="memItemLeft" align="right" valign="top">static int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a082aa8e67257bcdcfc40d1280a3d0315">byteToAddressInt</a> (int4 val, uint4 ws)</td></tr>
<tr class="memdesc:a082aa8e67257bcdcfc40d1280a3d0315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale int4 from byte units to addressable units.  <a href="#a082aa8e67257bcdcfc40d1280a3d0315">More...</a><br/></td></tr>
<tr class="separator:a082aa8e67257bcdcfc40d1280a3d0315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2e93b0348411a63144f566c684764d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#aee2e93b0348411a63144f566c684764d">compareByIndex</a> (const <a class="el" href="classAddrSpace.html">AddrSpace</a> *a, const <a class="el" href="classAddrSpace.html">AddrSpace</a> *b)</td></tr>
<tr class="memdesc:aee2e93b0348411a63144f566c684764d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two spaces by their index.  <a href="#aee2e93b0348411a63144f566c684764d">More...</a><br/></td></tr>
<tr class="separator:aee2e93b0348411a63144f566c684764d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af61640170c0baa861bbacee0e5c22a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#af61640170c0baa861bbacee0e5c22a31">calcScaleMask</a> (void)</td></tr>
<tr class="memdesc:af61640170c0baa861bbacee0e5c22a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate scale and mask.  <a href="#af61640170c0baa861bbacee0e5c22a31">More...</a><br/></td></tr>
<tr class="separator:af61640170c0baa861bbacee0e5c22a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd14c033be519525d486fcbc94a2bf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a3dd14c033be519525d486fcbc94a2bf7">setFlags</a> (uint4 fl)</td></tr>
<tr class="memdesc:a3dd14c033be519525d486fcbc94a2bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a cached attribute.  <a href="#a3dd14c033be519525d486fcbc94a2bf7">More...</a><br/></td></tr>
<tr class="separator:a3dd14c033be519525d486fcbc94a2bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523bc5940337efda7c00745c06c4346f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a523bc5940337efda7c00745c06c4346f">clearFlags</a> (uint4 fl)</td></tr>
<tr class="memdesc:a523bc5940337efda7c00745c06c4346f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a cached attribute.  <a href="#a523bc5940337efda7c00745c06c4346f">More...</a><br/></td></tr>
<tr class="separator:a523bc5940337efda7c00745c06c4346f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402a44d9589f7222560a6eb0aecf26db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a402a44d9589f7222560a6eb0aecf26db">saveBasicAttributes</a> (ostream &amp;s) const </td></tr>
<tr class="memdesc:a402a44d9589f7222560a6eb0aecf26db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the XML attributes of this space.  <a href="#a402a44d9589f7222560a6eb0aecf26db">More...</a><br/></td></tr>
<tr class="separator:a402a44d9589f7222560a6eb0aecf26db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7365b29fa5cf7d650af0552ceb26a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#acc7365b29fa5cf7d650af0552ceb26a9">decodeBasicAttributes</a> (<a class="el" href="classDecoder.html">Decoder</a> &amp;decoder)</td></tr>
<tr class="memdesc:acc7365b29fa5cf7d650af0552ceb26a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read attributes for <b>this</b> space from an open XML element.  <a href="#acc7365b29fa5cf7d650af0552ceb26a9">More...</a><br/></td></tr>
<tr class="separator:acc7365b29fa5cf7d650af0552ceb26a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ecacea771a34c4349d1f31272316c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a84ecacea771a34c4349d1f31272316c7">truncateSpace</a> (uint4 newsize)</td></tr>
<tr class="separator:a84ecacea771a34c4349d1f31272316c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa0df0a80bf601ab9e4384a36e72f0c72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0df0a80bf601ab9e4384a36e72f0c72"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#aa0df0a80bf601ab9e4384a36e72f0c72">name</a></td></tr>
<tr class="memdesc:aa0df0a80bf601ab9e4384a36e72f0c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of this space. <br/></td></tr>
<tr class="separator:aa0df0a80bf601ab9e4384a36e72f0c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c9b715d49d562e566ca392818fb798"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05c9b715d49d562e566ca392818fb798"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a05c9b715d49d562e566ca392818fb798">addressSize</a></td></tr>
<tr class="memdesc:a05c9b715d49d562e566ca392818fb798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of an address into this space in bytes. <br/></td></tr>
<tr class="separator:a05c9b715d49d562e566ca392818fb798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a3c9c83f617703abed64d7c6de849a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01a3c9c83f617703abed64d7c6de849a"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a01a3c9c83f617703abed64d7c6de849a">wordsize</a></td></tr>
<tr class="memdesc:a01a3c9c83f617703abed64d7c6de849a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of unit being addressed (1=byte) <br/></td></tr>
<tr class="separator:a01a3c9c83f617703abed64d7c6de849a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd897fe79e11489f2c9204f4a07067fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd897fe79e11489f2c9204f4a07067fc"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#acd897fe79e11489f2c9204f4a07067fc">minimumPointerSize</a></td></tr>
<tr class="memdesc:acd897fe79e11489f2c9204f4a07067fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest size of a pointer into <b>this</b> space (in bytes) <br/></td></tr>
<tr class="separator:acd897fe79e11489f2c9204f4a07067fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace333a37cd6fe6ae2c52cd9d64d7269e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace333a37cd6fe6ae2c52cd9d64d7269e"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#ace333a37cd6fe6ae2c52cd9d64d7269e">index</a></td></tr>
<tr class="memdesc:ace333a37cd6fe6ae2c52cd9d64d7269e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer identifier for the space. <br/></td></tr>
<tr class="separator:ace333a37cd6fe6ae2c52cd9d64d7269e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1ad3a09f9860eac23dd34f910808cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb1ad3a09f9860eac23dd34f910808cd"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#adb1ad3a09f9860eac23dd34f910808cd">delay</a></td></tr>
<tr class="memdesc:adb1ad3a09f9860eac23dd34f910808cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay in heritaging this space. <br/></td></tr>
<tr class="separator:adb1ad3a09f9860eac23dd34f910808cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fd37355d0ed2ebee552ac944f67d95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2fd37355d0ed2ebee552ac944f67d95"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#aa2fd37355d0ed2ebee552ac944f67d95">deadcodedelay</a></td></tr>
<tr class="memdesc:aa2fd37355d0ed2ebee552ac944f67d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay before deadcode removal is allowed on this space. <br/></td></tr>
<tr class="separator:aa2fd37355d0ed2ebee552ac944f67d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac3dc27910401c5a153026ed919d99466"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3dc27910401c5a153026ed919d99466"></a>
<a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231">spacetype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#ac3dc27910401c5a153026ed919d99466">type</a></td></tr>
<tr class="memdesc:ac3dc27910401c5a153026ed919d99466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of space (PROCESSOR, CONSTANT, INTERNAL, ...) <br/></td></tr>
<tr class="separator:ac3dc27910401c5a153026ed919d99466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f26bb0b06e43bc0337085808c211e14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f26bb0b06e43bc0337085808c211e14"></a>
<a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a8f26bb0b06e43bc0337085808c211e14">manage</a></td></tr>
<tr class="memdesc:a8f26bb0b06e43bc0337085808c211e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager for processor using this space. <br/></td></tr>
<tr class="separator:a8f26bb0b06e43bc0337085808c211e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12eb398085cfc5ea04614d13f7c81a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac12eb398085cfc5ea04614d13f7c81a3"></a>
const <a class="el" href="classTranslate.html">Translate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#ac12eb398085cfc5ea04614d13f7c81a3">trans</a></td></tr>
<tr class="memdesc:ac12eb398085cfc5ea04614d13f7c81a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processor translator (for register names etc) for this space. <br/></td></tr>
<tr class="separator:ac12eb398085cfc5ea04614d13f7c81a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0886d7bcbf22c5157cd09b1554d4f38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0886d7bcbf22c5157cd09b1554d4f38"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#af0886d7bcbf22c5157cd09b1554d4f38">refcount</a></td></tr>
<tr class="memdesc:af0886d7bcbf22c5157cd09b1554d4f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of managers using this space. <br/></td></tr>
<tr class="separator:af0886d7bcbf22c5157cd09b1554d4f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94e5466d60e021837ae49d4093ea6b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af94e5466d60e021837ae49d4093ea6b5"></a>
uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a></td></tr>
<tr class="memdesc:af94e5466d60e021837ae49d4093ea6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classAttributes.html" title="The attributes for a single XML element. ">Attributes</a> of the space. <br/></td></tr>
<tr class="separator:af94e5466d60e021837ae49d4093ea6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651b636a4b50b7e54ad81fc09c720b84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a651b636a4b50b7e54ad81fc09c720b84"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a651b636a4b50b7e54ad81fc09c720b84">highest</a></td></tr>
<tr class="memdesc:a651b636a4b50b7e54ad81fc09c720b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highest (byte) offset into this space. <br/></td></tr>
<tr class="separator:a651b636a4b50b7e54ad81fc09c720b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5a220b549a1bac5d86a8ccaae68c2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e5a220b549a1bac5d86a8ccaae68c2f"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a8e5a220b549a1bac5d86a8ccaae68c2f">pointerLowerBound</a></td></tr>
<tr class="memdesc:a8e5a220b549a1bac5d86a8ccaae68c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset below which we don't search for pointers. <br/></td></tr>
<tr class="separator:a8e5a220b549a1bac5d86a8ccaae68c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9314f29b21a32cc860db914606991912"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9314f29b21a32cc860db914606991912"></a>
uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#a9314f29b21a32cc860db914606991912">pointerUpperBound</a></td></tr>
<tr class="memdesc:a9314f29b21a32cc860db914606991912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset above which we don't search for pointers. <br/></td></tr>
<tr class="separator:a9314f29b21a32cc860db914606991912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51e6f51e1f0c3307e3a41a9d25e25dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad51e6f51e1f0c3307e3a41a9d25e25dd"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAddrSpace.html#ad51e6f51e1f0c3307e3a41a9d25e25dd">shortcut</a></td></tr>
<tr class="memdesc:ad51e6f51e1f0c3307e3a41a9d25e25dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut character for printing. <br/></td></tr>
<tr class="separator:ad51e6f51e1f0c3307e3a41a9d25e25dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0e578f3e90e10ec045899c0e9cb65d46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e578f3e90e10ec045899c0e9cb65d46"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>AddrSpaceManager</b></td></tr>
<tr class="separator:a0e578f3e90e10ec045899c0e9cb65d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A region where processor data is stored. </p>
<p>An <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> (<a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a> Space) is an arbitrary sequence of bytes where a processor can store data. As is usual with most processors' concept of RAM, an integer offset paired with an <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> forms the address (See <a class="el" href="classAddress.html" title="A low-level machine address for labelling bytes and data. ">Address</a>) of a byte. The <em>size</em> of an <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> indicates the number of bytes that can be separately addressed and is usually described by the number of bytes needed to encode the biggest offset. I.e. a <em>4-byte</em> address space means that there are offsets ranging from 0x00000000 to 0xffffffff within the space for a total of 2^32 addressable bytes within the space. There can be multiple address spaces, and it is typical to have spaces</p>
<ul>
<li><b>ram</b> Modelling the main processor address bus</li>
<li><b>register</b> Modelling a processors registers</li>
</ul>
<p>The processor specification can set up any address spaces it needs in an arbitrary manner, but <em>all</em> data manipulated by the processor, which the specification hopes to model, must be contained in some address space, including RAM, ROM, general registers, special registers, i/o ports, etc.</p>
<p>The analysis engine also uses additional address spaces to model special concepts. These include</p>
<ul>
<li><b>const</b> There is a <em>constant</em> address space for modelling constant values in pcode expressions (See <a class="el" href="classConstantSpace.html" title="Special AddrSpace for representing constants during analysis. ">ConstantSpace</a>)</li>
<li><b>unique</b> There is always a <em>unique</em> address space used as a pool for temporary registers. (See <a class="el" href="classUniqueSpace.html" title="The pool of temporary storage registers. ">UniqueSpace</a>) </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451a8d907075fd50528d0ac10d43af899be2"></a>big_endian</em>&nbsp;</td><td class="fielddoc">
<p>Space is big endian if set, little endian otherwise. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451aaa1675e833af050897d4ad66c138f1b4"></a>heritaged</em>&nbsp;</td><td class="fielddoc">
<p>This space is heritaged. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451aeb1ab5b0f82801bfb177916a2b902fe6"></a>does_deadcode</em>&nbsp;</td><td class="fielddoc">
<p>Dead-code analysis is done on this space. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451ae26a47a5510e05c1ca0ab8ec2ee0b72b"></a>programspecific</em>&nbsp;</td><td class="fielddoc">
<p>Space is specific to a particular loadimage. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451abb22ff2778e1876ccf90657fc6df801f"></a>reverse_justification</em>&nbsp;</td><td class="fielddoc">
<p>Justification within aligned word is opposite of endianness. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451aa54bdb7e06b55e1bed3ece9eb0864859"></a>formal_stackspace</em>&nbsp;</td><td class="fielddoc">
<p>Space attached to the formal <b>stack</b> <b>pointer</b>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451a7820728fd72194c3c22534c0d814ab76"></a>overlay</em>&nbsp;</td><td class="fielddoc">
<p>This space is an overlay of another space. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451ae8c7fcb8745b27504eb57262b2936d4b"></a>overlaybase</em>&nbsp;</td><td class="fielddoc">
<p>This is the base space for overlay space(s) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451ad16f38794d350a82a0af64e95b933f50"></a>truncated</em>&nbsp;</td><td class="fielddoc">
<p>Space is truncated from its original size, expect pointers larger than this size. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451a91dce97e6f6b850d04eb182edde6e2c6"></a>hasphysical</em>&nbsp;</td><td class="fielddoc">
<p>Has physical memory associated with it. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451a8a071c679352d4d470de464cc455f071"></a>is_otherspace</em>&nbsp;</td><td class="fielddoc">
<p>Quick check for the <a class="el" href="classOtherSpace.html" title="Special AddrSpace for special/user-defined address spaces. ">OtherSpace</a> derived class. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5f6ad75f3ae456a8734ced8047818451a4a7e5f29d8510b239e70ba18fa9c7864"></a>has_nearpointers</em>&nbsp;</td><td class="fielddoc">
<p>Does there exist near pointers into this space. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8ff2c48f386eb8be5d60206c28cc1be2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AddrSpace::AddrSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTranslate.html">Translate</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231">spacetype</a>&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>dl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize an address space with its basic attributes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>is the space manager associated with the new space </td></tr>
    <tr><td class="paramname">t</td><td>is the processor translator associated with the new space </td></tr>
    <tr><td class="paramname">tp</td><td>is the type of the new space (PROCESSOR, CONSTANT, INTERNAL,...) </td></tr>
    <tr><td class="paramname">nm</td><td>is the name of the new space </td></tr>
    <tr><td class="paramname">size</td><td>is the (offset encoding) size of the new space </td></tr>
    <tr><td class="paramname">ws</td><td>is the number of bytes in an addressable unit </td></tr>
    <tr><td class="paramname">ind</td><td>is the integer identifier for the new space </td></tr>
    <tr><td class="paramname">fl</td><td>can be 0 or <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a91dce97e6f6b850d04eb182edde6e2c6" title="Has physical memory associated with it. ">AddrSpace::hasphysical</a> </td></tr>
    <tr><td class="paramname">dl</td><td>is the number of rounds to delay heritage for the new space </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#a05c9b715d49d562e566ca392818fb798">addressSize</a>, <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a8d907075fd50528d0ac10d43af899be2">big_endian</a>, <a class="el" href="classAddrSpace.html#af61640170c0baa861bbacee0e5c22a31">calcScaleMask()</a>, <a class="el" href="classAddrSpace.html#aa2fd37355d0ed2ebee552ac944f67d95">deadcodedelay</a>, <a class="el" href="classAddrSpace.html#adb1ad3a09f9860eac23dd34f910808cd">delay</a>, <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451aeb1ab5b0f82801bfb177916a2b902fe6">does_deadcode</a>, <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>, <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a91dce97e6f6b850d04eb182edde6e2c6">hasphysical</a>, <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451aaa1675e833af050897d4ad66c138f1b4">heritaged</a>, <a class="el" href="classAddrSpace.html#ace333a37cd6fe6ae2c52cd9d64d7269e">index</a>, <a class="el" href="classTranslate.html#a4650154d4ecaef0d282e24c50ca0208b">Translate::isBigEndian()</a>, <a class="el" href="classAddrSpace.html#a8f26bb0b06e43bc0337085808c211e14">manage</a>, <a class="el" href="classAddrSpace.html#acd897fe79e11489f2c9204f4a07067fc">minimumPointerSize</a>, <a class="el" href="classAddrSpace.html#aa0df0a80bf601ab9e4384a36e72f0c72">name</a>, <a class="el" href="classAddrSpace.html#af0886d7bcbf22c5157cd09b1554d4f38">refcount</a>, <a class="el" href="classAddrSpace.html#ad51e6f51e1f0c3307e3a41a9d25e25dd">shortcut</a>, <a class="el" href="classAddrSpace.html#ac12eb398085cfc5ea04614d13f7c81a3">trans</a>, <a class="el" href="classAddrSpace.html#ac3dc27910401c5a153026ed919d99466">type</a>, and <a class="el" href="classAddrSpace.html#a01a3c9c83f617703abed64d7c6de849a">wordsize</a>.</p>

</div>
</div>
<a class="anchor" id="a89ba3e0553cd1713a2becedf4541e6b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AddrSpace::AddrSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTranslate.html">Translate</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231">spacetype</a>&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For use with decode. </p>
<p>This is a partial constructor, for initializing a space via XML </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the associated address space manager </td></tr>
    <tr><td class="paramname">t</td><td>is the processor translator </td></tr>
    <tr><td class="paramname">tp</td><td>the basic type of the space </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451aeb1ab5b0f82801bfb177916a2b902fe6">does_deadcode</a>, <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>, <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451aaa1675e833af050897d4ad66c138f1b4">heritaged</a>, <a class="el" href="classAddrSpace.html#a8f26bb0b06e43bc0337085808c211e14">manage</a>, <a class="el" href="classAddrSpace.html#acd897fe79e11489f2c9204f4a07067fc">minimumPointerSize</a>, <a class="el" href="classAddrSpace.html#af0886d7bcbf22c5157cd09b1554d4f38">refcount</a>, <a class="el" href="classAddrSpace.html#ad51e6f51e1f0c3307e3a41a9d25e25dd">shortcut</a>, <a class="el" href="classAddrSpace.html#ac12eb398085cfc5ea04614d13f7c81a3">trans</a>, <a class="el" href="classAddrSpace.html#ac3dc27910401c5a153026ed919d99466">type</a>, and <a class="el" href="classAddrSpace.html#a01a3c9c83f617703abed64d7c6de849a">wordsize</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af5925a4ae67a290f59bf17533fac62b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb AddrSpace::addressToByte </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale from addressable units to byte units. </p>
<p>Given an offset into an address space based on the addressable unit size (wordsize), convert it into a byte relative offset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is the offset to convert </td></tr>
    <tr><td class="paramname">ws</td><td>is the number of bytes in the addressable word </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the scaled offset </dd></dl>

<p>Referenced by <a class="el" href="classRawLoadImage.html#aee25cd14ca80ad47db0b17d56cc31180">RawLoadImage::adjustVma()</a>, <a class="el" href="classEmulateMemory.html#ad612d22e967669919fd5c8538ade212f">EmulateMemory::executeLoad()</a>, <a class="el" href="classEmulateMemory.html#a3fed95d66c73d4dad23532f959a9417d">EmulateMemory::executeStore()</a>, <a class="el" href="classAddrSpaceManager.html#ae16363aa88c3c9fd1859fc8d36ae9273">AddrSpaceManager::parseAddressSimple()</a>, <a class="el" href="classAddrSpace.html#a2a7fb8caa90194445f8e70d2e88557e6">read()</a>, and <a class="el" href="classAddrSpaceManager.html#a27d2893a87a604368cb0891482551349">AddrSpaceManager::resolveConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="a18aa860242e1e753b3ad786a0aa1b36e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 AddrSpace::addressToByteInt </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale int4 from addressable units to byte units. </p>
<p>Given an int4 offset into an address space based on the addressable unit size (wordsize), convert it into a byte relative offset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is the offset to convert </td></tr>
    <tr><td class="paramname">ws</td><td>is the number of bytes in the addressable word </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the scaled offset </dd></dl>

</div>
</div>
<a class="anchor" id="a3c9149df492bdcaccc208eac261e8365"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb AddrSpace::byteToAddress </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale from byte units to addressable units. </p>
<p>Given an offset in an address space based on bytes, convert it into an offset relative to the addressable unit of the space (wordsize) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is the offset to convert </td></tr>
    <tr><td class="paramname">ws</td><td>is the number of bytes in the addressable word </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the scaled offset </dd></dl>

<p>Referenced by <a class="el" href="classAddrSpace.html#a0a28ec850803f89be4db6c85669573cc">printRaw()</a>.</p>

</div>
</div>
<a class="anchor" id="a082aa8e67257bcdcfc40d1280a3d0315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 AddrSpace::byteToAddressInt </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale int4 from byte units to addressable units. </p>
<p>Given an int4 offset in an address space based on bytes, convert it into an offset relative to the addressable unit of the space (wordsize) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>is the offset to convert </td></tr>
    <tr><td class="paramname">ws</td><td>is the number of bytes in the addressable word </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the scaled offset </dd></dl>

</div>
</div>
<a class="anchor" id="af61640170c0baa861bbacee0e5c22a31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpace::calcScaleMask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate scale and mask. </p>
<p>Calculate <em>highest</em> based on <em>addressSize</em>, and <em>wordsize</em>. This also calculates the default pointerLowerBound </p>

<p>References <a class="el" href="classAddrSpace.html#a05c9b715d49d562e566ca392818fb798">addressSize</a>, <a class="el" href="address_8hh.html#aae7b27e228c11138200b27f02831fc00">calc_mask()</a>, <a class="el" href="classAddrSpace.html#a651b636a4b50b7e54ad81fc09c720b84">highest</a>, <a class="el" href="classAddrSpace.html#a8e5a220b549a1bac5d86a8ccaae68c2f">pointerLowerBound</a>, <a class="el" href="classAddrSpace.html#a9314f29b21a32cc860db914606991912">pointerUpperBound</a>, and <a class="el" href="classAddrSpace.html#a01a3c9c83f617703abed64d7c6de849a">wordsize</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpace.html#a8ff2c48f386eb8be5d60206c28cc1be2">AddrSpace()</a>, <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>, <a class="el" href="classAddrSpace.html#acc7365b29fa5cf7d650af0552ceb26a9">decodeBasicAttributes()</a>, and <a class="el" href="classAddrSpace.html#a84ecacea771a34c4349d1f31272316c7">truncateSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="a523bc5940337efda7c00745c06c4346f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpace::clearFlags </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>fl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a cached attribute. </p>
<p>An internal method for derived classes to clear space attibutes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fl</td><td>is the set of attributes to clear </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>.</p>

<p>Referenced by <a class="el" href="classConstantSpace.html#a36cf29b192ec6776dda7cd11ca8f8d07">ConstantSpace::ConstantSpace()</a>, <a class="el" href="classJoinSpace.html#a5fdea9549e6071a2f4e6a21762eba6d8">JoinSpace::JoinSpace()</a>, and <a class="el" href="classOtherSpace.html#acf1d9a8da9c19e9f5157af4ef2be179a">OtherSpace::OtherSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="aee2e93b0348411a63144f566c684764d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrSpace::compareByIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two spaces by their index. </p>
<p>For sorting a sequence of address spaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is the first space </td></tr>
    <tr><td class="paramname">b</td><td>is the second space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the first space should come before the second </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#ace333a37cd6fe6ae2c52cd9d64d7269e">index</a>.</p>

</div>
</div>
<a class="anchor" id="acfd61654ef34bec85e16360eeb08e31d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb AddrSpace::decodeAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDecoder.html">Decoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint4 &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recover an offset and size. </p>
<p>For an open element describing an address in <b>this</b> space, this routine recovers the offset and possibly the size described by the element </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decoder</td><td>is the stream decoder </td></tr>
    <tr><td class="paramname">size</td><td>is a reference where the recovered size should be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the recovered offset </dd></dl>

<p>Reimplemented in <a class="el" href="classJoinSpace.html#a782272458968df7a727e7d6280edc8d8">JoinSpace</a>.</p>

<p>References <a class="el" href="classDecoder.html#ad98ca46e0ea39c4ce713d4b14bc44772">Decoder::getNextAttributeId()</a>, <a class="el" href="classDecoder.html#a88c617582ce9540eca9519accbb8ee00">Decoder::readSignedInteger()</a>, and <a class="el" href="classDecoder.html#a738ae1f9145b933f70748cf039afe847">Decoder::readUnsignedInteger()</a>.</p>

<p>Referenced by <a class="el" href="structVarnodeData.html#ad620f74a51a72a652bf518571e351957">VarnodeData::decodeFromAttributes()</a>.</p>

</div>
</div>
<a class="anchor" id="acc7365b29fa5cf7d650af0552ceb26a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpace::decodeBasicAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDecoder.html">Decoder</a> &amp;&#160;</td>
          <td class="paramname"><em>decoder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read attributes for <b>this</b> space from an open XML element. </p>
<p>Walk attributes of the current element and recover all the properties defining this space. The processor translator, <em>trans</em>, and the <em>type</em> must already be filled in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decoder</td><td>is the stream decoder </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#a05c9b715d49d562e566ca392818fb798">addressSize</a>, <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a8d907075fd50528d0ac10d43af899be2">big_endian</a>, <a class="el" href="classAddrSpace.html#af61640170c0baa861bbacee0e5c22a31">calcScaleMask()</a>, <a class="el" href="classAddrSpace.html#aa2fd37355d0ed2ebee552ac944f67d95">deadcodedelay</a>, <a class="el" href="classAddrSpace.html#adb1ad3a09f9860eac23dd34f910808cd">delay</a>, <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>, <a class="el" href="classDecoder.html#ad98ca46e0ea39c4ce713d4b14bc44772">Decoder::getNextAttributeId()</a>, <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a91dce97e6f6b850d04eb182edde6e2c6">hasphysical</a>, <a class="el" href="classAddrSpace.html#ace333a37cd6fe6ae2c52cd9d64d7269e">index</a>, <a class="el" href="classAddrSpace.html#aa0df0a80bf601ab9e4384a36e72f0c72">name</a>, <a class="el" href="classDecoder.html#a41a25fdd41dff502755f8c142c5a59d8">Decoder::readBool()</a>, <a class="el" href="classDecoder.html#a88c617582ce9540eca9519accbb8ee00">Decoder::readSignedInteger()</a>, <a class="el" href="classDecoder.html#a206874f59d968db5904c0d39ad6bfdee">Decoder::readString()</a>, <a class="el" href="classDecoder.html#a738ae1f9145b933f70748cf039afe847">Decoder::readUnsignedInteger()</a>, and <a class="el" href="classAddrSpace.html#a01a3c9c83f617703abed64d7c6de849a">wordsize</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpace.html#acfbc31fbef23911b81173b7c93b24543">decode()</a>, and <a class="el" href="classSpacebaseSpace.html#a8a430a27ade5a8703c520656bb5ed10f">SpacebaseSpace::decode()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a345015f43b75815a5debdc41c3c375"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrSpace::doesDeadcode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <b>true</b> if dead code analysis should be done on this space. </p>
<p>Most memory locations should have dead-code analysis performed, and this routine will return <b>true</b>. For certain special spaces like the <em>constant</em> space, dead-code analysis doesn't make sense, and this routine returns <b>false</b>. </p>

<p>References <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451aeb1ab5b0f82801bfb177916a2b902fe6">does_deadcode</a>, and <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>.</p>

</div>
</div>
<a class="anchor" id="a2c407cfabac453b763b59d14cdec74de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpace::encodeAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEncoder.html">Encoder</a> &amp;&#160;</td>
          <td class="paramname"><em>encoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode address attributes to a stream. </p>
<p>Write the main attributes for an address within <b>this</b> space. The caller provides only the <em>offset</em>, and this routine fills in other details pertaining to this particular space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>is the stream encoder </td></tr>
    <tr><td class="paramname">offset</td><td>is the offset of the address </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classJoinSpace.html#a3627ef798a38b95cbc28d44ea44e05ba">JoinSpace</a>.</p>

<p>References <a class="el" href="classEncoder.html#a6e2eec2d5ea88c1811202cf0ef626ab1">Encoder::writeSpace()</a>, and <a class="el" href="classEncoder.html#a50b3419ae52a4536b0644cdb8e806565">Encoder::writeUnsignedInteger()</a>.</p>

<p>Referenced by <a class="el" href="structTrackedContext.html#a49ec0cb5b28fc198d428d47374c73d91">TrackedContext::encode()</a>, <a class="el" href="classAddress.html#afcb62651d149f28317aa0af35830a739">Address::encode()</a>, <a class="el" href="classSeqNum.html#a95d4b48e1869c8b7ee7fcd7d07d9df57">SeqNum::encode()</a>, <a class="el" href="classContextInternal.html#aa6c2913e6b71ccc005c5914fd6664627">ContextInternal::encodeContext()</a>, and <a class="el" href="classContextDatabase.html#aad4f93f4dacd48b7ccb2e5c378d4d15c">ContextDatabase::encodeTracked()</a>.</p>

</div>
</div>
<a class="anchor" id="a4fcc0af3ca69f06649b1a6d533fd8a4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpace::encodeAttributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEncoder.html">Encoder</a> &amp;&#160;</td>
          <td class="paramname"><em>encoder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode an address and size attributes to a stream. </p>
<p>Write the main attributes of an address with <b>this</b> space and a size. The caller provides the <em>offset</em> and <em>size</em>, and other details about this particular space are filled in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoder</td><td>is the stream encoder </td></tr>
    <tr><td class="paramname">offset</td><td>is the offset of the address </td></tr>
    <tr><td class="paramname">size</td><td>is the size of the memory location </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classJoinSpace.html#ab8d87d7917ef6a4884d7d5c6b072cce8">JoinSpace</a>.</p>

<p>References <a class="el" href="classEncoder.html#a82c265a30a9c6319d9fcc0b4f6e222e5">Encoder::writeSignedInteger()</a>, <a class="el" href="classEncoder.html#a6e2eec2d5ea88c1811202cf0ef626ab1">Encoder::writeSpace()</a>, and <a class="el" href="classEncoder.html#a50b3419ae52a4536b0644cdb8e806565">Encoder::writeUnsignedInteger()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0cfccb152e2d1f13cbb70e253cf69bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 AddrSpace::getAddrSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the space. </p>
<p>Return the number of bytes needed to represent an offset into this space. A space with 2^32 bytes has an address size of 4, for instance. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of an address </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#a05c9b715d49d562e566ca392818fb798">addressSize</a>.</p>

<p>Referenced by <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>, <a class="el" href="classAddress.html#a45e9717c199593d3446eae0328499e43">Address::getAddrSize()</a>, <a class="el" href="classAddrSpaceManager.html#ab8a93c129bd2799a82cccfc7df915942">AddrSpaceManager::getDefaultSize()</a>, <a class="el" href="classAddrSpace.html#a0a28ec850803f89be4db6c85669573cc">printRaw()</a>, and <a class="el" href="classConsistencyChecker.html#a23aec6161da89c04a0ca23ccbc2e455b">ConsistencyChecker::sizeRestriction()</a>.</p>

</div>
</div>
<a class="anchor" id="a5971d35628c019b97c34a4b90001a5f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * AddrSpace::getContain </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this space's containing space (if any) </p>
<p>If this space is virtual, then this routine returns the containing address space, otherwise it returns NULL. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the containing space or NULL </dd></dl>

<p>Reimplemented in <a class="el" href="classOverlaySpace.html#a43a463d9d50d7f243103f757308a2a19">OverlaySpace</a>, and <a class="el" href="classSpacebaseSpace.html#a05cf625b9a1eba78280bfab0c6b908f7">SpacebaseSpace</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">AddrSpaceManager::insertSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="a844c74531e892138675449ccbd5cbf76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 AddrSpace::getDeadcodeDelay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of passes before deadcode removal is allowed. </p>
<p>The point at which deadcode removal is performed on varnodes within a space can be set to skip some number of heritage passes, in case not all the varnodes are created within a single pass. This method gives the number of rounds that should be skipped before deadcode elimination begins </p>
<dl class="section return"><dt>Returns</dt><dd>the number of rounds to skip deadcode removal </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#aa2fd37355d0ed2ebee552ac944f67d95">deadcodedelay</a>.</p>

<p>Referenced by <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>.</p>

</div>
</div>
<a class="anchor" id="a3497d662ef4ed44dc1b936f2a07c30cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 AddrSpace::getDelay </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of heritage passes being delayed. </p>
<p>If the heritage algorithms need to trace dataflow within this space, the algorithms can delay tracing this space in order to let indirect references into the space resolve themselves. This method indicates the number of rounds of dataflow analysis that should be skipped for this space to let this resolution happen </p>
<dl class="section return"><dt>Returns</dt><dd>the number of rounds to skip heritage </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#adb1ad3a09f9860eac23dd34f910808cd">delay</a>.</p>

<p>Referenced by <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>.</p>

</div>
</div>
<a class="anchor" id="a592b7cfae93217aac10c62dd63b30941"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb AddrSpace::getHighest </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the highest byte-scaled address. </p>
<p>Get the highest (byte) offset possible for this space </p>
<dl class="section return"><dt>Returns</dt><dd>the offset </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#a651b636a4b50b7e54ad81fc09c720b84">highest</a>.</p>

<p>Referenced by <a class="el" href="classRange.html#a94744dd422421a5578aaca9fb6f382bf">Range::decodeFromAttributes()</a>, <a class="el" href="classContextInternal.html#ab49e9b4c05c997a393100f11f9d8f028">ContextInternal::getContext()</a>, <a class="el" href="classRange.html#a907491659daa4f7a6064bd357c83f30b">Range::getLastAddrOpen()</a>, <a class="el" href="classRangeList.html#ad5d22c063464f50cc7a033c6cf19152c">RangeList::getLastSignedRange()</a>, and <a class="el" href="classRange.html#a1f471967fde21f530f087c799681278a">Range::Range()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6053f6a9a768acc129311f367318a9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 AddrSpace::getIndex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the integer identifier. </p>
<p>Each address space has an associated index that can be used as an integer encoding of the space. </p>
<dl class="section return"><dt>Returns</dt><dd>the unique index </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#ace333a37cd6fe6ae2c52cd9d64d7269e">index</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a45068bcc8331bebc780f00e51bd85250">AddrSpaceManager::copySpaces()</a>, <a class="el" href="classAddrSpaceManager.html#aee56defff6dfb953555b001afb3a84ea">AddrSpaceManager::decodeSpaces()</a>, <a class="el" href="classMemoryState.html#aad70aa2f0fb034403741d18fdbb3a8aa">MemoryState::getMemoryBank()</a>, <a class="el" href="classAddrSpaceManager.html#a0bcb1edc24d876b71fac49c003307872">AddrSpaceManager::getNextSpaceInOrder()</a>, <a class="el" href="classAddrSpaceManager.html#a6330481f1f40a24d860c820a5a2b64f5">AddrSpaceManager::insertResolver()</a>, <a class="el" href="classSleighCompile.html#afadd41c3c850e824d48ec7c2638304c8">SleighCompile::newSpace()</a>, <a class="el" href="structVarnodeData.html#a253e48d84f2b17cfc0a1a6c9e6bdc4a9">VarnodeData::operator&lt;()</a>, <a class="el" href="classAddress.html#af07d3060bdc07d9b25cea7c561e6ef81">Address::operator&lt;()</a>, <a class="el" href="classRange.html#a295acb5c069a4458f2fc81d841447b49">Range::operator&lt;()</a>, <a class="el" href="classAddress.html#a4ae71cfe5906858be8c34d8b2cce18fd">Address::operator&lt;=()</a>, <a class="el" href="classAddrSpaceManager.html#a27d2893a87a604368cb0891482551349">AddrSpaceManager::resolveConstant()</a>, and <a class="el" href="classMemoryState.html#ad1c31dbc7de2dfb6926537c7f9166e92">MemoryState::setMemoryBank()</a>.</p>

</div>
</div>
<a class="anchor" id="aa5502574575723e9af7ad3d3b8844fdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> * AddrSpace::getManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the space manager. </p>
<p>Every address space is associated with a manager of (all possible) spaces. This method recovers the address space manager object. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the address space manager </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#a8f26bb0b06e43bc0337085808c211e14">manage</a>.</p>

<p>Referenced by <a class="el" href="classJoinSpace.html#a782272458968df7a727e7d6280edc8d8">JoinSpace::decodeAttributes()</a>, <a class="el" href="classJoinSpace.html#a3627ef798a38b95cbc28d44ea44e05ba">JoinSpace::encodeAttributes()</a>, <a class="el" href="classJoinSpace.html#a5ba72eff2b1010e948b1696472979cdd">JoinSpace::printRaw()</a>, <a class="el" href="classJoinSpace.html#a7607cfde31c477ef860cca530b502445">JoinSpace::read()</a>, and <a class="el" href="classAddress.html#a079f391c59a43a0e0fb8a5c66eaf6f64">Address::renormalize()</a>.</p>

</div>
</div>
<a class="anchor" id="ab735a8026d27e65147f67fc1ebbdbe94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 AddrSpace::getMinimumPtrSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum pointer size for <b>this</b> space. </p>
<p>A value of 0 means the size must match exactly. If the space is truncated, or if there exists near pointers, this value may be non-zero. </p>

<p>References <a class="el" href="classAddrSpace.html#acd897fe79e11489f2c9204f4a07067fc">minimumPointerSize</a>.</p>

</div>
</div>
<a class="anchor" id="a9a1077feee89cf4434154e017a3360f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string &amp; AddrSpace::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name. </p>
<p>Every address space has a (unique) name, which is referred to especially in configuration files via XML. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of this space </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#aa0df0a80bf601ab9e4384a36e72f0c72">name</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a9d5300e7a40dba53c7c78fdacebfc6ed">AddrSpaceManager::assignShortcut()</a>, <a class="el" href="classSleighCompile.html#a1e433991d333e08656e9312892dee474">SleighCompile::checkCaseSensitivity()</a>, <a class="el" href="classMemoryState.html#a3d5ab62d64919a04fa45c63fe52b2ec4">MemoryState::getChunk()</a>, <a class="el" href="classSpacebaseSpace.html#af7eff646322d46a9bb2cbbcbb803b559">SpacebaseSpace::getSpacebase()</a>, <a class="el" href="classSpacebaseSpace.html#a411ab78960bb646724d0a3c675549921">SpacebaseSpace::getSpacebaseFull()</a>, <a class="el" href="classMemoryState.html#ae676a2cfb1a2f92c7a6f6d039eb555ec">MemoryState::getValue()</a>, <a class="el" href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">AddrSpaceManager::insertSpace()</a>, <a class="el" href="classRange.html#a22053e89923f137d55a4058d006aa5c3">Range::printBounds()</a>, <a class="el" href="classSpacebaseSpace.html#ae3b46970e8ea1b8204fd310b72d73cef">SpacebaseSpace::saveXml()</a>, <a class="el" href="classOverlaySpace.html#a944dd6926d25f90603295094c0ad2a3d">OverlaySpace::saveXml()</a>, <a class="el" href="classSpacebaseSpace.html#a8c5de8cd7feb232e04d7e50a85fb0e24">SpacebaseSpace::setBaseRegister()</a>, <a class="el" href="classMemoryState.html#aa8d03c2a848a00090098b75f1fe877e1">MemoryState::setChunk()</a>, and <a class="el" href="classMemoryState.html#af4abdf013cacfaa4cfbe223f3893a76a">MemoryState::setValue()</a>.</p>

</div>
</div>
<a class="anchor" id="ad21a14246466b6d6bc8bd5d592e86b69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb AddrSpace::getPointerLowerBound </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get lower bound for assuming an offset is a pointer. </p>
<p>Constant offsets are tested against <b>this</b> lower bound as a quick filter before attempting to lookup symbols. </p>
<dl class="section return"><dt>Returns</dt><dd>the minimum offset that will be inferred as a pointer </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#a8e5a220b549a1bac5d86a8ccaae68c2f">pointerLowerBound</a>.</p>

</div>
</div>
<a class="anchor" id="ac7dfc6a5657075b0f777cfd938b8dc1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb AddrSpace::getPointerUpperBound </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get upper bound for assuming an offset is a pointer. </p>
<p>Constant offsets are tested against <b>this</b> upper bound as a quick filter before attempting to lookup symbols. </p>
<dl class="section return"><dt>Returns</dt><dd>the maximum offset that will be inferred as a pointer </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#a9314f29b21a32cc860db914606991912">pointerUpperBound</a>.</p>

</div>
</div>
<a class="anchor" id="a10c33b5d21f18a7a06b2d5e083f786c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char AddrSpace::getShortcut </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the shortcut character. </p>
<p>Return a unique short cut character that is associated with this space. The shortcut character can be used by the read method to quickly specify the space of an address. </p>
<dl class="section return"><dt>Returns</dt><dd>the shortcut character </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#ad51e6f51e1f0c3307e3a41a9d25e25dd">shortcut</a>.</p>

<p>Referenced by <a class="el" href="classAddress.html#af0f2d71168775f819e4e482c2e13c1b9">Address::getShortcut()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b16390dfa556c9bdd6fe5b31448f7d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp; AddrSpace::getSpacebase </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a base register that creates this virtual space. </p>
<p>For virtual spaces, like the stack space, this routine returns the location information for a base register of the space. This routine will throw an exception if the register does not exist </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>is the index of the base register starting at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="structVarnodeData.html" title="Data defining a specific memory location. ">VarnodeData</a> that describes the register </dd></dl>

<p>Reimplemented in <a class="el" href="classSpacebaseSpace.html#af7eff646322d46a9bb2cbbcbb803b559">SpacebaseSpace</a>.</p>

<p>References <a class="el" href="classAddrSpace.html#aa0df0a80bf601ab9e4384a36e72f0c72">name</a>.</p>

</div>
</div>
<a class="anchor" id="aa697bc18ef49fd35c33845be9d9d2af6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structVarnodeData.html">VarnodeData</a> &amp; AddrSpace::getSpacebaseFull </td>
          <td>(</td>
          <td class="paramtype">int4&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return original spacebase register before truncation. </p>
<p>If a stack pointer is truncated to fit the stack space, we may need to know the extent of the original register </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>is the index of the base register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the original register before truncation </dd></dl>

<p>Reimplemented in <a class="el" href="classSpacebaseSpace.html#a411ab78960bb646724d0a3c675549921">SpacebaseSpace</a>.</p>

<p>References <a class="el" href="classAddrSpace.html#aa0df0a80bf601ab9e4384a36e72f0c72">name</a>.</p>

</div>
</div>
<a class="anchor" id="affd0745190cc202feaec683a31f043d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTranslate.html">Translate</a> * AddrSpace::getTrans </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the processor translator. </p>
<p>Every address space is associated with a processor which may have additional objects like registers etc. associated with it. This method returns a pointer to that processor translator </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <a class="el" href="classTranslate.html" title="The interface to a translation engine for a processor. ">Translate</a> object </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#ac12eb398085cfc5ea04614d13f7c81a3">trans</a>.</p>

<p>Referenced by <a class="el" href="classJoinSpace.html#a782272458968df7a727e7d6280edc8d8">JoinSpace::decodeAttributes()</a>, <a class="el" href="structVarnodeData.html#ad620f74a51a72a652bf518571e351957">VarnodeData::decodeFromAttributes()</a>, <a class="el" href="classRange.html#a94744dd422421a5578aaca9fb6f382bf">Range::decodeFromAttributes()</a>, <a class="el" href="classRange.html#a1f471967fde21f530f087c799681278a">Range::Range()</a>, and <a class="el" href="classJoinSpace.html#a7607cfde31c477ef860cca530b502445">JoinSpace::read()</a>.</p>

</div>
</div>
<a class="anchor" id="a219ee14b2c9fef027078b63c8b485e76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="space_8hh.html#a1a83535cca68b7ca3f25bfad70262231">spacetype</a> AddrSpace::getType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of space. </p>
<p>Return the defining type for this address space.</p>
<ul>
<li>IPTR_CONSTANT for the constant space</li>
<li>IPTR_PROCESSOR for a normal space</li>
<li>IPTR_INTERNAL for the temporary register space</li>
<li>IPTR_FSPEC for special FuncCallSpecs references</li>
<li>IPTR_IOP for special PcodeOp references <dl class="section return"><dt>Returns</dt><dd>the basic type of this space </dd></dl>
</li>
</ul>

<p>References <a class="el" href="classAddrSpace.html#ac3dc27910401c5a153026ed919d99466">type</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#a9d5300e7a40dba53c7c78fdacebfc6ed">AddrSpaceManager::assignShortcut()</a>, <a class="el" href="classSleighCompile.html#a1e433991d333e08656e9312892dee474">SleighCompile::checkCaseSensitivity()</a>, <a class="el" href="classAddrSpaceManager.html#a1cfc5383270584be6e9b974114e65f13">AddrSpaceManager::constructJoinAddress()</a>, <a class="el" href="classMemoryState.html#ae676a2cfb1a2f92c7a6f6d039eb555ec">MemoryState::getValue()</a>, <a class="el" href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">AddrSpaceManager::insertSpace()</a>, <a class="el" href="classAddress.html#a5b132480ba80a42ba433f52b00164f91">Address::isConstant()</a>, <a class="el" href="classAddress.html#af320224a1a004a7bc94d2fa8ac474835">Address::isJoin()</a>, <a class="el" href="classAddress.html#a14bcd73e2401a3416abd1ee02b0bd2f4">Address::overlap()</a>, <a class="el" href="classAddress.html#a079f391c59a43a0e0fb8a5c66eaf6f64">Address::renormalize()</a>, and <a class="el" href="classSleighBase.html#a661ffc811ae5d7f4ed123b1eb495df94">SleighBase::saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a3d94aea39c4fc962e493b81452afe8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 AddrSpace::getWordSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the addressable unit size. </p>
<p>This method indicates the number of bytes contained in an <em>addressable</em> <em>unit</em> of this space. This is almost always 1, but can be any other small integer. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes in a unit </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#a01a3c9c83f617703abed64d7c6de849a">wordsize</a>.</p>

<p>Referenced by <a class="el" href="classRawLoadImage.html#aee25cd14ca80ad47db0b17d56cc31180">RawLoadImage::adjustVma()</a>, <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>, <a class="el" href="classEmulateMemory.html#ad612d22e967669919fd5c8538ade212f">EmulateMemory::executeLoad()</a>, <a class="el" href="classEmulateMemory.html#a3fed95d66c73d4dad23532f959a9417d">EmulateMemory::executeStore()</a>, <a class="el" href="classAddrSpaceManager.html#ae16363aa88c3c9fd1859fc8d36ae9273">AddrSpaceManager::parseAddressSimple()</a>, and <a class="el" href="classAddrSpaceManager.html#a27d2893a87a604368cb0891482551349">AddrSpaceManager::resolveConstant()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e91f272c5e148c8e75e139abbe19a8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrSpace::hasPhysical </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <b>true</b> if data is physically stored in this. </p>
<p>This routine returns <b>true</b>, if, like most spaces, the space has actual read/writeable bytes associated with it. Some spaces, like the <em>constant</em> space, do not. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the space has physical data in it. </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>, and <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a91dce97e6f6b850d04eb182edde6e2c6">hasphysical</a>.</p>

<p>Referenced by <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>, and <a class="el" href="classAddrSpace.html#a402a44d9589f7222560a6eb0aecf26db">saveBasicAttributes()</a>.</p>

</div>
</div>
<a class="anchor" id="aee713265281a230a8d25ea84328c37de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrSpace::isBigEndian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <b>true</b> if values in this space are big endian. </p>
<p>If integer values stored in this space are encoded in this space using the big endian format, then return <b>true</b>. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the space is big endian </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451a8d907075fd50528d0ac10d43af899be2">big_endian</a>, and <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>.</p>

<p>Referenced by <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>, <a class="el" href="classMemoryImage.html#a16130eaadd5034c19262d7e022acfb92">MemoryImage::find()</a>, <a class="el" href="classMemoryBank.html#acb2cdb307328079da661634d3c3050e2">MemoryBank::getPage()</a>, <a class="el" href="classContextDatabase.html#af74b40c20b8ed3c3b7b4f667da6eb182">ContextDatabase::getTrackedValue()</a>, <a class="el" href="classMemoryBank.html#a80d7b700eda74b93ca0841db4cbce1c0">MemoryBank::getValue()</a>, <a class="el" href="classAddress.html#ae7209c4a9300045576cf400b7443981e">Address::isBigEndian()</a>, <a class="el" href="classAddress.html#a7de8fd2dd0029f985341ec5bb3530008">Address::isContiguous()</a>, <a class="el" href="classAddress.html#a87bb3dfe1bd894305f137aac061c8707">Address::justifiedContain()</a>, <a class="el" href="classAddrSpace.html#a402a44d9589f7222560a6eb0aecf26db">saveBasicAttributes()</a>, <a class="el" href="classSpacebaseSpace.html#a8c5de8cd7feb232e04d7e50a85fb0e24">SpacebaseSpace::setBaseRegister()</a>, <a class="el" href="classMemoryBank.html#a68bf2318442e1f7da99ae85f63f9df19">MemoryBank::setPage()</a>, and <a class="el" href="classMemoryBank.html#a331f70cbc9d2c7172ebbaaa7e185c1e9">MemoryBank::setValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c612644dfaf2e8c857c461e67fb14ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrSpace::isFormalStackSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <b>true</b> if <b>this</b> is attached to the formal <b>stack</b> <b>pointer</b>. </p>
<p>Currently an architecture can declare only one formal stack pointer. </p>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>, and <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451aa54bdb7e06b55e1bed3ece9eb0864859">formal_stackspace</a>.</p>

</div>
</div>
<a class="anchor" id="a9c88339e07b5da212fee17205ddf20d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrSpace::isHeritaged </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <b>true</b> if dataflow has been traced. </p>
<p>During analysis, memory locations in most spaces need to have their data-flow traced. This method returns <b>true</b> for these spaces. For some of the special spaces, like the <em>constant</em> space, tracing data flow makes no sense, and this routine will return <b>false</b>. </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if this space's data-flow is analyzed </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>, and <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451aaa1675e833af050897d4ad66c138f1b4">heritaged</a>.</p>

</div>
</div>
<a class="anchor" id="a34059c36f09aeab6e6585317be85dd32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrSpace::isReverseJustified </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <b>true</b> if alignment justification does not match endianness. </p>
<p>Certain architectures or compilers specify an alignment for accessing words within the space The space required for a variable must be rounded up to the alignment. For variables smaller than the alignment, there is the issue of how the variable is "justified" within the aligned word. Usually the justification depends on the endianness of the space, for certain weird cases the justification may be the opposite of the endianness. </p>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>, and <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451abb22ff2778e1876ccf90657fc6df801f">reverse_justification</a>.</p>

</div>
</div>
<a class="anchor" id="aa7472d8a944382dab56e41ba5deca72c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrSpace::isTruncated </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <b>true</b> if this space is truncated from its original size. </p>
<p>If this method returns <b>true</b>, the logical form of this space is truncated from its actual size Pointers may refer to this original size put the most significant bytes are ignored </p>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>, and <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451ad16f38794d350a82a0af64e95b933f50">truncated</a>.</p>

</div>
</div>
<a class="anchor" id="aae785e311543d4e95c7d344b0c93823c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 AddrSpace::numSpacebase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of base registers associated with this space. </p>
<p>Some spaces are "virtual", like the stack spaces, where addresses are really relative to a base pointer stored in a register, like the stackpointer. This routine will return non-zero if <b>this</b> space is virtual and there is 1 (or more) associated pointer registers </p>
<dl class="section return"><dt>Returns</dt><dd>the number of base registers associated with this space </dd></dl>

<p>Reimplemented in <a class="el" href="classSpacebaseSpace.html#a5223e299556750126cf57f17560a52b5">SpacebaseSpace</a>.</p>

</div>
</div>
<a class="anchor" id="a23cf84c2900da85d1aeb5c737182f4e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpace::printOffset </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an address offset to a stream. </p>
<p>Print the <em>offset</em> as hexidecimal digits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the stream to write to </td></tr>
    <tr><td class="paramname">offset</td><td>is the offset to be printed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a28ec850803f89be4db6c85669573cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpace::printRaw </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an address in this space to a stream. </p>
<p>This is a printing method for the debugging routines. It prints taking into account the <em>wordsize</em>, adding a "+n" if the offset is not on-cut with wordsize. It also returns the expected/typical size of values from this space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the stream being written </td></tr>
    <tr><td class="paramname">offset</td><td>is the offset to be printed </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classJoinSpace.html#a5ba72eff2b1010e948b1696472979cdd">JoinSpace</a>, <a class="el" href="classOtherSpace.html#ad4c848651e6537e5011e5c60c98695f0">OtherSpace</a>, and <a class="el" href="classConstantSpace.html#ad6431cf5f166aa25e7f378de4884f4f6">ConstantSpace</a>.</p>

<p>References <a class="el" href="classAddrSpace.html#a3c9149df492bdcaccc208eac261e8365">byteToAddress()</a>, <a class="el" href="classAddrSpace.html#ac0cfccb152e2d1f13cbb70e253cf69bf">getAddrSize()</a>, and <a class="el" href="classAddrSpace.html#a01a3c9c83f617703abed64d7c6de849a">wordsize</a>.</p>

<p>Referenced by <a class="el" href="classAddress.html#a040ac0edbb01bd26c8956130ec4ef20e">Address::printRaw()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a7fb8caa90194445f8e70d2e88557e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb AddrSpace::read </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int4 &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read in an address (and possible size) from a string. </p>
<p>For the console mode, an address space can tailor how it converts user strings into offsets within the space. The base routine can read and convert register names as well as absolute hex addresses. A size can be indicated by appending a ':' and integer, .i.e. 0x1000:2. Offsets within a register can be indicated by appending a '+' and integer, i.e. eax+2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the string to be parsed </td></tr>
    <tr><td class="paramname">size</td><td>is a reference to the size being returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parsed offset </dd></dl>

<p>Reimplemented in <a class="el" href="classJoinSpace.html#a7607cfde31c477ef860cca530b502445">JoinSpace</a>.</p>

<p>References <a class="el" href="classAddrSpace.html#af5925a4ae67a290f59bf17533fac62b4">addressToByte()</a>, <a class="el" href="classAddrSpaceManager.html#ab8a93c129bd2799a82cccfc7df915942">AddrSpaceManager::getDefaultSize()</a>, <a class="el" href="classTranslate.html#a3a62c460db4eccc285fa3dd29dd4a29b">Translate::getRegister()</a>, <a class="el" href="classAddrSpace.html#a8f26bb0b06e43bc0337085808c211e14">manage</a>, <a class="el" href="structVarnodeData.html#a1a511384ee72e847b51423cc99c8233e">VarnodeData::offset</a>, <a class="el" href="classAddrSpace.html#ac12eb398085cfc5ea04614d13f7c81a3">trans</a>, and <a class="el" href="classAddrSpace.html#a01a3c9c83f617703abed64d7c6de849a">wordsize</a>.</p>

<p>Referenced by <a class="el" href="classAddress.html#a10953bd3fe65b279ee102a69d43e2d27">Address::read()</a>, and <a class="el" href="classJoinSpace.html#a7607cfde31c477ef860cca530b502445">JoinSpace::read()</a>.</p>

</div>
</div>
<a class="anchor" id="a402a44d9589f7222560a6eb0aecf26db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpace::saveBasicAttributes </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the XML attributes of this space. </p>
<p>Save the <em>name</em>, <em>index</em>, <em>bigendian</em>, <em>delay</em>, <em>size</em>, <em>wordsize</em>, and <em>physical</em> attributes which are common with all address spaces derived from <a class="el" href="classAddrSpace.html" title="A region where processor data is stored. ">AddrSpace</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the stream where the attributes are written </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="xml_8hh.html#a0fa1b18d881c70abd1489da2ba2f6792">a_v()</a>, <a class="el" href="xml_8hh.html#a87634423f394bc832a51957ee6fc85c9">a_v_b()</a>, <a class="el" href="xml_8hh.html#aa12f4a381037faf4e90d1876bb44aa02">a_v_i()</a>, <a class="el" href="classAddrSpace.html#a05c9b715d49d562e566ca392818fb798">addressSize</a>, <a class="el" href="classAddrSpace.html#aa2fd37355d0ed2ebee552ac944f67d95">deadcodedelay</a>, <a class="el" href="classAddrSpace.html#adb1ad3a09f9860eac23dd34f910808cd">delay</a>, <a class="el" href="classAddrSpace.html#a2e91f272c5e148c8e75e139abbe19a8b">hasPhysical()</a>, <a class="el" href="classAddrSpace.html#ace333a37cd6fe6ae2c52cd9d64d7269e">index</a>, <a class="el" href="classAddrSpace.html#aee713265281a230a8d25ea84328c37de">isBigEndian()</a>, <a class="el" href="classAddrSpace.html#aa0df0a80bf601ab9e4384a36e72f0c72">name</a>, and <a class="el" href="classAddrSpace.html#a01a3c9c83f617703abed64d7c6de849a">wordsize</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpace.html#acec4ae729130858e8370b98a2cc9ffb4">saveXml()</a>, <a class="el" href="classSpacebaseSpace.html#ae3b46970e8ea1b8204fd310b72d73cef">SpacebaseSpace::saveXml()</a>, <a class="el" href="classOtherSpace.html#a2a139cc0fb62b0ee1e0dcecec57e8d25">OtherSpace::saveXml()</a>, and <a class="el" href="classUniqueSpace.html#a07f2575cf8013f3f48e6d9cc61286471">UniqueSpace::saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="acec4ae729130858e8370b98a2cc9ffb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpace::saveXml </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the details of this space as XML. </p>
<p>Write a tag fully describing the details of this space suitable for later recovery via decode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the stream being written </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classOverlaySpace.html#a944dd6926d25f90603295094c0ad2a3d">OverlaySpace</a>, <a class="el" href="classJoinSpace.html#a289cb7467c6ad0fd0443e05c931ee221">JoinSpace</a>, <a class="el" href="classUniqueSpace.html#a07f2575cf8013f3f48e6d9cc61286471">UniqueSpace</a>, <a class="el" href="classOtherSpace.html#a2a139cc0fb62b0ee1e0dcecec57e8d25">OtherSpace</a>, <a class="el" href="classConstantSpace.html#a7f3c059250bcae4a5748db42feb4ec3f">ConstantSpace</a>, and <a class="el" href="classSpacebaseSpace.html#ae3b46970e8ea1b8204fd310b72d73cef">SpacebaseSpace</a>.</p>

<p>References <a class="el" href="classAddrSpace.html#a402a44d9589f7222560a6eb0aecf26db">saveBasicAttributes()</a>.</p>

<p>Referenced by <a class="el" href="classSleighBase.html#a661ffc811ae5d7f4ed123b1eb495df94">SleighBase::saveXml()</a>.</p>

</div>
</div>
<a class="anchor" id="a3dd14c033be519525d486fcbc94a2bf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpace::setFlags </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>fl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a cached attribute. </p>
<p>An internal method for derived classes to set space attributes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fl</td><td>is the set of attributes to be set </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#af94e5466d60e021837ae49d4093ea6b5">flags</a>.</p>

<p>Referenced by <a class="el" href="classConstantSpace.html#a36cf29b192ec6776dda7cd11ca8f8d07">ConstantSpace::ConstantSpace()</a>, <a class="el" href="classOverlaySpace.html#ad1c0eee21587345d884d078ff59a2aee">OverlaySpace::decode()</a>, <a class="el" href="classAddrSpaceManager.html#a89658bd677414a271a918f0f37af0bd6">AddrSpaceManager::insertSpace()</a>, <a class="el" href="classAddrSpaceManager.html#aba1c818ccc3950c188e06df08746725f">AddrSpaceManager::markNearPointers()</a>, <a class="el" href="classOtherSpace.html#acf1d9a8da9c19e9f5157af4ef2be179a">OtherSpace::OtherSpace()</a>, <a class="el" href="classOverlaySpace.html#a4ff9ec9fa7ed004c685f6f34c9978c09">OverlaySpace::OverlaySpace()</a>, <a class="el" href="classAddrSpaceManager.html#abdab85595c68e18ab86dd42af914f35b">AddrSpaceManager::setReverseJustified()</a>, <a class="el" href="classSpacebaseSpace.html#aaf2740fbd3a8ab8ed02d0d4b45cd64de">SpacebaseSpace::SpacebaseSpace()</a>, <a class="el" href="classAddrSpace.html#a84ecacea771a34c4349d1f31272316c7">truncateSpace()</a>, and <a class="el" href="classUniqueSpace.html#ae51a769e9fa8f3143357214e16686b22">UniqueSpace::UniqueSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="a717c89d2bce8e930d230fa24227d7caa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AddrSpace::stackGrowsNegative </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <b>true</b> if a stack in this space grows negative. </p>
<p>For stack (or other spacebase) spaces, this routine returns <b>true</b> if the space can viewed as a stack and a <b>push</b> operation causes the spacebase pointer to be decreased (grow negative) </p>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if stacks grow in negative direction. </dd></dl>

<p>Reimplemented in <a class="el" href="classSpacebaseSpace.html#ad3e6f17ea2a3b5d9902a6b37be1787e8">SpacebaseSpace</a>.</p>

</div>
</div>
<a class="anchor" id="a84ecacea771a34c4349d1f31272316c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AddrSpace::truncateSpace </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>newsize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The logical form of the space is truncated from its actual size Pointers may refer to this original size put the most significant bytes are ignored </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newsize</td><td>is the size (in bytes) of the truncated (logical) space </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classAddrSpace.html#a05c9b715d49d562e566ca392818fb798">addressSize</a>, <a class="el" href="classAddrSpace.html#af61640170c0baa861bbacee0e5c22a31">calcScaleMask()</a>, <a class="el" href="classAddrSpace.html#acd897fe79e11489f2c9204f4a07067fc">minimumPointerSize</a>, <a class="el" href="classAddrSpace.html#a3dd14c033be519525d486fcbc94a2bf7">setFlags()</a>, and <a class="el" href="classAddrSpace.html#a5f6ad75f3ae456a8734ced8047818451ad16f38794d350a82a0af64e95b933f50">truncated</a>.</p>

<p>Referenced by <a class="el" href="classAddrSpaceManager.html#aef7d980ea2fc0c6450e941fd7dbec7e6">AddrSpaceManager::truncateSpace()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b66b527431243c6ea0bb471d813c5f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb AddrSpace::wrapOffset </td>
          <td>(</td>
          <td class="paramtype">uintb&#160;</td>
          <td class="paramname"><em>off</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap -off- to the offset that fits into this space. </p>
<p>Calculate <em>off</em> modulo the size of this address space in order to construct the offset "equivalent" to <em>off</em> that fits properly into this space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>is the offset requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the wrapped offset </dd></dl>

<p>References <a class="el" href="classAddrSpace.html#a651b636a4b50b7e54ad81fc09c720b84">highest</a>.</p>

<p>Referenced by <a class="el" href="classSleighBuilder.html#ad1b67f65ebe1781105eadcb54fbecbe7">SleighBuilder::generateLocation()</a>, <a class="el" href="classSleighBuilder.html#a6109efed3a4d919bec0cb600694d122f">SleighBuilder::generatePointer()</a>, <a class="el" href="classAddress.html#a7de8fd2dd0029f985341ec5bb3530008">Address::isContiguous()</a>, <a class="el" href="classAddress.html#a2a440c026e09b7ec2d2cb361301c6164">Address::operator+()</a>, <a class="el" href="classAddress.html#a239158df52ba68f63d5d697b17067743">Address::operator-()</a>, <a class="el" href="classAddress.html#a14bcd73e2401a3416abd1ee02b0bd2f4">Address::overlap()</a>, and <a class="el" href="classAddrSpaceManager.html#a27d2893a87a604368cb0891482551349">AddrSpaceManager::resolveConstant()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="space_8hh.html">space.hh</a></li>
<li>space.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
