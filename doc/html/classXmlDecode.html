<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>decompiler: XmlDecode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">decompiler
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classXmlDecode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">XmlDecode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An XML based decoder.  
 <a href="classXmlDecode.html#details">More...</a></p>

<p><code>#include &lt;marshal.hh&gt;</code></p>
<div class="dynheader">
Inheritance diagram for XmlDecode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classXmlDecode.png" usemap="#XmlDecode_map" alt=""/>
  <map id="XmlDecode_map" name="XmlDecode_map">
<area href="classDecoder.html" title="A class for reading structured data from a stream. " alt="Decoder" shape="rect" coords="0,0,77,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab1cac974648218839092540cef10780f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1cac974648218839092540cef10780f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#ab1cac974648218839092540cef10780f">XmlDecode</a> (const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *spc, const <a class="el" href="classElement.html">Element</a> *root)</td></tr>
<tr class="memdesc:ab1cac974648218839092540cef10780f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with preparsed root. <br/></td></tr>
<tr class="separator:ab1cac974648218839092540cef10780f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77be2587671acd036dfb7af42a5a7066"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77be2587671acd036dfb7af42a5a7066"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a77be2587671acd036dfb7af42a5a7066">XmlDecode</a> (const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *spc)</td></tr>
<tr class="memdesc:a77be2587671acd036dfb7af42a5a7066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for use with ingestStream. <br/></td></tr>
<tr class="separator:a77be2587671acd036dfb7af42a5a7066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc58b55a1bdadb3b982307b848fac6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dc58b55a1bdadb3b982307b848fac6a"></a>
const <a class="el" href="classElement.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a9dc58b55a1bdadb3b982307b848fac6a">getCurrentXmlElement</a> (void) const </td></tr>
<tr class="memdesc:a9dc58b55a1bdadb3b982307b848fac6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to underlying XML element object. <br/></td></tr>
<tr class="separator:a9dc58b55a1bdadb3b982307b848fac6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9039549449d97bdd27f2e316db7a9052"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a9039549449d97bdd27f2e316db7a9052">ingestStream</a> (istream &amp;s)</td></tr>
<tr class="memdesc:a9039549449d97bdd27f2e316db7a9052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare to decode a given stream.  <a href="#a9039549449d97bdd27f2e316db7a9052">More...</a><br/></td></tr>
<tr class="separator:a9039549449d97bdd27f2e316db7a9052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c7ee140e1b6675b0f54a3865377be8"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#af6c7ee140e1b6675b0f54a3865377be8">peekElement</a> (void)</td></tr>
<tr class="memdesc:af6c7ee140e1b6675b0f54a3865377be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the next child element of the current parent, without traversing in (opening) it.  <a href="#af6c7ee140e1b6675b0f54a3865377be8">More...</a><br/></td></tr>
<tr class="separator:af6c7ee140e1b6675b0f54a3865377be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab85b69a8ea29222626340d23be11a4"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a3ab85b69a8ea29222626340d23be11a4">openElement</a> (void)</td></tr>
<tr class="memdesc:a3ab85b69a8ea29222626340d23be11a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open (traverse into) the next child element of the current parent.  <a href="#a3ab85b69a8ea29222626340d23be11a4">More...</a><br/></td></tr>
<tr class="separator:a3ab85b69a8ea29222626340d23be11a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b9beb021c1ce4c9160524b14155e96"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#ae9b9beb021c1ce4c9160524b14155e96">openElement</a> (const <a class="el" href="classElementId.html">ElementId</a> &amp;elemId)</td></tr>
<tr class="memdesc:ae9b9beb021c1ce4c9160524b14155e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open (traverse into) the next child element, which must be of a specific type.  <a href="#ae9b9beb021c1ce4c9160524b14155e96">More...</a><br/></td></tr>
<tr class="separator:ae9b9beb021c1ce4c9160524b14155e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e50db3b9a26f220bdca3b2e0c9a901"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#aa8e50db3b9a26f220bdca3b2e0c9a901">closeElement</a> (uint4 id)</td></tr>
<tr class="memdesc:aa8e50db3b9a26f220bdca3b2e0c9a901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the current element.  <a href="#aa8e50db3b9a26f220bdca3b2e0c9a901">More...</a><br/></td></tr>
<tr class="separator:aa8e50db3b9a26f220bdca3b2e0c9a901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084dcab64aaceb413b66a93ccf1e7970"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a084dcab64aaceb413b66a93ccf1e7970">closeElementSkipping</a> (uint4 id)</td></tr>
<tr class="memdesc:a084dcab64aaceb413b66a93ccf1e7970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the current element, skipping any child elements that have not yet been parsed.  <a href="#a084dcab64aaceb413b66a93ccf1e7970">More...</a><br/></td></tr>
<tr class="separator:a084dcab64aaceb413b66a93ccf1e7970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe976dd55bf980879066e4180686e2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#acfe976dd55bf980879066e4180686e2b">rewindAttributes</a> (void)</td></tr>
<tr class="memdesc:acfe976dd55bf980879066e4180686e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset attribute traversal for the current element.  <a href="#acfe976dd55bf980879066e4180686e2b">More...</a><br/></td></tr>
<tr class="separator:acfe976dd55bf980879066e4180686e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad696ae2412f215cdf74ea373d7d9be3c"><td class="memItemLeft" align="right" valign="top">virtual uint4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#ad696ae2412f215cdf74ea373d7d9be3c">getNextAttributeId</a> (void)</td></tr>
<tr class="memdesc:ad696ae2412f215cdf74ea373d7d9be3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next attribute id for the current element.  <a href="#ad696ae2412f215cdf74ea373d7d9be3c">More...</a><br/></td></tr>
<tr class="separator:ad696ae2412f215cdf74ea373d7d9be3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a13d4fbff3bc5e7ab88f718d1594d65"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a9a13d4fbff3bc5e7ab88f718d1594d65">readBool</a> (void)</td></tr>
<tr class="memdesc:a9a13d4fbff3bc5e7ab88f718d1594d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as a boolean value.  <a href="#a9a13d4fbff3bc5e7ab88f718d1594d65">More...</a><br/></td></tr>
<tr class="separator:a9a13d4fbff3bc5e7ab88f718d1594d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af329fb28ce197553092af8d07e9d5dc6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#af329fb28ce197553092af8d07e9d5dc6">readBool</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)</td></tr>
<tr class="memdesc:af329fb28ce197553092af8d07e9d5dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as a boolean value.  <a href="#af329fb28ce197553092af8d07e9d5dc6">More...</a><br/></td></tr>
<tr class="separator:af329fb28ce197553092af8d07e9d5dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5b7686e66310aa5d13534bd0d7dbe3"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a6c5b7686e66310aa5d13534bd0d7dbe3">readSignedInteger</a> (void)</td></tr>
<tr class="memdesc:a6c5b7686e66310aa5d13534bd0d7dbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as a signed integer value.  <a href="#a6c5b7686e66310aa5d13534bd0d7dbe3">More...</a><br/></td></tr>
<tr class="separator:a6c5b7686e66310aa5d13534bd0d7dbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90f328dc0c346d8323aa8e32bbe60a7"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#af90f328dc0c346d8323aa8e32bbe60a7">readSignedInteger</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)</td></tr>
<tr class="memdesc:af90f328dc0c346d8323aa8e32bbe60a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as a signed integer.  <a href="#af90f328dc0c346d8323aa8e32bbe60a7">More...</a><br/></td></tr>
<tr class="separator:af90f328dc0c346d8323aa8e32bbe60a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf043fa2688d7732fa6990052a70a4c"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#afbf043fa2688d7732fa6990052a70a4c">readSignedIntegerExpectString</a> (const string &amp;expect, intb expectval)</td></tr>
<tr class="memdesc:afbf043fa2688d7732fa6990052a70a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as either a signed integer value or a string.  <a href="#afbf043fa2688d7732fa6990052a70a4c">More...</a><br/></td></tr>
<tr class="separator:afbf043fa2688d7732fa6990052a70a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211b48088ce1256f335fca2102028599"><td class="memItemLeft" align="right" valign="top">virtual intb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a211b48088ce1256f335fca2102028599">readSignedIntegerExpectString</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId, const string &amp;expect, intb expectval)</td></tr>
<tr class="memdesc:a211b48088ce1256f335fca2102028599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as either a signed integer or a string.  <a href="#a211b48088ce1256f335fca2102028599">More...</a><br/></td></tr>
<tr class="separator:a211b48088ce1256f335fca2102028599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0413c852158d3219633bf6d10a6984"><td class="memItemLeft" align="right" valign="top">virtual uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a0c0413c852158d3219633bf6d10a6984">readUnsignedInteger</a> (void)</td></tr>
<tr class="memdesc:a0c0413c852158d3219633bf6d10a6984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as an unsigned integer value.  <a href="#a0c0413c852158d3219633bf6d10a6984">More...</a><br/></td></tr>
<tr class="separator:a0c0413c852158d3219633bf6d10a6984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f460096d7bcde0a84e96099d534da6a"><td class="memItemLeft" align="right" valign="top">virtual uintb&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a5f460096d7bcde0a84e96099d534da6a">readUnsignedInteger</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)</td></tr>
<tr class="memdesc:a5f460096d7bcde0a84e96099d534da6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and parse a specific attribute in the current element as an unsigned integer.  <a href="#a5f460096d7bcde0a84e96099d534da6a">More...</a><br/></td></tr>
<tr class="separator:a5f460096d7bcde0a84e96099d534da6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6017dcf41117fc94070b2ea603190f"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a3b6017dcf41117fc94070b2ea603190f">readString</a> (void)</td></tr>
<tr class="memdesc:a3b6017dcf41117fc94070b2ea603190f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as a string.  <a href="#a3b6017dcf41117fc94070b2ea603190f">More...</a><br/></td></tr>
<tr class="separator:a3b6017dcf41117fc94070b2ea603190f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f0b91832a3d9647dab65c5f9634d98"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a98f0b91832a3d9647dab65c5f9634d98">readString</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)</td></tr>
<tr class="memdesc:a98f0b91832a3d9647dab65c5f9634d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the specific attribute in the current element and return it as a string.  <a href="#a98f0b91832a3d9647dab65c5f9634d98">More...</a><br/></td></tr>
<tr class="separator:a98f0b91832a3d9647dab65c5f9634d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372e9e97f1e9a9ee2e3ca456d3bfd802"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a372e9e97f1e9a9ee2e3ca456d3bfd802">readSpace</a> (void)</td></tr>
<tr class="memdesc:a372e9e97f1e9a9ee2e3ca456d3bfd802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the current attribute as an address space.  <a href="#a372e9e97f1e9a9ee2e3ca456d3bfd802">More...</a><br/></td></tr>
<tr class="separator:a372e9e97f1e9a9ee2e3ca456d3bfd802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b15c5b9229daf7b662438ce5958952a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classAddrSpace.html">AddrSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a7b15c5b9229daf7b662438ce5958952a">readSpace</a> (const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;attribId)</td></tr>
<tr class="memdesc:a7b15c5b9229daf7b662438ce5958952a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the specific attribute in the current element and return it as an address space.  <a href="#a7b15c5b9229daf7b662438ce5958952a">More...</a><br/></td></tr>
<tr class="separator:a7b15c5b9229daf7b662438ce5958952a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classDecoder"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classDecoder')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classDecoder.html">Decoder</a></td></tr>
<tr class="memitem:ad742ab5418158e242bd8105561231143 inherit pub_methods_classDecoder"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad742ab5418158e242bd8105561231143"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#ad742ab5418158e242bd8105561231143">Decoder</a> (const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *spc)</td></tr>
<tr class="memdesc:ad742ab5418158e242bd8105561231143 inherit pub_methods_classDecoder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base constructor. <br/></td></tr>
<tr class="separator:ad742ab5418158e242bd8105561231143 inherit pub_methods_classDecoder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e1c337c5263c056415259df22bc284 inherit pub_methods_classDecoder"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7e1c337c5263c056415259df22bc284"></a>
const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#af7e1c337c5263c056415259df22bc284">getAddrSpaceManager</a> (void) const </td></tr>
<tr class="memdesc:af7e1c337c5263c056415259df22bc284 inherit pub_methods_classDecoder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the manager used for address space decoding. <br/></td></tr>
<tr class="separator:af7e1c337c5263c056415259df22bc284 inherit pub_methods_classDecoder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018cda43f7451dab35dfc6a4f262df46 inherit pub_methods_classDecoder"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a018cda43f7451dab35dfc6a4f262df46"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a018cda43f7451dab35dfc6a4f262df46">~Decoder</a> (void)</td></tr>
<tr class="memdesc:a018cda43f7451dab35dfc6a4f262df46 inherit pub_methods_classDecoder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a018cda43f7451dab35dfc6a4f262df46 inherit pub_methods_classDecoder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bc3e4fc9f888c1ee13b50afaa23103 inherit pub_methods_classDecoder"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#ad7bc3e4fc9f888c1ee13b50afaa23103">skipElement</a> (void)</td></tr>
<tr class="memdesc:ad7bc3e4fc9f888c1ee13b50afaa23103 inherit pub_methods_classDecoder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip parsing of the next element.  <a href="#ad7bc3e4fc9f888c1ee13b50afaa23103">More...</a><br/></td></tr>
<tr class="separator:ad7bc3e4fc9f888c1ee13b50afaa23103 inherit pub_methods_classDecoder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a24270496d92b1a78dd90b7db6e134636"><td class="memItemLeft" align="right" valign="top">int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a24270496d92b1a78dd90b7db6e134636">findMatchingAttribute</a> (const <a class="el" href="classElement.html">Element</a> *el, const string &amp;attribName)</td></tr>
<tr class="memdesc:a24270496d92b1a78dd90b7db6e134636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the attribute index, within the given element, for the given name.  <a href="#a24270496d92b1a78dd90b7db6e134636">More...</a><br/></td></tr>
<tr class="separator:a24270496d92b1a78dd90b7db6e134636"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aac06590f73a71344547eea6d9fc9fdf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac06590f73a71344547eea6d9fc9fdf3"></a>
<a class="el" href="classDocument.html">Document</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#aac06590f73a71344547eea6d9fc9fdf3">document</a></td></tr>
<tr class="memdesc:aac06590f73a71344547eea6d9fc9fdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">An ingested XML document, owned by <b>this</b> decoder. <br/></td></tr>
<tr class="separator:aac06590f73a71344547eea6d9fc9fdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8f89d6d09d674313b4a0cd271d820b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e8f89d6d09d674313b4a0cd271d820b"></a>
const <a class="el" href="classElement.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a4e8f89d6d09d674313b4a0cd271d820b">rootElement</a></td></tr>
<tr class="memdesc:a4e8f89d6d09d674313b4a0cd271d820b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root XML element to be decoded. <br/></td></tr>
<tr class="separator:a4e8f89d6d09d674313b4a0cd271d820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8f7773f7cb24cd6627e1c0a161a0b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd8f7773f7cb24cd6627e1c0a161a0b6"></a>
vector&lt; const <a class="el" href="classElement.html">Element</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a></td></tr>
<tr class="memdesc:afd8f7773f7cb24cd6627e1c0a161a0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack of currently <em>open</em> elements. <br/></td></tr>
<tr class="separator:afd8f7773f7cb24cd6627e1c0a161a0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0733ac56beac62762551252a0e18ee43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0733ac56beac62762551252a0e18ee43"></a>
vector&lt; List::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#a0733ac56beac62762551252a0e18ee43">iterStack</a></td></tr>
<tr class="memdesc:a0733ac56beac62762551252a0e18ee43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of next child for each <em>open</em> element. <br/></td></tr>
<tr class="separator:a0733ac56beac62762551252a0e18ee43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62786b9fc055b519abd4f642963ccf0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae62786b9fc055b519abd4f642963ccf0"></a>
int4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a></td></tr>
<tr class="memdesc:ae62786b9fc055b519abd4f642963ccf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of <em>current</em> attribute to parse (in <em>current</em> element) <br/></td></tr>
<tr class="separator:ae62786b9fc055b519abd4f642963ccf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classDecoder"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classDecoder')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classDecoder.html">Decoder</a></td></tr>
<tr class="memitem:a1710afd881dc823cd5920692685c47af inherit pro_attribs_classDecoder"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1710afd881dc823cd5920692685c47af"></a>
const <a class="el" href="classAddrSpaceManager.html">AddrSpaceManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDecoder.html#a1710afd881dc823cd5920692685c47af">spcManager</a></td></tr>
<tr class="memdesc:a1710afd881dc823cd5920692685c47af inherit pro_attribs_classDecoder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager for decoding address space attributes. <br/></td></tr>
<tr class="separator:a1710afd881dc823cd5920692685c47af inherit pro_attribs_classDecoder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An XML based decoder. </p>
<p>The underlying transfer encoding is an XML document. The decoder can either be initialized with an existing <a class="el" href="classElement.html" title="An XML element. A node in the DOM tree. ">Element</a> as the root of the data to transfer, or the <a class="el" href="classXmlDecode.html#a9039549449d97bdd27f2e316db7a9052" title="Prepare to decode a given stream. ">ingestStream()</a> method can be invoked to read the XML document from an input stream, in which case the decoder manages the <a class="el" href="classDocument.html" title="A complete in-memory XML document. ">Document</a> object. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa8e50db3b9a26f220bdca3b2e0c9a901"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XmlDecode::closeElement </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the current element. </p>
<p>The data for the current element is considered fully processed. If the element has additional children, an exception is thrown. The stream must indicate the end of the element in some way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the id of the element to close (which must be the current element) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classDecoder.html#a1837b91ab3c9d2a7f5b2711fe0a86a97">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>, <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classElementId.html#a7e6531dcbcfa10e01aea00596f3c3da3">ElementId::find()</a>, <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>, <a class="el" href="classElement.html#ac25b2c09b0a8d71dc9dc7ad8644810ce">Element::getName()</a>, and <a class="el" href="classXmlDecode.html#a0733ac56beac62762551252a0e18ee43">iterStack</a>.</p>

</div>
</div>
<a class="anchor" id="a084dcab64aaceb413b66a93ccf1e7970"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XmlDecode::closeElementSkipping </td>
          <td>(</td>
          <td class="paramtype">uint4&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the current element, skipping any child elements that have not yet been parsed. </p>
<p>This closes the given element, which must be current. If there are child elements that have not been parsed, this is not considered an error, and they are skipped over in the parse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>is the id of the element to close (which must be the current element) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classDecoder.html#a36a59712041e1dc3f7185440d665b3d3">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>, <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classElementId.html#a7e6531dcbcfa10e01aea00596f3c3da3">ElementId::find()</a>, <a class="el" href="classElement.html#ac25b2c09b0a8d71dc9dc7ad8644810ce">Element::getName()</a>, and <a class="el" href="classXmlDecode.html#a0733ac56beac62762551252a0e18ee43">iterStack</a>.</p>

</div>
</div>
<a class="anchor" id="a24270496d92b1a78dd90b7db6e134636"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int4 XmlDecode::findMatchingAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a> *&#160;</td>
          <td class="paramname"><em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>attribName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the attribute index, within the given element, for the given name. </p>
<p>Run through the attributes of the element until we find the one matching the name, or throw an exception otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>is the given element to search </td></tr>
    <tr><td class="paramname">attribName</td><td>is the attribute name to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matching attribute index </dd></dl>

<p>References <a class="el" href="classElement.html#a44c4700b8e55e8ea0f22e7a900e8bfba">Element::getAttributeName()</a>, and <a class="el" href="classElement.html#a637efeb8c6b73d2292e7ee5b73b9eac1">Element::getNumAttributes()</a>.</p>

<p>Referenced by <a class="el" href="classXmlDecode.html#af329fb28ce197553092af8d07e9d5dc6">readBool()</a>, <a class="el" href="classXmlDecode.html#af90f328dc0c346d8323aa8e32bbe60a7">readSignedInteger()</a>, <a class="el" href="classXmlDecode.html#a7b15c5b9229daf7b662438ce5958952a">readSpace()</a>, <a class="el" href="classXmlDecode.html#a98f0b91832a3d9647dab65c5f9634d98">readString()</a>, and <a class="el" href="classXmlDecode.html#a5f460096d7bcde0a84e96099d534da6a">readUnsignedInteger()</a>.</p>

</div>
</div>
<a class="anchor" id="ad696ae2412f215cdf74ea373d7d9be3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 XmlDecode::getNextAttributeId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the next attribute id for the current element. </p>
<p><a class="el" href="classAttributes.html" title="The attributes for a single XML element. ">Attributes</a> are automatically set up for traversal using this method, when the element is opened. If all attributes have been traversed (or there are no attributes), 0 is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the id of the next attribute or 0 </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#ad98ca46e0ea39c4ce713d4b14bc44772">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>, <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classAttributeId.html#ad6d0d5a05a80a0b9d3c67faa8e385e76">AttributeId::find()</a>, and <a class="el" href="classElement.html#a44c4700b8e55e8ea0f22e7a900e8bfba">Element::getAttributeName()</a>.</p>

</div>
</div>
<a class="anchor" id="a9039549449d97bdd27f2e316db7a9052"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XmlDecode::ingestStream </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare to decode a given stream. </p>
<p>Called once before any decoding. Currently this is assumed to make an internal copy of the stream data, i.e. the input stream is cleared before any decoding takes place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the given input stream to be decode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the stream was fully ingested </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a992d5adfdb5766ec56844e6d5c2d1457">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#aac06590f73a71344547eea6d9fc9fdf3">document</a>, <a class="el" href="classDocument.html#abde517d9851c72c569339eb5c59d3779">Document::getRoot()</a>, <a class="el" href="classXmlDecode.html#a4e8f89d6d09d674313b4a0cd271d820b">rootElement</a>, and <a class="el" href="xml_8hh.html#a4e0d1051f142e3711986dbb797049769">xml_tree()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ab85b69a8ea29222626340d23be11a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 XmlDecode::openElement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open (traverse into) the next child element of the current parent. </p>
<p>The child becomes the current parent. The list of attributes is initialized for use with getNextAttributeId. </p>
<dl class="section return"><dt>Returns</dt><dd>the id of the child element </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a9b21defb3b7d9023324df3bb8328c87f">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>, <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classElementId.html#a7e6531dcbcfa10e01aea00596f3c3da3">ElementId::find()</a>, <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>, <a class="el" href="classElement.html#ac25b2c09b0a8d71dc9dc7ad8644810ce">Element::getName()</a>, <a class="el" href="classXmlDecode.html#a0733ac56beac62762551252a0e18ee43">iterStack</a>, and <a class="el" href="classXmlDecode.html#a4e8f89d6d09d674313b4a0cd271d820b">rootElement</a>.</p>

</div>
</div>
<a class="anchor" id="ae9b9beb021c1ce4c9160524b14155e96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 XmlDecode::openElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElementId.html">ElementId</a> &amp;&#160;</td>
          <td class="paramname"><em>elemId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open (traverse into) the next child element, which must be of a specific type. </p>
<p>The child becomes the current parent, and its attributes are initialized for use with getNextAttributeId. The child must match the given element id or an exception is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elemId</td><td>is the given element id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the child element </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#ac6af23e00b46785ec0894c37a6f72d87">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>, <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>, <a class="el" href="classElementId.html#ab261eb071c7a9693554f809d15fb02fa">ElementId::getId()</a>, <a class="el" href="classElementId.html#afd21891c1fa1a0102395f7ddf34b347c">ElementId::getName()</a>, <a class="el" href="classElement.html#ac25b2c09b0a8d71dc9dc7ad8644810ce">Element::getName()</a>, <a class="el" href="classXmlDecode.html#a0733ac56beac62762551252a0e18ee43">iterStack</a>, and <a class="el" href="classXmlDecode.html#a4e8f89d6d09d674313b4a0cd271d820b">rootElement</a>.</p>

</div>
</div>
<a class="anchor" id="af6c7ee140e1b6675b0f54a3865377be8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint4 XmlDecode::peekElement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at the next child element of the current parent, without traversing in (opening) it. </p>
<p>The element id is returned, which can be compared to <a class="el" href="classElementId.html" title="An annotation for a specific collection of hierarchical data. ">ElementId</a> labels. If there are no remaining child elements to traverse, 0 is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the element id or 0 </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a5a196e06e948a4ab4023fe0e5d129377">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classElementId.html#a7e6531dcbcfa10e01aea00596f3c3da3">ElementId::find()</a>, <a class="el" href="classElement.html#aa002594c7d5b4feed9a855207c7dfe92">Element::getChildren()</a>, <a class="el" href="classElement.html#ac25b2c09b0a8d71dc9dc7ad8644810ce">Element::getName()</a>, <a class="el" href="classXmlDecode.html#a0733ac56beac62762551252a0e18ee43">iterStack</a>, and <a class="el" href="classXmlDecode.html#a4e8f89d6d09d674313b4a0cd271d820b">rootElement</a>.</p>

</div>
</div>
<a class="anchor" id="a9a13d4fbff3bc5e7ab88f718d1594d65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlDecode::readBool </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as a boolean value. </p>
<p>The last attribute, as returned by getNextAttributeId, is treated as a boolean, and its value is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the boolean value associated with the current attribute. </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a41a25fdd41dff502755f8c142c5a59d8">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>, <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

</div>
</div>
<a class="anchor" id="af329fb28ce197553092af8d07e9d5dc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool XmlDecode::readBool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as a boolean value. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then parsed as a boolean and its value returned. If there is no attribute matching the id, an exception is thrown. Parsing via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean value </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#af097ef2bdd296e892cc4c1c48639693e">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classXmlDecode.html#a24270496d92b1a78dd90b7db6e134636">findMatchingAttribute()</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classElement.html#a857c0199d1304ccb3e8fce8771c58195">Element::getContent()</a>, <a class="el" href="classAttributeId.html#a01db63c010eb304f1c117e145e5f0463">AttributeId::getName()</a>, and <a class="el" href="xml_8hh.html#ac2d01d7c2986f1143b2f6145311d093e">xml_readbool()</a>.</p>

</div>
</div>
<a class="anchor" id="a6c5b7686e66310aa5d13534bd0d7dbe3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intb XmlDecode::readSignedInteger </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as a signed integer value. </p>
<p>The last attribute, as returned by getNextAttributeId, is treated as a signed integer, and its value is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the signed integer value associated with the current attribute. </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a88c617582ce9540eca9519accbb8ee00">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>, <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, and <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>.</p>

</div>
</div>
<a class="anchor" id="af90f328dc0c346d8323aa8e32bbe60a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intb XmlDecode::readSignedInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as a signed integer. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then parsed as a signed integer and its value returned. If there is no attribute matching the id, an exception is thrown. Parsing via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the signed integer value </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a59999a0af09a7b5654fdb08febe7f3eb">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classXmlDecode.html#a24270496d92b1a78dd90b7db6e134636">findMatchingAttribute()</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classElement.html#a857c0199d1304ccb3e8fce8771c58195">Element::getContent()</a>, and <a class="el" href="classAttributeId.html#a01db63c010eb304f1c117e145e5f0463">AttributeId::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="afbf043fa2688d7732fa6990052a70a4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intb XmlDecode::readSignedIntegerExpectString </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>expect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intb&#160;</td>
          <td class="paramname"><em>expectval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as either a signed integer value or a string. </p>
<p>If the attribute is an integer, its value is returned. If the attribute is a string, it must match an expected string passed to the method, and a predetermined integer value associated with the string is returned. If the attribute neither matches the expected string nor is an integer, the return value is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expect</td><td>is the string value to expect if the attribute is encoded as a string </td></tr>
    <tr><td class="paramname">expectval</td><td>is the integer value to return if the attribute matches the expected string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoded integer or the integer value associated with the expected string </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a4e3deb10c5112cb984390b7a14262202">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>, <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, and <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a211b48088ce1256f335fca2102028599"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intb XmlDecode::readSignedIntegerExpectString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>expect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intb&#160;</td>
          <td class="paramname"><em>expectval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as either a signed integer or a string. </p>
<p>If the attribute is an integer, its value is parsed and returned. If the attribute is encoded as a string, it must match an expected string passed to this method. In this case, a predetermined integer value is passed back, indicating a matching string was parsed. If the attribute neither matches the expected string nor is an integer, the return value is undefined. If there is no attribute matching the id, an exception is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
    <tr><td class="paramname">expect</td><td>is the string to expect, if the attribute is not encoded as an integer </td></tr>
    <tr><td class="paramname">expectval</td><td>is the integer value to return if the attribute matches the expected string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoded integer or the integer value associated with the expected string </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#af003e43112b4d358a0d24b653de72d13">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#a3b6017dcf41117fc94070b2ea603190f">readString()</a>.</p>

</div>
</div>
<a class="anchor" id="a372e9e97f1e9a9ee2e3ca456d3bfd802"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * XmlDecode::readSpace </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as an address space. </p>
<p>The last attribute, as returned by getNextAttributeId, is returned as an address space. </p>
<dl class="section return"><dt>Returns</dt><dd>the address space associated with the current attribute. </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a698792800d19dede5dc90f8d091a0efb">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>, <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classAddrSpaceManager.html#a799fc65471e0b5201e2dd738f01dc34d">AddrSpaceManager::getSpaceByName()</a>, and <a class="el" href="classDecoder.html#a1710afd881dc823cd5920692685c47af">Decoder::spcManager</a>.</p>

</div>
</div>
<a class="anchor" id="a7b15c5b9229daf7b662438ce5958952a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAddrSpace.html">AddrSpace</a> * XmlDecode::readSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the specific attribute in the current element and return it as an address space. </p>
<p>Search attributes from the current element for a match to the given attribute id. Return this attribute as an address space. If there is no attribute matching the id, an exception is thrown. Parse via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address space associated with the attribute </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#ac5d2b96ed213096d7cc93a85c2e3c030">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classXmlDecode.html#a24270496d92b1a78dd90b7db6e134636">findMatchingAttribute()</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classElement.html#a857c0199d1304ccb3e8fce8771c58195">Element::getContent()</a>, <a class="el" href="classAttributeId.html#a01db63c010eb304f1c117e145e5f0463">AttributeId::getName()</a>, <a class="el" href="classAddrSpaceManager.html#a799fc65471e0b5201e2dd738f01dc34d">AddrSpaceManager::getSpaceByName()</a>, and <a class="el" href="classDecoder.html#a1710afd881dc823cd5920692685c47af">Decoder::spcManager</a>.</p>

</div>
</div>
<a class="anchor" id="a3b6017dcf41117fc94070b2ea603190f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string XmlDecode::readString </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as a string. </p>
<p>The last attribute, as returned by getNextAttributeId, is returned as a string. </p>
<dl class="section return"><dt>Returns</dt><dd>the string associated with the current attribute. </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a206874f59d968db5904c0d39ad6bfdee">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>, <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, and <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>.</p>

<p>Referenced by <a class="el" href="classXmlDecode.html#a211b48088ce1256f335fca2102028599">readSignedIntegerExpectString()</a>.</p>

</div>
</div>
<a class="anchor" id="a98f0b91832a3d9647dab65c5f9634d98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string XmlDecode::readString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the specific attribute in the current element and return it as a string. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then returned as a string. If there is no attribute matching the id, and exception is thrown. Parse via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string associated with the attribute </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a4403ec4674a01b257d4cb2494a40b25b">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classXmlDecode.html#a24270496d92b1a78dd90b7db6e134636">findMatchingAttribute()</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classElement.html#a857c0199d1304ccb3e8fce8771c58195">Element::getContent()</a>, and <a class="el" href="classAttributeId.html#a01db63c010eb304f1c117e145e5f0463">AttributeId::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c0413c852158d3219633bf6d10a6984"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb XmlDecode::readUnsignedInteger </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the current attribute as an unsigned integer value. </p>
<p>The last attribute, as returned by getNextAttributeId, is treated as an unsigned integer, and its value is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>the unsigned integer value associated with the current attribute. </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#a738ae1f9145b933f70748cf039afe847">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>, <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, and <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f460096d7bcde0a84e96099d534da6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintb XmlDecode::readUnsignedInteger </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAttributeId.html">AttributeId</a> &amp;&#160;</td>
          <td class="paramname"><em>attribId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and parse a specific attribute in the current element as an unsigned integer. </p>
<p>The set of attributes for the current element is searched for a match to the given attribute id. This attribute is then parsed as an unsigned integer and its value returned. If there is no attribute matching the id, an exception is thrown. Parsing via getNextAttributeId is reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribId</td><td>is the specific attribute id to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unsigned integer value </dd></dl>

<p>Implements <a class="el" href="classDecoder.html#af6f34bd56b4fce89f77d93135aeb5a57">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#afd8f7773f7cb24cd6627e1c0a161a0b6">elStack</a>, <a class="el" href="classXmlDecode.html#a24270496d92b1a78dd90b7db6e134636">findMatchingAttribute()</a>, <a class="el" href="classElement.html#a7336214ac0ea6275d9d9517b06661195">Element::getAttributeValue()</a>, <a class="el" href="classElement.html#a857c0199d1304ccb3e8fce8771c58195">Element::getContent()</a>, and <a class="el" href="classAttributeId.html#a01db63c010eb304f1c117e145e5f0463">AttributeId::getName()</a>.</p>

</div>
</div>
<a class="anchor" id="acfe976dd55bf980879066e4180686e2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void XmlDecode::rewindAttributes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset attribute traversal for the current element. </p>
<p><a class="el" href="classAttributes.html" title="The attributes for a single XML element. ">Attributes</a> for a single element can be traversed more than once using the getNextAttributeId method. </p>

<p>Implements <a class="el" href="classDecoder.html#af90d9a4d81b76e608dd59614c8259231">Decoder</a>.</p>

<p>References <a class="el" href="classXmlDecode.html#ae62786b9fc055b519abd4f642963ccf0">attributeIndex</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>marshal.hh</li>
<li>marshal.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
